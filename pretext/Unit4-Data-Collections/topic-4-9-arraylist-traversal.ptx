<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="topic-4-9-arraylist-traversal">
  <title><c>ArrayList</c> Traversals</title><introduction>
    
    <idx>ArrayList traversal</idx>
 <idx>traversal</idx>
 <idx>loop</idx>
 <idx>enhanced for</idx>
 <idx>IndexOutOfBoundsException</idx>
 <idx>ConcurrentModificationException</idx>

    <p>Traversing an <c>ArrayList</c> is when iteration (a loop) is used to access all or an ordered sequence of the elements in the <c>ArrayList</c>. Just like with arrays, we can use <c>while</c> loops, indexed <c>for</c> loops, or  enhanced <c>for</c> loops to traverse an  <c>ArrayList</c>. In a later lesson, we’ll also talk about recursion which is when a method calls itself over again which is another way you can traverse an array or <c>ArrayList</c>. In this lesson, we’ll focus on using loops.</p>
  </introduction>
  <subsection xml:id="enhanced-for-loop">
            <title>Enhanced For Loop</title>
            <idx><h>list</h><h>for-each loop</h></idx>

            
            <p>You can use an enhanced <c>for</c> loop to traverse all of the items in an
                <c>ArrayList</c>, just like you do with an array when you only care about the
                values in the list and not their indices. An example is shown in the <c>main</c>
                method below.</p>
            <p>Note however that you can’t use the enhanced <c>for</c> loop if you want to add or
                remove elements while traversing an <c>ArrayList</c>. If the size of an <c>ArrayList</c> is
                modified, such as by calling the <c>add</c> or <c>remove</c> methods, while it is
                being looped over, it will cause the loop to throw a
                <c>ConcurrentModificationException</c>. If you need to modify an <c>ArrayList</c>
                while looping over it, you’ll need to use a regular <c>while</c> or <c>for</c> loop.</p>

<activity label="listForEachLoop">
    <statement>
            <p>What does the following code do? Guess before you run it. Then, add another enhanced for each loop that computes the product of all the elements in myList by multiplying them. Print out the product after the new loop.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*; // import all classes in this package.

public class Test1
{
    public static void main(String[] args)
    {
        ArrayList&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;();
        myList.add(50);
        myList.add(30);
        myList.add(20);
        int total = 0;
        for (Integer value : myList)
        {
            total += value;
        }
        System.out.println("Sum of all elements: " + total);

        // Write a for-each loop that computes the product
        // of all the elements in myList and print out the product.

    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testExpected() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "100";
        boolean passed = output.contains(expect);
        getResults(expect, output, "Prints out sum", passed);
        assertTrue(passed);
    }

    @Test
    public void testProduct() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "30000";
        boolean passed = output.contains(expect);
        getResults(expect, output, "Prints out product", passed);
        assertTrue(passed);
    }

    @Test
    public void countForLoops()
    {
        String code = removeSpaces(getCode());
        int count = countOccurences(code, "for(Integer");
        boolean passed = count &gt;= 2;
        getResults("2", count + "", "Number of for each loops", passed);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>
<activity label="list_1" numbered="yes" adaptive="yes" indentation="show" language="java"><statement>
            <p>The following has the correct code for the method getScore plus at least one extra unneeded code statement.  This method will calculate and return the score for a word game.  The code should loop through all of the elements in wordList and if the length of the current word is 3 it should add one to the score, if the length of the word is 4 it should add 2 to the score, and if the length is greater than 4 it should add 3 to the score.  The method should return the score.  Drag the needed blocks from the left into the correct order on the right. Check your solution by clicking on the Check button.  You will be told if any of the blocks are in the wrong order or if you need to remove one or more blocks.  There is one extra block that is not needed in a correct solution.</p>
</statement>
<blocks><block order="9">
<cline>public static int getScore(ArrayList&lt;String&gt;</cline>
<cline>                            wordList)</cline>
<cline>{</cline>
</block><block order="6">
<cline>  int score = 0;</cline>
<cline>  for (String word : wordList)</cline>
<cline>  {</cline>
</block><block order="4">
<cline>    if (word.length() == 3)</cline>
</block><block order="7">
<cline>    {</cline>
<cline>      score++;</cline>
<cline>    }</cline>
</block><block order="3">
<cline>    else if (word.length() == 4)</cline>
<cline>    {</cline>
<cline>      score = score + 2;</cline>
<cline>    }</cline>
</block><block order="1">
<cline>    else if (word.length() &gt; 4)</cline>
<cline>    {</cline>
<cline>      score = score + 3;</cline>
<cline>    }</cline>
</block><block order="8">
<cline>  } // end for</cline>
</block><block order="5">
<cline>  return score;</cline>
<cline>} // end method</cline>
</block><block order="2" correct="no">
<cline>if (word.length == 3) </cline>
</block></blocks></activity>        </subsection>
  <subsection xml:id="for-loops-and-indexoutofbounds-exception">
            <title>For Loops and IndexOutOfBounds Exception</title>
            <p>You can also use a regular indexed <c>for</c> loop to process list
                elements accessed using an index. <c>ArrayList</c> indices starts at 0 just like
                array indices, but instead of using the index operator <c>[]</c> to access
                elements, you use the <c>get(index)</c> method to get the value at the index and
                <c>set(index,value)</c> to set the element at an index to a new value.</p>
            <p>If you try to use an index that is outside of the range of 0 to the number of
                elements − 1 in an ArrayList, your code will throw an
                <c>IndexOutOfBoundsException</c>, similar to the <c>ArrayIndexOutOfBoundsException</c>
                thrown if you use the index operator on an array with an index out of bounds for
                that array.</p>

<activity label="listForLoop">
    <statement>
            <p>The following code will throw an <c>IndexOutOfBoundsException</c>. Can you fix
                it?</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*;

public class TestForLoop
{
    public static void main(String[] args)
    {
        ArrayList&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;();
        myList.add(50);
        myList.add(30);
        myList.add(20);
        int total = 0;
        for (int i = 0; i &lt;= myList.size(); i++)
        {
            total = total + myList.get(i);
        }
        System.out.println(total);
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "100";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }

    @Test
    public void fixedCode()
    {
        boolean passed = checkCodeContains("fixed test in loop", "i &lt; myList.size()");
        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>
        </subsection>
  <subsection xml:id="while-loop">
            <title>While Loop</title>
            <p>The example below demonstrates a <c>while</c> loop and an object-oriented approach
                where the list is a field of the current object and an instance method
                rather than a class (static) method loops through the list.</p>

<activity label="listForEachLoopObj">
    <statement>
            <p>The following code removes a name from a list. Set the found variable to the appropriate true or false values at line 13 and line 20 to make the code work.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*;
public class ListWorker
{
   private ArrayList&lt;String&gt; nameList;

   public ListWorker(ArrayList&lt;String&gt; nameList)
   {
       this.nameList = nameList;
   }

   public boolean removeName(String name)
   {
       boolean found =   // true or false?
       int index = 0;
       while (index &lt; nameList.size())
       {
           if (name.equals(nameList.get(index)))
           {
               nameList.remove(index);
               found =    // true or false?
           }
           else
           {
               index++;
           }
       }
       return found;
    }

    public static void main(String[] args)
    {
        ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();
        myList.add("Amun");
        myList.add("Ethan");
        myList.add("Donnie");
        myList.add("Ethan");
        ListWorker listWorker = new ListWorker(myList);
        System.out.println(listWorker.nameList);
        listWorker.removeName("Ethan");
        System.out.println("After removing Ethan: "
                  + listWorker.nameList);
    }
}
</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "[Amun, Ethan, Donnie, Ethan]\nAfter removing Ethan: [Amun, Donnie]";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>
            <p>Be careful when you remove items from a list as you loop through it. Notice how
                the method above only increments the index if an item was not removed from the
                list. This is because removing an item from a list will shift the remaining
                items to the left and if you increment the index in all cases you will skip the
                elements immediately after each element you remove. To see why, consider that
                those elements will be shifted into the position of the just removed element and
                if you increment the index, it will move to the next position, skipping the
                element that used to be at that position. Leaving the index unchanged after a
                remove allows the shifted-down element to be processed on the next time through
                the loop.</p>

    <activity label="qloopList_1">
        <statement>

            <p> Assume that <c>nums</c> has been created as an <c>ArrayList</c> object and it initially contains the following <c>Integer</c> values [0, 0, 4, 2, 5, 0, 3, 0]. What will <c>nums</c> contain as a result of executing <c>numQuest</c>?</p>
            <program language="java"><code>
ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
private ArrayList&lt;Integer&gt; nums;

// precondition: nums.size() &gt; 0;
// nums contains Integer objects
public void numQuest()
{
   int k = 0;
   Integer zero = new Integer(0);
   while (k &lt; nums.size())
   {
      if (nums.get(k).equals(zero))
         nums.remove(k);
      k++;
   }
}
</code></program>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>[0, 4, 2, 5, 3]</p>
                </statement>
                <feedback>
                    <p>Incrementing the index each time through the loop will miss when there are two zeros in a row.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[3, 5, 2, 4, 0, 0, 0, 0]</p>
                </statement>
                <feedback>
                    <p>This would be true if the code moved the zeros to the end, but that is not what it does.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[0, 0, 0, 0, 4, 2, 5, 3]</p>
                </statement>
                <feedback>
                    <p>This would be true if the code moved the zeros to the font, but that is not what it does.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 2, 5, 3]</p>
                </statement>
                <feedback>
                    <p>This would be correct if k was only incremented when an item was not removed from the list.</p>
                </feedback>
            </choice>
</choices>

    </activity>
            <p>You can step through the code above by clicking on the following <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0A%0Apublic+class+ListWorker+%7B%0A%0A+++private+List%3CInteger%3E+nums%3B%0A+++%0A+++public+ListWorker(List%3CInteger%3E+theNums)%0A+++%7B%0A++++++nums+%3D+theNums%3B%0A+++%7D%0A%0A+++//+precondition%3A+nums.size()+%3E+0%3B%0A+++//+nums+contains+Integer+objects%0A+++public+void+numQuest()%0A+++%7B%0A++++++int+k+%3D+0%3B%0A++++++Integer+zero+%3D+new+Integer(0)%3B%0A++++++while+(k+%3C+nums.size())%0A++++++%7B%0A+++++++++if+(nums.get(k).equals(zero))%0A++++++++++++nums.remove(k)%3B%0A+++++++++k%2B%2B%3B%0A++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++List%3CInteger%3E+numList+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(4)%3B%0A++++++numList.add(2)%3B%0A++++++numList.add(5)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(3)%3B%0A++++++numList.add(0)%3B%0A++++++System.out.println(numList)%3B%0A++++++ListWorker+listW+%3D+new+ListWorker(numList)%3B%0A++++++listW.numQuest()%3B%0A++++++System.out.println(numList)%3B%0A+++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=11" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0A%0Apublic+class+ListWorker+%7B%0A%0A+++private+List%3CInteger%3E+nums%3B%0A+++%0A+++public+ListWorker(List%3CInteger%3E+theNums)%0A+++%7B%0A++++++nums+%3D+theNums%3B%0A+++%7D%0A%0A+++//+precondition%3A+nums.size()+%3E+0%3B%0A+++//+nums+contains+Integer+objects%0A+++public+void+numQuest()%0A+++%7B%0A++++++int+k+%3D+0%3B%0A++++++Integer+zero+%3D+new+Integer(0)%3B%0A++++++while+(k+%3C+nums.size())%0A++++++%7B%0A+++++++++if+(nums.get(k).equals(zero))%0A++++++++++++nums.remove(k)%3B%0A+++++++++k%2B%2B%3B%0A++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++List%3CInteger%3E+numList+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(4)%3B%0A++++++numList.add(2)%3B%0A++++++numList.add(5)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(3)%3B%0A++++++numList.add(0)%3B%0A++++++System.out.println(numList)%3B%0A++++++ListWorker+listW+%3D+new+ListWorker(numList)%3B%0A++++++listW.numQuest()%3B%0A++++++System.out.println(numList)%3B%0A+++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=11">Example</url>.</p>
<activity label="listInsertParsons" numbered="yes" adaptive="yes" indentation="show" language="java"><statement>
            <p>The following has the correct code for a method called insertInOrder plus at least one extra unneeded code statement. This method should add the passed name in alphabetic order to a private list field called nameList.  Drag the needed blocks from the left into the correct order on the right. Check your solution by clicking on the Check button.  You will be told if any of the blocks are in the wrong order or if you need to remove one or more blocks.  There is one extra block that is not needed in a correct solution.</p>
</statement>
<blocks><block order="8">
<cline>public void insertInOrder(String name)</cline>
<cline>{</cline>
</block><block order="7">
<cline>  int index = 0;</cline>
</block><block order="6">
<cline>  while (index &lt; nameList.size() &amp;&amp;</cline>
<cline>     nameList.get(index).compareTo(name)</cline>
<cline>                             &lt; 0)</cline>
<cline>  {</cline>
</block><block order="4">
<cline>    index++;</cline>
</block><block order="3">
<cline>  } // end while</cline>
</block><block order="5">
<cline>  nameList.add(index,name);</cline>
</block><block order="1">
<cline>} // end method</cline>
</block><block order="2" correct="no">
<cline>nameList.add(name); </cline>
</block></blocks></activity>        </subsection>
  <subsection xml:id="reading-in-files-with-java-nio-file">
            <title>Reading in Files with <c>java.nio.file</c></title>
            <p>Although not covered in the AP CSA exam, the <c>java.nio.file</c> package (nio stands for new input/output), added in Java version 7, provides a better and easier way to read in files. The <c>Files</c> class in this package has a method called <c>readAllLines</c> that reads all of the lines in a file and returns them as a <c>List</c> of <c>String</c> objects. The <c>readAllLines</c> method throws an <c>IOException</c> if the file cannot be read. (<c>List</c> is an <term>interface</term>. Interfaces are not on the AP CSA exam but are quite common in actual Java programming. For now all you need to know is that all the methods we’ve talked about using with <c>ArrayList</c> you can use on any <c>List</c> such as the one returned by <c>readAllLines</c>.)</p>
            <program language="java"><code>
import java.nio.file.*;
...

// This connects and reads in the file in 1 line of code!
// It needs to be in a method that throws or handles IOException
List&lt;String&gt; lines = Files.readAllLines(Paths.get("data.txt"));
</code></program>
            <p>Under the covers <c>readAllLines</c> is almost certainly using an <c>ArrayList</c> which is a kind of <c>List</c>. The advantage of storing the lines in a dynamic data structure like an <c>ArrayList</c>, instead of an array, is that you do not need to know how many lines you are going to store when you create the <c>ArrayList</c> the way you do when you create an array.  The <c>ArrayList</c> can then grow in size as needed. (If you absolutely need an array, you can convert the <c>List</c> to an array declared to be the correct size with  <c>myArray = lines.toArray(myArray);</c>)</p>

<activity label="read-pokemon-file-nio">
    <statement>
            <p>Complete the code in the main method below to reads all lines of the file using <c>Files.readAllLines</c> into a <c>List&lt;String&gt;</c> named <c>lines</c>. Add a loop that prints out the first 10 pokemon.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.io.*;
import java.nio.file.*;
import java.util.*;

public class ReadData
{
    public static void main(String[] args) throws IOException
    {
        List&lt;String&gt; lines = Files.readAllLines(Paths.get("pokemon.csv"));
        // Add a loop that prints out the first 10 elements of the List lines
        // You can use the get method with Lists just like ArrayLists

    }
}

</code><tests>
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("ReadData");
    }

    @Test
    public void testMain() throws IOException
    {
         String output = getMethodOutput("main");
         String[] lines = output.split("\\s+");
         boolean passed = lines.length &gt;= 10;

         passed = getResults("10+ lines of output", lines.length + " lines of output", "Expected output", passed);
         assertTrue(passed);
    }
    @Test
    public void getMethodTest()
    {
       boolean passed = checkCodeContains("call to get method with lines", "lines.get");
       assertTrue(passed);
    }
 }
        </tests>
    </program>
</activity>
        </subsection>
  <subsection xml:id="arraylist-of-student-objects">
            <title>ArrayList of Student Objects</title>
            <p>You can put any kind of objects into an <c>ArrayList</c>. For example, here is an
                <c>ArrayList</c> of <c>Student</c>s. Although the print statement works here, you
                may want a nicer printout.</p>

<activity label="StudentList">
    <statement>
            <p>Add a for each loop that prints out each student and then a new line.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*;

public class StudentList
{
    // main method for testing
    public static void main(String[] args)
    {
        ArrayList&lt;Student&gt; roster = new ArrayList&lt;Student&gt;();
        roster.add(new Student("Skyler", "skyler@sky.com", 123456));
        roster.add(new Student("Ayanna", "ayanna@gmail.com", 789012));
        // Replace this with a for each loop that prints out each student on a
        // separate line
        System.out.println(roster);
    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String name, String email, int id)
    {
        this.name = name;
        this.email = email;
        this.id = id;
    }

    // toString() method
    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "123456: Skyler, skyler@sky.com\n789012: Ayanna, ayanna@gmail.com";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }

    @Test
    public void loopCode()
    {
        boolean passed = checkCodeContains("for loop", "for");
        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>
        </subsection>
  <subsection xml:id="coding-challenge-frq-word-pairs">
            <title>Coding Challenge : FRQ Word Pairs</title>
            <p>This challenge is based on the <url href="https://secure-media.collegeboard.org/ap/pdf/ap18-frq-computer-science-a.pdf#page=7" visual="https://secure-media.collegeboard.org/ap/pdf/ap18-frq-computer-science-a.pdf#page=7">2018 Free Response Question #2 WordPair</url>. We
                encourage you to work in pairs on this challenge.</p>
            <p>You are given a class called <c>WordPair</c> that can store pairs of words.</p>
            <program language="java"><code>
class WordPair
{
    private String word1;
    private String word2;

    public WordPair(String word1, String word2)
    {
        this.word1 = word1;
        this.word2 = word2;
    }

    public String getFirst()
    {
        return word1;
    }

    public String getSecond()
    {
        return word2;
    }

    public String toString()
    {
        return "(" + word1 + ", " + word2 + ")";
    }
}
</code></program>
            <p>First, see if you can create an <c>ArrayList</c> of <c>WordPair</c> objects below.
                Look at the <c>StudentList</c> example above for help.</p>

<activity label="ArrayListWordPair1">
    <statement>
            <p>Create an Arraylist of WordPair objects.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*;

public class WordPairTest
{
    public static void main(String[] args)
    {
        // Create an ArrayList of WordPair objects called pairs

        pairs.add(new WordPair("hi", "there"));
        pairs.add(new WordPair("hi", "bye"));
        System.out.println(pairs);
    }
}

class WordPair
{
    private String word1;
    private String word2;

    public WordPair(String word1, String word2)
    {
        this.word1 = word1;
        this.word2 = word2;
    }

    public String getFirst()
    {
        return word1;
    }

    public String getSecond()
    {
        return word2;
    }

    public String toString()
    {
        return "(" + word1 + ", " + word2 + ")";
    }
}

 </code><tests>
 import static org.junit.Assert.*;

 import org.junit.*;

 import java.io.*;

 public class RunestoneTests extends CodeTestHelper
 {
     public RunestoneTests()
     {
         super("WordPairTest");
     }

     @Test
     public void testMain() throws IOException
     {
         String output = getMethodOutput("main");
         String expect = "[(hi, there), (hi, bye)]";
         boolean passed = getResults(expect, output, "Expected output from main");
         assertTrue(passed);
     }

     @Test
     public void hasArrayList()
     {
         boolean passed = checkCodeContains("ArrayList declaration", "ArrayList&lt;WordPair&gt;");
         assertTrue(passed);
     }
 }
        </tests>
    </program>
</activity>
            <figure align="left"><image source="Unit4-Data-Collections/Figures/wordpairs.png" width="34%"/></figure>
            <p>In this FRQ, you are given an array of words and you will create pairs of them
                by taking the first word and pairing it with all the other words, then taking
                the second word and pairing it with all but the first one, and so on. For
                example, if the word array is [“Hi”, “there”, “Tyler”, “Sam”], this figure shows
                how the word pairs are formed.</p>
            <p>In the class <c>WordPairsList</c> below, you will write the constructor which takes
                the array of words and pairs them up as shown in the figure. You will need
                nested loops to pair each element with the rest of the elements in the list.</p>
            <p>Here is the pseudocode for the constructor method.</p>
            <p><ul>
                <li>
                    <p>Initialize the <c>allPairs</c> list to an empty <c>ArrayList</c> of <c>WordPair</c> objects.</p>
                </li>
                <li>
                    <p>Loop through the <c>words</c> array for the first word in the word pair (for loop from index <c>i = 0</c> to <c>length-1</c>)</p>
                    <p><ul>
                        <li>
                            <p>Loop through the rest of the word array starting from index <c>i + 1</c> for the second word in the word pair (for loop from index <c>j = i + 1</c> to <c>length</c>)</p>
                            <p><ul>
                                <li>
                                    <p>Add the new <c>WordPair</c> formed from the <c>i</c>th word and the <c>j</c>th word to the <c>allPairs</c> <c>ArrayList</c>.</p>
                                </li>
                            </ul></p>
                        </li>
                    </ul></p>
                </li>
            </ul></p>

<activity label="challenge-WordPairs">
    <statement>
            <p>FRQ WordPairs Challenge: Complete the constructor for <c>WordPairsList</c> below
                which will add pairs of words from a given array to the <c>ArrayList</c>. Then,
                complete the method <c>numMatches()</c> as described below this exercise.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
import java.util.*;

public class WordPairsList
{
    private ArrayList&lt;WordPair&gt; allPairs;

    public WordPairsList(String[] words)
    {
        // WRITE YOUR CODE HERE
        // initialize allPairs to an empty ArrayList of WordPair objects

        // nested loops through the words array to add each pair to allPairs

    }

    public int numMatches()
    {
        // Write the code for the second part described below
        return 0;
    }

    public String toString()
    {
        return allPairs.toString();
    }

    public static void main(String[] args)
    {
        String[] words = {"Hi", "there", "Tyler", "Sam"};
        WordPairsList list = new WordPairsList(words);
        System.out.println(list);
        // For second part below, uncomment this test:
        // System.out.println("The number of matched pairs is: " +
        // list.numMatches());
    }
}

class WordPair
{
    private String word1;
    private String word2;

    public WordPair(String word1, String word2)
    {
        this.word1 = word1;
        this.word2 = word2;
    }

    public String getFirst()
    {
        return word1;
    }

    public String getSecond()
    {
        return word2;
    }

    public String toString()
    {
        return "(" + word1 + ", " + word2 + ")";
    }
}

 </code><tests>
 import static org.junit.Assert.*;

 import org.junit.*;

 import java.io.*;

 public class RunestoneTests extends CodeTestHelper
 {
     public RunestoneTests()
     {
         super("WordPairsList");
     }

     @Test
     public void test1()
     {
         String output = getMethodOutput("main");
         String expect =
                 "[(Hi, there), (Hi, Tyler), (Hi, Sam), (there, Tyler), (there, Sam), (Tyler, Sam)]";

         boolean passed = output.contains(expect);

         String[] lines = output.split("\n");
         if (lines.length &gt; 1) output = lines[0];

         getResults(expect, output, "Part 1 - Add all word pairs from main()", passed);
         assertTrue(passed);
     }

     /* //remove test because instructions say to add a matched pair.
     @Test
     public void test2()
     {
         String output = getMethodOutput("main");
         String expect = "The number of matched pairs is: 0";

         boolean passed = output.contains(expect);
         String[] lines = output.split("\n");
         if (lines.length &gt; 1) output = lines[1];

         getResults(expect, output, "Part 2 - call to numMatches from main()", passed);
         assertTrue(passed);
     }
     */

     @Test
     public void test3()
     {
         String[] words = {"Hi", "Hi", "Test", "Test"};
         WordPairsList list = new WordPairsList(words);
         String output = list.toString();
         String expect = "[(Hi, Hi), (Hi, Test), (Hi, Test), (Hi, Test), (Hi, Test), (Test, Test)]";

         boolean passed =
                 getResults(
                         expect,
                         output,
                         "Part 1 - Add all word pairs with {\"Hi\", \"Hi\", \"Test\", \"Test\"}");
         assertTrue(passed);
     }

     @Test
     public void test4()
     {
         String[] words = {"Hi", "Hi", "Test", "Test"};
         WordPairsList list = new WordPairsList(words);
         String output = "The number of matched pairs is: " + list.numMatches();
         String expect = "The number of matched pairs is: 2";

         boolean passed =
                 getResults(
                         expect,
                         output,
                         "Part 2 - numMatches() with {\"Hi\", \"Hi\", \"Test\", \"Test\"}");
         assertTrue(passed);
     }
 }
        </tests>
    </program>
</activity>
            <p>In the next part of the FRQ challenge, you are asked to write a method called
                <c>numMatches</c> that counts and returns the number of pairs where the first word
                is the same as the second word. For example, if the word array is
                <c>["hi","bye","hi"]</c>, the pairs generated would be <c>["hi","bye"]</c>,
                <c>["hi","hi"]</c>, and <c>["bye","hi"]</c>. In the second pair <c>["hi","hi"]</c>, the
                first word is the same as the second word, so <c>numMatches</c> would return 1.</p>
            <p>For this method, you will need a loop that goes through the <c>ArrayList</c>
                <c>allPairs</c> and for each <c>WordPair</c> in <c>allPairs</c>, it checks to see if its
                first word (using the <c>getFirst</c> method) equals the second word (using the
                <c>getSecond</c> method). If there is a match, it increments a counter which it
                returns at the end of the method. To test this method, add another “there” into
                the words array and then uncomment the call to <c>numMatches</c>.</p>
        </subsection>
  <subsection xml:id="summary-50">
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>(AP 4.9.A.1) Traversing an <c>ArrayList</c> is when iteration or recursive statements are used to access all or an ordered sequence of the elements in an <c>ArrayList</c>.</p>
                </li>
                <li>
                    <p><c>ArrayList</c>s can be traversed with an enhanced <c>for</c> loop, a <c>while</c>
                        loop, or a regular <c>for</c> loop using an index.</p>
                </li>
                <li>
                    <p>(AP 4.9.A.2) Deleting elements during a traversal of an <c>ArrayList</c> requires the use of special techniques to avoid skipping elements (since <c>remove</c> moves all the
                        elements above the removed index down.)</p>
                </li>
                <li>
                    <p>(AP 4.9.A.3) Attempting to access an index value outside of its range will result in an <c>IndexOutOfBoundsException</c>. (The indices for an <c>ArrayList</c> start at 0 and end at the number of elements − 1).</p>
                </li>
                <li>
                    <p>(AP 4.9.A.4) Changing the size of an <c>ArrayList</c> while traversing it using an enhanced <c>for</c> loop can result in a <c>ConcurrentModificationException</c>. Therefore, when using an enhanced <c>for</c> loop to traverse an <c>ArrayList</c>, you should not add or remove elements.</p>
                </li>
            </ul></p>
        </subsection>
</section>
