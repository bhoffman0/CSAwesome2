<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="recursive-searching-and-sorting">
  <title>Recursive Searching and Sorting</title><introduction>
    
    <p>In Unit 7, we learned about searching and sorting algorithms using iteration (loops) to search or sort arrays and ArrayLists. In this lesson, we will take a look at a <term>recursive binary search</term> algorithm and a <term>recursive merge-sort</term> algorithm.</p>
  </introduction>
  <subsection>
            <title>Recursive Binary Search</title>
            <p>In Unit 7, we learned about two search algorithms, linear search and binary search. Linear search searches for an element in an array or ArrayList by checking each element in order. Binary search is more efficient (faster) because it starts at the middle of a sorted array or ArrayList and eliminates half of the array or ArrayList each pass through the algorithm. Binary search only works on sorted data. It can be written with iteration (using a loop) like below or recursively.</p>

    <program interactive="activecode" language="java">
        <input>
public class IterativeBinarySearch
{
    public static int binarySearch(int[] elements, int target)
    {
        int left = 0;
        int right = elements.length - 1;
        while (left &lt;= right)
        {
            int middle = (left + right) / 2;
            if (target &lt; elements[middle])
            {
                right = middle - 1;
            }
            else if (target &gt; elements[middle])
            {
                left = middle + 1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        int[] arr1 = {-20, 3, 15, 81, 432};

        int index = binarySearch(arr1, 81);
        System.out.println(index);
    }
}
        </input>
    </program>
            <p>Watch the iterative binary search code running in the <problematic refid="id3">|Java Visualizer|</problematic>.</p>
            <p>Let’s write a recursive version of Binary Search. Note that you can write solutions to many problems using recursion or iteration. Iteration is usually preferred and more efficient, but recursive solutions can be elegant and require less code.</p>
            <p><problematic refid="id5">|Exercise|</problematic> <term>Check Your Understanding</term></p>

<exercise label="baseCaseQ">
    <statement>
            <p>10-2-2: What’s the base case for a recursive version of Binary Search (where we want the recursion to stop)? Remember that in binary search, we always check the middle element first when looking for a target element from a startIndex to an endIndex.</p>

    </statement>
</exercise>

<exercise label="recursiveCallQ">
    <statement>
            <p>10-2-3: Given a recursive binary search method with the method signature “boolean binarySearch(int[] array, int startIndex, int endIndex, int target)”, what recursive method call would search the array from index 0 to the middle index?</p>

    </statement>
</exercise>
            <p>Here is the Java code for a recursive binary search:</p>
            <p><problematic refid="id7">|CodingEx|</problematic> <term>Coding Exercise</term></p>

<exercise label="recursiveBinarySearch">
    <statement>
            <p>Run the code below. Try searching for the value 3 and then the value 2 which is not in the array. What would happen if we removed the second base case checking if end &lt; start? Try it and see.</p>

    </statement>
    <program interactive="activecode" language="java">
        <input>
public class RecursiveBinarySearch
{
    public static int recursiveBinarySearch(
        int[] array, int start, int end, int target)
    {
        int middle = (start + end) / 2;
        // base case: check middle element
        if (target == array[middle])
        {
            return middle;
        }
        // base case: check if we've run out of elements
        if (end &lt; start)
        {
            return -1; // not found
        }
        // recursive call: search start to middle
        if (target &lt; array[middle])
        {
            return recursiveBinarySearch(array, start, middle - 1, target);
        }
        // recursive call: search middle to end
        if (target &gt; array[middle])
        {
            return recursiveBinarySearch(array, middle + 1, end, target);
        }
        return -1;
    }

    public static void main(String[] args)
    {
        int[] array = {3, 7, 12, 19, 22, 25, 29, 30};
        int target = 25;
        int foundIndex = recursiveBinarySearch(array, 0, array.length - 1, target);
        System.out.println(target + " was found at index " + foundIndex);
    }
}
        </input>
    </program>
</exercise>
            <p>Try the recursive binary search code in this <url href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#code=++public+class+RecursiveBinarySearch%0A++%7B%0A+++++public+static+int+recursiveBinarySearch(int%5B%5D+array,+int+target,+int+start,+int+end)%0A+++++%7B%0A+++++++int+middle+%3D+(start+%2B+end)/2%3B%0A%09+++%0A+++++++if+(target+%3D%3D+array%5Bmiddle%5D)+%7B%0A%09%09%09return+middle%3B%0A%09+++%7D%09%0A%09+++if(end+%3C+start)%7B%0A%09%09%09+return+-1%3B+//+not+found%0A%09++++%7D+%0A%09%09%0A%09++++if+(target+%3C+array%5Bmiddle%5D)%7B%0A%09%09%09return+recursiveBinarySearch(array,+target,+start,+middle+-+1)%3B%0A%09%09%7D%0A%09%09%0A%09%09if+(target+%3E+array%5Bmiddle%5D)%7B%0A%09%09%09return+recursiveBinarySearch(array,+target,+middle+%2B+1,+end)%3B%0A%09%09%7D%0A%0A%09%09return+-1%3B%0A+++%7D%0A%0A+++public+static+void+main(String%5B%5D+args)%0A+++%7B%0A++++++int%5B%5D+array+%3D+%7B+3,+7,+12,+19,+22,+25,+29,+30+%7D%3B%0A++++++int+foundIndex+%3D+recursiveBinarySearch(array,25,0,array.length)%3B%0A++++++System.out.println(%2225+was+found+at+index+%22+%2B+foundIndex)%3B%0A+++%7D%0A++%7D&amp;mode=display&amp;curInstr=28" visual="https://cscircles.cemc.uwaterloo.ca/java_visualize/#code=++public+class+RecursiveBinarySearch%0A++%7B%0A+++++public+static+int+recursiveBinarySearch(int%5B%5D+array,+int+target,+int+start,+int+end)%0A+++++%7B%0A+++++++int+middle+%3D+(start+%2B+end)/2%3B%0A%09+++%0A+++++++if+(target+%3D%3D+array%5Bmiddle%5D)+%7B%0A%09%09%09return+middle%3B%0A%09+++%7D%09%0A%09+++if(end+%3C+start)%7B%0A%09%09%09+return+-1%3B+//+not+found%0A%09++++%7D+%0A%09%09%0A%09++++if+(target+%3C+array%5Bmiddle%5D)%7B%0A%09%09%09return+recursiveBinarySearch(array,+target,+start,+middle+-+1)%3B%0A%09%09%7D%0A%09%09%0A%09%09if+(target+%3E+array%5Bmiddle%5D)%7B%0A%09%09%09return+recursiveBinarySearch(array,+target,+middle+%2B+1,+end)%3B%0A%09%09%7D%0A%0A%09%09return+-1%3B%0A+++%7D%0A%0A+++public+static+void+main(String%5B%5D+args)%0A+++%7B%0A++++++int%5B%5D+array+%3D+%7B+3,+7,+12,+19,+22,+25,+29,+30+%7D%3B%0A++++++int+foundIndex+%3D+recursiveBinarySearch(array,25,0,array.length)%3B%0A++++++System.out.println(%2225+was+found+at+index+%22+%2B+foundIndex)%3B%0A+++%7D%0A++%7D&amp;mode=display&amp;curInstr=28">Java visualizer link</url>.</p>
        </subsection>
  <subsection>
            <title>Merge Sort</title>
            
            
            <p>In Unit 7, we looked at two sorting algorithms, Selection Sort and Insertion Sort. In this lesson, we will look at a third sorting algorithm, Merge Sort, which uses recursion. Merge Sort is actually more efficient (faster) than Selection Sort and Insertion Sort because it divides the problem in half each time like binary search. This is called a <term>divide and conquer</term> algorithm.</p>
            <p>A merge sort recursively breaks the values to be sorted in half until there is only one value to be sorted and then it merges the two sorted lists into one sorted list.  The code shown below uses a second array the same size as the original array for merging the values in order.  Then it copies all of the sorted values back into the original array.</p>
            <p>Here is a folk dance <url href="https://youtu.be/XaqR3G_NVoo" visual="https://youtu.be/XaqR3G_NVoo">video</url> that shows the merge sort process.</p>

    <video youtube="XaqR3G_NVoo"/>
                <p>And here is a short <url href="https://youtu.be/4VqmGXwpLqc" visual="https://youtu.be/4VqmGXwpLqc">video</url> that describes how merge sort works.</p>

    <video youtube="4VqmGXwpLqc"/>
                <p>The code for <c>mergeSort</c> below is from the AP CSA course description.</p>
            <p>To identify a merge sort look for the following:</p>
            <p><ul>
                <li>
                    <p>3 methods, mergeSort, mergeSortHelper, and merge</p>
                </li>
                <li>
                    <p>mergeSortHelper is recursive</p>
                </li>
            </ul></p>

    <program interactive="activecode" language="java">
        <input>
import java.util.Arrays;

public class SortTest
{
    public static void mergeSort(int[] elements)
    {
        int n = elements.length;
        int[] temp = new int[n];
        mergeSortHelper(elements, 0, n - 1, temp);
    }

    private static void mergeSortHelper(
        int[] elements, int from, int to, int[] temp)
    {
        if (from &lt; to)
        {
            int middle = (from + to) / 2;
            mergeSortHelper(elements, from, middle, temp);
            mergeSortHelper(elements, middle + 1, to, temp);
            merge(elements, from, middle, to, temp);
        }
    }

    private static void merge(
        int[] elements, int from, int mid, int to, int[] temp)
    {
        int i = from;
        int j = mid + 1;
        int k = from;

        while (i &lt;= mid &amp;&amp; j &lt;= to)
        {
            if (elements[i] &lt; elements[j])
            {
                temp[k] = elements[i];
                i++;
            }
            else
            {
                temp[k] = elements[j];
                j++;
            }
            k++;
        }

        while (i &lt;= mid)
        {
            temp[k] = elements[i];
            i++;
            k++;
        }

        while (j &lt;= to)
        {
            temp[k] = elements[j];
            j++;
            k++;
        }

        for (k = from; k &lt;= to; k++)
        {
            elements[k] = temp[k];
        }
    }

    public static void main(String[] args)
    {
        int[] arr1 = {86, 3, 43, 5};
        System.out.println(Arrays.toString(arr1));
        mergeSort(arr1);
        System.out.println(Arrays.toString(arr1));
    }
}
        </input>
    </program>
            <p>You can see this executing using the <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=++import+java.util.Arrays%3B%0A++%0A++public+class+SortTest%0A++%7B%0A+++++public+static+void+mergeSort(int%5B%5D+elements)+%0A+++++%7B%0A++++++++int+n+%3D+elements.length%3B%0A++++++++int%5B%5D+temp+%3D+new+int%5Bn%5D%3B+%0A++++++++mergeSortHelper(elements,+0,+n+-+1,+temp)%3B%0A+++++%7D%0A+++++%0A+++++private+static+void+mergeSortHelper(int%5B%5D+elements,+int+from,+int+to,+int%5B%5D+temp)%0A+++++%7B%0A+++++++++if+(from+%3C+to)%0A+++++++++%7B%0A++++++++++++int+middle+%3D+(from+%2B+to)+/+2%3B+%0A++++++++++++mergeSortHelper(elements,+from,+middle,+temp)%3B+%0A++++++++++++mergeSortHelper(elements,+middle+%2B+1,+to,+temp)%3B+%0A++++++++++++merge(elements,+from,+middle,+to,+temp)%3B%0A+++++++++%7D%0A+++++%7D%0A+++++%0A+++++private+static+void+merge(int%5B%5D+elements,+int+from,+int+mid,+int+to,+int%5B%5D+temp)%0A+++++%7B%0A++++++++int+i+%3D+from%3B+%0A++++++++int+j+%3D+mid+%2B+1%3B+%0A++++++++int+k+%3D+from%3B%0A++++++++%0A++++++++while+(i+%3C%3D+mid+%26%26+j+%3C%3D+to)+%0A++++++++%7B%0A+++++++++++if+(elements%5Bi%5D+%3C+elements%5Bj%5D)+%0A+++++++++++%7B%0A++++++++++++++temp%5Bk%5D+%3D+elements%5Bi%5D%3B%0A++++++++++++++i%2B%2B%3B+%0A+++++++++++%7D%0A+++++++++++else+%0A+++++++++++%7B%0A++++++++++++++temp%5Bk%5D+%3D+elements%5Bj%5D%3B%0A++++++++++++++j%2B%2B%3B+%0A+++++++++++%7D%0A+++++++++++k%2B%2B%3B+%0A++++++++%7D%0A%0A++++++++while+(i+%3C%3D+mid)+%0A++++++++%7B%0A+++++++++++temp%5Bk%5D+%3D+elements%5Bi%5D%3B+%0A+++++++++++i%2B%2B%3B%0A+++++++++++k%2B%2B%3B%0A++++++++%7D%0A++++++++%0A++++++++while+(j+%3C%3D+to)+%0A++++++++%7B%0A+++++++++++temp%5Bk%5D+%3D+elements%5Bj%5D%3B+%0A+++++++++++j%2B%2B%3B%0A+++++++++++k%2B%2B%3B%0A++++++++%7D%0A++++++++%0A++++++++for+(k+%3D+from%3B+k+%3C%3D+to%3B+k%2B%2B)+%0A++++++++%7B%0A+++++++++++elements%5Bk%5D+%3D+temp%5Bk%5D%3B+%0A++++++++%7D%0A+++++%7D%0A++++++++%0A++++++%0A+++++public+static+void+main(String%5B%5D+args)%0A+++++%7B%0A++++++++int%5B%5D+arr1+%3D+%7B86,+3,+43%7D%3B%0A++++++++System.out.println(Arrays.toString(arr1))%3B%0A++++++++mergeSort(arr1)%3B%0A++++++++System.out.println(Arrays.toString(arr1))%3B%0A+++++%7D%0A++%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=++import+java.util.Arrays%3B%0A++%0A++public+class+SortTest%0A++%7B%0A+++++public+static+void+mergeSort(int%5B%5D+elements)+%0A+++++%7B%0A++++++++int+n+%3D+elements.length%3B%0A++++++++int%5B%5D+temp+%3D+new+int%5Bn%5D%3B+%0A++++++++mergeSortHelper(elements,+0,+n+-+1,+temp)%3B%0A+++++%7D%0A+++++%0A+++++private+static+void+mergeSortHelper(int%5B%5D+elements,+int+from,+int+to,+int%5B%5D+temp)%0A+++++%7B%0A+++++++++if+(from+%3C+to)%0A+++++++++%7B%0A++++++++++++int+middle+%3D+(from+%2B+to)+/+2%3B+%0A++++++++++++mergeSortHelper(elements,+from,+middle,+temp)%3B+%0A++++++++++++mergeSortHelper(elements,+middle+%2B+1,+to,+temp)%3B+%0A++++++++++++merge(elements,+from,+middle,+to,+temp)%3B%0A+++++++++%7D%0A+++++%7D%0A+++++%0A+++++private+static+void+merge(int%5B%5D+elements,+int+from,+int+mid,+int+to,+int%5B%5D+temp)%0A+++++%7B%0A++++++++int+i+%3D+from%3B+%0A++++++++int+j+%3D+mid+%2B+1%3B+%0A++++++++int+k+%3D+from%3B%0A++++++++%0A++++++++while+(i+%3C%3D+mid+%26%26+j+%3C%3D+to)+%0A++++++++%7B%0A+++++++++++if+(elements%5Bi%5D+%3C+elements%5Bj%5D)+%0A+++++++++++%7B%0A++++++++++++++temp%5Bk%5D+%3D+elements%5Bi%5D%3B%0A++++++++++++++i%2B%2B%3B+%0A+++++++++++%7D%0A+++++++++++else+%0A+++++++++++%7B%0A++++++++++++++temp%5Bk%5D+%3D+elements%5Bj%5D%3B%0A++++++++++++++j%2B%2B%3B+%0A+++++++++++%7D%0A+++++++++++k%2B%2B%3B+%0A++++++++%7D%0A%0A++++++++while+(i+%3C%3D+mid)+%0A++++++++%7B%0A+++++++++++temp%5Bk%5D+%3D+elements%5Bi%5D%3B+%0A+++++++++++i%2B%2B%3B%0A+++++++++++k%2B%2B%3B%0A++++++++%7D%0A++++++++%0A++++++++while+(j+%3C%3D+to)+%0A++++++++%7B%0A+++++++++++temp%5Bk%5D+%3D+elements%5Bj%5D%3B+%0A+++++++++++j%2B%2B%3B%0A+++++++++++k%2B%2B%3B%0A++++++++%7D%0A++++++++%0A++++++++for+(k+%3D+from%3B+k+%3C%3D+to%3B+k%2B%2B)+%0A++++++++%7B%0A+++++++++++elements%5Bk%5D+%3D+temp%5Bk%5D%3B+%0A++++++++%7D%0A+++++%7D%0A++++++++%0A++++++%0A+++++public+static+void+main(String%5B%5D+args)%0A+++++%7B%0A++++++++int%5B%5D+arr1+%3D+%7B86,+3,+43%7D%3B%0A++++++++System.out.println(Arrays.toString(arr1))%3B%0A++++++++mergeSort(arr1)%3B%0A++++++++System.out.println(Arrays.toString(arr1))%3B%0A+++++%7D%0A++%7D&amp;mode=display&amp;curInstr=0">Java visualizer for merge sort</url>.</p>
            <p>You can trace through a merge sort algorithm given an array by using parentheses or curly braces to show how the array is divided into subarrays and then merged. For example, here is how you could write down the trace of <c>mergeSort(arr1)</c> where arr1 = {86, 3, 43, 5} like in the example above.</p>
            <p><ol marker="1">
                <li>
                    <p>Split 1: { {86, 3} , {43, 5} }</p>
                </li>
                <li>
                    <p>Split 2: { { {86},{3}} , { {43},{5}} }</p>
                </li>
                <li>
                    <p>Merge 1: { {3, 86} , {5,43} }</p>
                </li>
                <li>
                    <p>Merge 2: { 3, 5, 43, 86 }</p>
                </li>
            </ol></p>
            <p><problematic refid="id9">|Exercise|</problematic> <term>Check Your Understanding</term></p>

    <exercise label="qms_1">
        <statement>

            <p>10-2-8: Under what condition will a merge sort execute faster?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>If the data is already sorted in ascending order</p>
                </statement>
                <feedback>
                    <p>This won't really affect the execution time for merge sort.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>If the data is already sorted in descending order</p>
                </statement>
                <feedback>
                    <p>This won't really affect the execution time for merge sort.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>It will always take the same amount of time to execute</p>
                </statement>
                <feedback>
                    <p>It will take about the same time regardless of the data.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="qms_2">
        <statement>

            <p>10-2-9: Which sort should be the fastest most of the time?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>selection sort</p>
                </statement>
                <feedback>
                    <p>Merge sort is always faster than selection sort.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>insertion sort</p>
                </statement>
                <feedback>
                    <p>Merge sort is usually faster than insertion sort.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>merge sort</p>
                </statement>
                <feedback>
                    <p>Merge sort is always faster than selection sort and usually faster than insertion sort.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
        </subsection>
  <subsection>
            <title><problematic refid="id11">|Groupwork|</problematic> Tracing Challenge : Recursive Search and Sort</title>
            <p>Working in pairs, practice the recursive binary search and merge sort algorithms with a deck of cards or pieces of paper with numbers or names on them.  Here’s a <url href="https://youtu.be/AMJjtTo1LLE" visual="https://youtu.be/AMJjtTo1LLE">video</url> that shows merge sort with cards.</p>

    <video youtube="AMJjtTo1LLE"/>
                <p>Work in pairs to do the following tracing problems.</p>

<exercise label="challenge-10-2-mergesort">
    <statement>
            <p>10-2-11: Trace through mergeSort(array) where array = {5, 2, 20, 22, 17, 15, 8, 10} writing down each split and merge.</p>

    </statement>
</exercise>

<exercise label="challenge-10-2-binary-search">
    <statement>
            <p>10-2-12: Trace through recursiveBinarySearch(sortedArray, 0, 8, 22) looking for the target number 22 where sortedArray = {2, 5, 8, 10, 11, 15, 17, 20, 22}. Write down each middle element that is checked and the start and end index for each recursive call. How many elements did the binary search have to check before finding 22?  How would this compare to a linear search?</p>

    </statement>
</exercise>
        </subsection>
  <subsection>
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>The binary search algorithm can be written either iteratively or recursively.</p>
                </li>
                <li>
                    <p>Data must be in sorted order to use the binary search algorithm.</p>
                </li>
                <li>
                    <p>The binary search algorithm starts at the middle of a sorted array or ArrayList and eliminates half of the array or ArrayList in until the desired value is found or all elements have been eliminated.</p>
                </li>
                <li>
                    <p>Binary search can be more efficient than sequential/linear search.</p>
                </li>
                <li>
                    <p>Merge sort is a recursive sorting algorithm that can be used to sort elements in an array or ArrayList.</p>
                </li>
            </ul></p>
        </subsection>
</section>
