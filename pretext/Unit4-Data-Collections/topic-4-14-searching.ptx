<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="topic-4-14-searching">
  <time minutes="90" />
  <title>Searching Algorithms</title>
  <introduction>
    <idx>sequential search</idx>
    <idx>binary search</idx>
    <idx>recursion</idx>
    <idx>
      <h>search</h><h>sequential</h>
    </idx>

    <idx>
      <h>search</h><h>binary</h>
    </idx>

    <p>
      Computers store vast amounts of data. One of the strengths of computers is
      their ability to find things quickly. This ability is called
      <term>searching</term>. For the AP CSA exam you will need to know both
      <term>linear (sequential) search</term> and <term>binary search</term>
      algorithms.
    </p>

    <p>
      The following video is also on YouTube at <url
      href="https://youtu.be/DHLCXXX1OtE"
      visual="https://youtu.be/DHLCXXX1OtE">https://youtu.be/DHLCXXX1OtE</url>.
      It introduces the concept of searching including sequential search and
      binary search.
    </p>

    <video youtube="DHLCXXX1OtE" label="video-search" />
    <p>
      <ul>
        <li>
          <p>
            <term>Linear search</term> is a standard algorithm that checks each
            element in order until the desired value is found or all elements in
            the array or <c>ArrayList</c> have been checked. Linear search
            algorithms can begin the search process from either end of the array
            or <c>ArrayList</c>.
          </p>
        </li>

        <li>
          <p>
            <term>Binary search</term> can only be used on data that has been
            <term>sorted</term> or stored in order. It checks the middle of the
            data to see if that middle value is less than, equal, or greater
            than the desired value and then based on the results of that it
            narrows the search. It cuts the search space in half each time.
          </p>
        </li>
      </ul>
    </p>

    <p>
      If binary search requires the values in an array or list to be sorted, how
      can you do that? There are many sorting algorithms which are covered in
      the next lesson.
    </p>
  </introduction>

  <subsection xml:id="linear-search">
    <title>Linear Search</title>
    <idx>sequential search</idx>
    <idx>linear search</idx>
    <idx>
      <h>search</h><h>sequential</h>
    </idx>

    <idx>
      <h>search</h><h>linear</h>
    </idx>

    <p>
      Linear or Sequential search can be used to find a value in
      <em>unsorted</em> data. It usually starts at the first element and walks
      through the array or <c>ArrayList</c> until it finds the value it is
      looking for and returns its index. If it reaches the end of the array or
      list without finding the value, the search method usually returns a -1 to
      show that it didn’t find the value in the array or list. Click on <em>Show
      CodeLens</em> below to see linear search in action.
    </p>

    <activity label="seqSearch">
      <statement>
        <p>
          The code for <c>sequentialSearch</c> for arrays below is from a
          previous AP CSA course description. Click on the Code Lens button to
          see this code running in the Java visualizer.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class ArraySearcher
{

    /**
     * Finds the index of a value in an array of integers.
     *
     * @param elements an array containing the items to be searched.
     * @param target the item to be found in elements.
     * @return an index of target in elements if found; -1 otherwise.
     */
    public static int sequentialSearch(int[] elements, int target)
    {
        for (int j = 0; j &lt; elements.length; j++)
        {
            if (elements[j] == target)
            {
                return j;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        int[] numArray = {3, -2, 9, 38, -23};
        System.out.println("Tests of sequentialSearch");
        System.out.println(sequentialSearch(numArray, 3));
        System.out.println(sequentialSearch(numArray, 9));
        System.out.println(sequentialSearch(numArray, -23));
        System.out.println(sequentialSearch(numArray, 99));
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "Tests of sequentialSearch\n0\n2\n4\n-1";
        boolean passed = getResults(expect, output, "Expected output from main", true);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <p>
      Here is the same search with an <c>ArrayList</c>. The same algorithms can
      be used with arrays or <c>ArrayList</c>s, but notice that <c>size()</c>
      and <c>get(i)</c> are used with <c>ArrayList</c>s instead of <c>length</c>
      and <c>[i]</c> which are used in arrays. Many of our examples will use
      arrays for simplicity since with arrays, we know how many items we have
      and the size won’t change during runtime. There are methods such as
      <c>contains</c> that can be used in ArrayLists instead of writing your own
      algorithms. However, they are not in the AP CSA Java subset.
    </p>

    <activity label="seqSearchList">
      <statement>
        <p>
          Here is a linear search using ArrayLists. Notice that size() and
          get(i) is used with ArrayLists instead of length and [i] which are
          used in arrays. Click on the Code Lens button to step through this
          code in the visualizer.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
import java.util.*;

public class ArrayListSearcher
{

    /**
     * Finds the index of a value in an ArrayList of integers.
     *
     * @param elements an array containing the items to be searched.
     * @param target the item to be found in elements.
     * @return an index of target in elements if found; -1 otherwise.
     */
    public static int sequentialSearch(ArrayList&lt;Integer&gt; elements, int target)
    {
        for (int j = 0; j &lt; elements.size(); j++)
        {
            if (elements.get(j) == target)
            {
                return j;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        ArrayList&lt;Integer&gt; numList = new ArrayList&lt;Integer&gt;();
        numList.add(3);
        numList.add(-2);
        numList.add(9);
        numList.add(38);
        numList.add(-23);
        System.out.println("Tests of sequentialSearch");
        System.out.println(sequentialSearch(numList, 3));
        System.out.println(sequentialSearch(numList, 9));
        System.out.println(sequentialSearch(numList, -23));
        System.out.println(sequentialSearch(numList, 99));
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "Tests of sequentialSearch\n0\n2\n4\n-1";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <activity label="qss_1">
      <statement>
        <p>
          Which will cause the <em>longest</em> execution of a sequential search
          looking for a value in an array of integers?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>The value is the first one in the array</p>
          </statement>

          <feedback>
            <p>
              This would be true for the shortest execution. This would only
              take one execution of the loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value is in the middle of the array</p>
          </statement>

          <feedback>
            <p>Why would this be the longest execution?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value is the last one in the array</p>
          </statement>

          <feedback>
            <p>There is one case that will take longer.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>The value isn't in the array</p>
          </statement>

          <feedback>
            <p>
              A sequential search loops through the elements of an array or list
              starting with the first and ending with the last and returns from
              the loop as soon as it finds the passed value. It has to check
              every value in the array when the value it is looking for is not
              in the array.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qss_2">
      <statement>
        <p>
          Which will cause the <em>shortest</em> execution of a sequential
          search looking for a value in an array of integers?
        </p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>The value is the first one in the array</p>
          </statement>

          <feedback>
            <p>This would only take one execution of the loop.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value is in the middle of the array</p>
          </statement>

          <feedback>
            <p>Are you thinking of binary search?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value is the last one in the array</p>
          </statement>

          <feedback>
            <p>
              This would be true if you were starting at the last element, but
              the algorithm in the course description starts with the first
              element.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value isn't in the array</p>
          </statement>

          <feedback>
            <p>
              This is true for the longest execution time, but we are looking
              for the shortest.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can also look for a <c>String</c> in an array or list, but be sure to
      use <c>equals</c> rather than <c>==</c>. Remember that <c>==</c> is only
      true when the two references refer to the same <c>String</c> object, while
      <c>equals</c> returns true if the characters in the two <c>String</c>
      objects are the same.
    </p>

    <activity label="seqSearchStr">
      <statement>
        <p>
          Demonstration of a linear search for a String. Click on the Code Lens
          button or the link below to step through this code.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class SearchTest
{

    public static int sequentialSearch(String[] elements, String target)
    {
        for (int j = 0; j &lt; elements.length; j++)
        {
            if (elements[j].equals(target))
            {
                return j;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        String[] arr1 = {"blue", "red", "purple", "green"};

        // test when the target is in the array
        int index = sequentialSearch(arr1, "red");
        System.out.println(index);

        // test when the target is not in the array
        index = sequentialSearch(arr1, "pink");
        System.out.println(index);
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "1\n-1";
        boolean passed = getResults(expect, output, "Expected output from main", true);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="linear-search-with-2d-arrays">
    <title>Linear Search with 2D Arrays</title>
    <p>
      We can also apply the linear search algorithm to data in a 2D array. We
      can loop through each row of the 2D array and then apply the linear search
      algorithm to each row to find an element. The code below demonstrates this
      with a 2D array of integers. Click on the Code Lens button to step through
      this code. Then, change it to work with a 2D array of Strings. Remember to
      use the <c>equals</c> method to compare Strings.
    </p>

    <activity label="linearSearch2DArrays">
      <statement>
        <p>
          What will the following code print? Click on the Code Lens button to
          step through this code. Can you change the code to work for a String
          2D array instead of an int array? Note that the indices row and col
          will still be ints. Remember to use the <c>equals</c> method to
          compare Strings.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class Search
{
    public static boolean search(int[][] array, int value)
    {
        boolean found = false;
        for (int row = 0; row &lt; array.length; row++)
        {
            for (int col = 0; col &lt; array[0].length; col++)
            {
                if (array[row][col] == value)
                {
                     found = true;
                }
            }
        }
        return found;
    }

    public static void main(String[] args)
    {
        int[][] matrix = { {3, 2, 3}, {4, 3, 6}, {8, 9, 3}, {10, 3, 3}};
        System.out.println(search(matrix, 10));
        System.out.println(search(matrix, 11));

        // Comment out the code above, and try these:
        // String[][] matrix2 = { {"a","b","c"},{"d","e","f"} };
        // System.out.println(search(matrix2, "b"));

    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("Search");
    }

    @Test
    public void test2()
    {
        String[][] array = { {"a", "b", "c"}, {"d", "e", "f"}, {"g", "h", "i"}, {"j", "k", "l"}};
        String value = "b";
        Object[] args = {array, value};

        String output = getMethodOutput("search", args);
        String expect = "true";

        boolean passed =
                getResults(
                        expect,
                        output,
                        "Testing search({"
                            + " {\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"},{\"g\",\"h\",\"i\"},{\"j\",\"k\",\"l\""
                            + " } }, \"b\")");
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="binary-search">
    <title>Binary Search</title>
    <idx>binary search</idx>
    <idx>
      <h>search</h><h>binary</h>
    </idx>

    <p>
      How do you search for something in a phone book or dictionary that is in
      alphabetical or numerical order? If you’re looking for something beginning
      with M or on page 100 in a 200 page book, you wouldn’t want to start with
      page 1. You would probably start looking somewhere in the middle of the
      book. This is the idea behind <term>binary search</term>.
    </p>

    <p>
      If your array or list is already in order (sorted), binary search will on
      average find an element or determine that it is missing much more quickly
      than a linear search. But binary search can only be used if the data is
      sorted.
    </p>

    <p>
      Binary search keeps dividing the sorted search space into half. It
      compares a target value to the value in the middle of a range of indices.
      If the value isn’t found it looks again in either the left or right half
      of the current range. Each time through the loop it eliminates half the
      values in the search area until either the value is found or there is no
      more data to look at. See the animation below from <url
      href="https://github.com/AlvaroIsrael/binary-search"
      visual="https://github.com/AlvaroIsrael/binary-search">https://github.com/AlvaroIsrael/binary-search</url>:
    </p>

    <figure align="center">
      <image source="Unit4-Data-Collections/Figures/binary-search-small.gif" width="89%" />
    </figure>

    <p>
      Binary search calculates the middle index as <c>left + right / 2</c> where
      left starts out at 0 and right starts out at the array length - 1 (the
      index of the last element). Remember that integer division gives an
      integer result so 2.5 becomes 2. It compares the value at the middle index
      with the target value (the value you are searching for). If the target
      value is less than the value at the middle it sets right to middle minus
      one. If the target value is greater than the value at the middle it sets
      left to middle plus one. Otherwise the values match and it returns the
      middle index. It also stops when left is greater than right which
      indicates that the value wasn’t found and it returns -1.
    </p>

    <p>
      The code for <c>binarySearch</c> below is from the AP CSA course
      description. A recursive version of this algorithm will be covered in
      lesson 4.17.
    </p>

    <activity label="binSearch">
      <statement>
        <p>
          Demonstration of iterative binary search. Click on the Code Lens
          button to step through this code.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class SearchTest
{
    public static int binarySearch(int[] elements, int target)
    {
        int left = 0;
        int right = elements.length - 1;
        while (left &lt;= right)
        {
            int middle = (left + right) / 2;
            if (target &lt; elements[middle])
            {
                right = middle - 1;
            }
            else if (target &gt; elements[middle])
            {
                left = middle + 1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        int[] arr1 = {-20, 3, 15, 81, 432};

        // test when the target is in the middle
        int index = binarySearch(arr1, 15);
        System.out.println(index);

        // test when the target is the first item in the array
        index = binarySearch(arr1, -20);
        System.out.println(index);

        // test when the target is in the array - last
        index = binarySearch(arr1, 432);
        System.out.println(index);

        // test when the target is not in the array
        index = binarySearch(arr1, 53);
        System.out.println(index);
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "2\n0\n4\n-1";
        boolean passed = getResults(expect, output, "Expected output from main", true);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <p>
      You can also use binary search with a <c>String</c> array. But, when you
      look for a <c>String</c>, be sure to use <c>compareTo</c> method rather
      than <c>&lt;</c> or <c>&gt;</c> which can only be used with primitive
      types. Remember how the <c>String</c> method <c>compareTo</c> works:
    </p>

    <blockquote>
      <p>
        <ul>
          <li>
            <p>
              <term>int compareTo(String other)</term> returns a negative value
              if the current string is less than the <c>other</c> string, 0 if
              they have the same characters in the same order, and a positive
              value if the current string is greater than the <c>other</c>
              string.
            </p>
          </li>
        </ul>
      </p>
    </blockquote>

    <activity label="binSearchStrings">
      <statement>
        <p>
          Demonstration of binary search with strings using compareTo. Click on
          the Code Lens button to step through the code.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class BinSearchStrings
{
    public static int binarySearch(String[] elements, String target)
    {
        int left = 0;
        int right = elements.length - 1;
        while (left &lt;= right)
        {
            int middle = (left + right) / 2;
            if (target.compareTo(elements[middle]) &lt; 0)
            {
                right = middle - 1;
            }
            else if (target.compareTo(elements[middle]) &gt; 0)
            {
                left = middle + 1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }

    public static void main(String[] args)
    {
        String[] arr1 = {"apple", "banana", "cherry", "kiwi", "melon"};

        // test when the target is in the middle
        int index = binarySearch(arr1, "cherry");
        System.out.println(index);

        // test when the target is the first item in the array
        index = binarySearch(arr1, "apple");
        System.out.println(index);

        // test when the target is in the array - last
        index = binarySearch(arr1, "melon");
        System.out.println(index);

        // test when the target is not in the array
        index = binarySearch(arr1, "pear");
        System.out.println(index);
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "2\n0\n4\n-1";
        boolean passed = getResults(expect, output, "Expected output from main", true);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="runtimes">
    <title>Runtimes</title>
    <p>
      How do we choose between two algorithms that solve the same problem? They
      usually have different characteristics and <term>runtimes</term> which
      measures how fast they run. For the searching problem, it depends on your
      data.
    </p>

    <p>
      Binary search is much faster than linear search, especially on large data
      sets, but it can only be used on sorted data. Often with runtimes,
      computer scientist think about the <term>worst case behavior</term>. With
      searching, the worst case is usually if you cannot find the item. With
      linear search, you would have to go through the whole array before
      realizing that it is not there, but binary search is much faster even in
      this case because it eliminates half the data set in each step. We can
      measure an informal runtime by just counting the number of steps.
    </p>

    <p>
      Here is a table that compares the worst case runtime of each search
      algorithm given an array of n elements. The runtime here is measured as
      the number of times the loop runs in each algorithm or the number of
      elements we need to check in the worst case when we don’t find the item we
      are looking for. Notice that with linear search, the worst case runtime is
      the size of the array n, because it has to look through the whole array.
      For the binary search runtime, we can calculate the number of times you
      can divide n in half until you get to 1. So, for example 8 elements can be
      divided in half to narrow down to 4 elements, which can be further divided
      in half to narrow down to 2 elements, which can be further divided in half
      to get down to 1 element, and then if that is wrong, to 0 elements, so
      that is 4 divisions or guesses to get the answer
      (8-&gt;4-&gt;2-&gt;1-&gt;0). In the table below, every time we double the
      size of N, we need at most one more guess or comparison with binary
      search. It’s much faster than linear search!
    </p>

    <table>
      <tabular row-headers="yes">
        <col top="minor" />
        <col top="minor" />
        <col top="minor" />
        <row header="yes" left="minor">
          <cell bottom="minor" right="minor">N</cell>
          <cell bottom="minor" right="minor">Linear Search</cell>
          <cell bottom="minor" right="minor">Binary Search</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">2</cell>
          <cell bottom="minor" right="minor">2 comparisons</cell>
          <cell bottom="minor" right="minor">2 comparisons</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">4</cell>
          <cell bottom="minor" right="minor">4</cell>
          <cell bottom="minor" right="minor">3</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">8</cell>
          <cell bottom="minor" right="minor">8</cell>
          <cell bottom="minor" right="minor">4</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">16</cell>
          <cell bottom="minor" right="minor">16</cell>
          <cell bottom="minor" right="minor">5</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">100</cell>
          <cell bottom="minor" right="minor">100</cell>
          <cell bottom="minor" right="minor">7</cell>
        </row>
      </tabular>
    </table>

    <p>
      Runtimes can be described with mathematical functions. For an array of
      size n, linear search runtime is a linear function, and binary search
      runtime is a function of log base 2 of n (or log n + 1 comparisons). This
      is called the big-O runtime function in computer science, for example
      O(log n) vs. O(n). You can compare the growth of functions like n and log
      <subscript>2</subscript>n as n, the data size, grows and see that binary
      search runs much faster for any n. You don’t need to know the log n
      runtime growth function for the AP exam, but you should be able to
      calculate how many steps binary search takes for a given n by counting how
      many times you can divide it in half. Or you can start at 1 and keep a
      count of how many times you can double it with the powers of two (1, 2, 4,
      8, 16, 32, 64, 128, 256, 512, 1024, etc.) until you reach a number that is
      slightly above n.
    </p>

    <activity label="qbs_1">
      <statement>
        <p>
          Which will cause the <em>shortest</em> execution of a binary search
          looking for a value in an array of integers?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>The value is the first one in the array</p>
          </statement>

          <feedback>
            <p>This would be true for sequential search, not binary.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>The value is in the middle of the array</p>
          </statement>

          <feedback>
            <p>
              If the value is in the middle of the array the binary search will
              return after one iteration of the loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value is the last one in the array</p>
          </statement>

          <feedback>
            <p>How would that be the shortest in a binary search?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The value isn't in the array</p>
          </statement>

          <feedback>
            <p>
              This is true for the longest execution time, but we are looking
              for the shortest.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qbs_2">
      <statement>
        <p>
          Which of the following conditions must be true in order to search for
          a value using binary search?
        </p>

        <program language="java">
          <code>
I. The values in the array must be integers.
II. The values in the array must be in sorted order.
III. The array must not contain duplicate values.
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>I only</p>
          </statement>

          <feedback>
            <p>
              You can use a binary search on any type of data that can be
              compared, but the data must be in order.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>I and II</p>
          </statement>

          <feedback>
            <p>
              You can use a binary search on any type of data that can be
              compared.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>II only</p>
          </statement>

          <feedback>
            <p>
              The only requirement for using a Binary Search is that the values
              must be ordered.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>II and III</p>
          </statement>

          <feedback>
            <p>The array can contain duplicate values.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qbs_3">
      <statement>
        <p>
          How many times would the loop in the binary search run for an array
          int[] arr = {2, 10, 23, 31, 55, 86} with binarySearch(arr,55)?
        </p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>2</p>
          </statement>

          <feedback>
            <p>
              It will first compare with the value at index 2 and then index 4
              and then return 4.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>1</p>
          </statement>

          <feedback>
            <p>This would be true if we were looking for 23.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>3</p>
          </statement>

          <feedback>
            <p>This would be true if we were looking for 31.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qbs_4">
      <statement>
        <p>
          If you had an ordered array of size 500, what is the maximum number of
          iterations required to find an element with binary search?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>approximately 15 times</p>
          </statement>

          <feedback>
            <p>How many times can you divide 500 in half?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>approximately 9 times</p>
          </statement>

          <feedback>
            <p>
              You can divide 500 in half, 9 times, or you can observe that 2^9 =
              512 which is slightly bigger than 500.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>500 times</p>
          </statement>

          <feedback>
            <p>How many times can you divide 500 in half?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>2 times</p>
          </statement>

          <feedback>
            <p>How many times can you divide 500 in half?</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-search-runtimes">
    <title>Coding Challenge : Search Runtimes</title>
    <p>
      Let’s go back to the spellchecker that we created with arrays. Here is a
      version of the spellchecker below that reads the dictionary file into an
      <c>ArrayList</c>. The advantage of using an <c>ArrayList</c> instead of an
      array for the dictionary is that we do not need to know or declare the
      size of the dictionary in advance.
    </p>

    <p>
      In the spellchecker challenge, we used linear search to find a word in the
      dictionary. However, the dictionary file is actually in alphabetical
      order. We could have used a much faster binary search algorithm! Let’s see
      how much faster we can make it.
    </p>

    <p>
      Write a linear search method and a binary search method to search for a
      given word in the dictionary using the code in this lesson as a guide. You
      will need to use <c>size</c> and <c>get(i)</c> instead of [] to get an
      element in the <c>ArrayList</c> dictionary at index i. You will need to
      use the <c>equals</c> and <c>compareTo</c> methods to compare Strings.
      Have the methods return a count of how many words they had to check before
      finding the word or returning.
    </p>

    <project label="challenge-search-coding">
      <statement>
        <p>
          This spellchecker uses an ArrayList for the dictionary. Write a
          <c>linearSearch(word)</c> and a <c>binarySearch(word)</c> method. Use
          <c>get(i)</c>, <c>size()</c>, <c>equals</c>, and <c>compareTo</c>.
          Return a count of the number of words checked.
        </p>
      </statement>

      <program interactive="activecode" language="java" datafile="dictionary.txt">
        <code>
import java.io.*;
import java.nio.file.*;
import java.util.*;

public class SpellChecker
{
    private ArrayList&lt;String&gt; dictionary;

    /* Constructor populates the dictionary ArrayList from the file dictionary.txt*/
    public SpellChecker() throws IOException
    {
        List&lt;String&gt; lines = Files.readAllLines(Paths.get("dictionary.txt"));
        dictionary = new ArrayList&lt;String&gt;(lines);
    }

    /**
     * Write a linearSearch(word) method that finds a word
     * in the ArrayList dictionary. It should also keep
     * a count of the number of words checked.
     *
     * @param String word to be found in elements.
     * @return a count of how many words checked before returning.
     */
    public int linearSearch(String word)
    {

    }

    /**
     * Write a binarySearch(word) method that finds the word
     * in the ArrayList dictionary. It should also keep
     * a count of the number of words checked.
     *
     * @param String word to be found in elements.
     * @return a count of how many words checked before returning.
     */
    public int binarySearch(String word)
    {

    }

    public static void main(String[] args) throws IOException
    {
        SpellChecker checker = new SpellChecker();
        String word = "catz";
        int i = checker.linearSearch(word);
        System.out.println("Linear search steps for " + word + " = " + i);
        int count = checker.binarySearch(word);
        System.out.println("Binary search steps for " + word + " = " + count);
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
       super("SpellChecker");
    }


   @Test
   public void test1()
   {
       Object[] args = {"medium"};
       String output = getMethodOutput("linearSearch", args);
       String expect = "5550";

       boolean passed =
               getResults(
                       expect,
                       output,
                       "linearSearch(\"medium\")"
                       );
       assertTrue(passed);
   }

   @Test
   public void test2()
   {
       Object[] args = {"medium"};
       String output = getMethodOutput("binarySearch", args);
       String expect = "13";

       boolean passed =
               getResults(
                       expect,
                       output,
                       "binarySearch(\"medium\")"
                       );
       assertTrue(passed);
   }
}
        </tests>
      </program>
    </project>

    <p>
      Run your code with the following test cases and record the runtime for
      each word in this <url
      href="https://docs.google.com/document/d/1VrQf7wFIEIu7qfOg7FYUTeNWrdrRsPw4eJSdehhz4dM/edit?usp=sharing"
      visual="https://docs.google.com/document/d/1VrQf7wFIEIu7qfOg7FYUTeNWrdrRsPw4eJSdehhz4dM/edit?usp=sharing">Google
      document</url> (do File/Make a Copy) also seen below to record your
      answers.
    </p>

    <interactive iframe="iframe/search.html" width="100%" aspect="1:1" />
    <p>
      What do you notice? Which one was faster in general? Were there some cases
      where each was faster? How fast were they with misspelled words? Record
      your answers in the window below.
    </p>

    <project label="challenge-binary-search">
      <statement>
        <p>
          After you complete your code, write in your comparison of the linear
          vs. binary search runtimes based on your test cases. Were there any
          cases where one was faster than the other? How did each perform in the
          worst case when a word is misspelled?
        </p>
      </statement>

      <response />
    </project>
  </subsection>

  <subsection xml:id="summary-40">
    <title>Summary</title>
    <p>
      <ul>
        <li>
          <p>
            (AP 4.14.A.1) <term>Linear search algorithms</term> are standard
            algorithms that check each element in order until the desired value
            is found or all elements in the array or <c>ArrayList</c> have been
            checked. Linear search algorithms can begin the search process from
            either end of the array or <c>ArrayList</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.14.A.2) When applying linear search algorithms to 2D arrays,
            each row must be accessed then linear search applied to each row of
            the 2D array.
          </p>
        </li>

        <li>
          <p>
            The <term>binary search</term> algorithm starts at the middle of a
            sorted array or <c>ArrayList</c> and eliminates half of the array or
            <c>ArrayList</c> in each iteration until the desired value is found
            or all elements have been eliminated.
          </p>
        </li>

        <li>
          <p>
            (AP 4.17.B.1 preview) Data must be in sorted order to use the binary
            search algorithm.
          </p>
        </li>

        <li>
          <p>
            (AP 4.17.B.2 preview) Binary search is typically more efficient than
            linear search.
          </p>
        </li>

        <li>
          <p>
            (AP 4.17.B.3 preview) The binary search algorithm can be written
            either iteratively or recursively. (The recursive solution will be
            presented in lesson 4.17).
          </p>
        </li>

        <li>
          <p>
            Informal run-time comparisons of program code segments can be made
            using statement execution counts.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
