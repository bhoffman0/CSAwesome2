<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="topic-4-16-recursion">
  <time minutes="90" />
  <title>Recursion</title>
  <introduction>
    <idx>recursion</idx>
    <idx>
      <h>recursion</h><h>definition</h>
    </idx>

    <p>
      <term>Recursion</term> is when a method calls itself. It is a form of
      repetition. See the example method below.
    </p>

    <program language="java" line-numbers="yes">
      <code line-numbers="yes">
public static void neverEnd()
{
  System.out.println("This is the method that never ends!");
  neverEnd();
}
      </code>
    </program>

    <idx>infinite recursion</idx>
    <idx>
      <h>recursion</h><h>infinite</h>
    </idx>

    <p>
      This method will print out “This is the method that never ends!” and then
      call itself, which will print out the message again, and then call itself,
      and so on. This is called <term>infinite recursion</term>, which is a
      recursion that never ends. Of course, this particular method is not very
      useful. (Actually, in practice it <em>will</em> end, crashing with a
      <c>StackOverFlowError</c> because there is a limit on how many times you
      can recurse.)
    </p>
  </introduction>

  <subsection xml:id="recursive-call">
    <title>Recursive Call</title>
    <p>
      Well-constructed recursive methods contain at least one <term>base
      case</term>, which halts the recursion, and at least one <term>recursive
      call</term>.
    </p>

    <activity label="recurb1fill">
      <statement>
        <p>
          Which line number contains the recursive call (the call to the same
          method) in the method <c>neverEnd</c> (shown above)?
        </p>

        <p>
          <fillin answer="4" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>
              Correct! This line contains a call to the same method, making it a recursive method.
            </feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>Look for a call to the same method name within the method body.</feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="qrb_1">
      <statement>
        <p>Is the following method recursive?</p>
        
          <program language="java">
            <code>
public static int mystery()
{
   int total = 0;
   for (int i=10; i&gt;0; i--)
   {
      total = total + i;
   }
   return total;
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>Yes</p>
          </statement>

          <feedback>
            <p>Where is the call to the same method?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>No</p>
          </statement>

          <feedback>
            <p>
              There is no call to the same method, so this can not be a
              recursive method. It uses iteration instead.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qrb_2">
      <statement>
        <p>Is the following method recursive?</p>

          <program language="java">
            <code>
public static int mystery2(int x)
{
   if (x == 1) return 1;
   else return x + mystery2(x-1);
}
            </code>
          </program>

      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>Yes</p>
          </statement>

          <feedback>
            <p>
              Yes, any method that contains at least one call to the same method
              is recursive.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>No</p>
          </statement>

          <feedback>
            <p>Look again. Check if the method contains a call to itself.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="why-use-recursion">
    <title>Why use Recursion?</title>
    <idx>fractal</idx>
    <idx>
      <h>recursion</h><h>purpose</h>
    </idx>

    <p>
      Recursion is most useful for solving problems where the structure of the
      problem allows it to be broken into smaller, but similar problems, whose
      solutions can be combined into the solution to the original problem.
    </p>

    <p>
      For example, suppose you wanted to find out how much space a folder on
      your computer uses? Well, if you knew how much space each of the files and
      sub-folders in that folder used, you could add them up and get the answer.
      Getting the size of a regular file is usually easy, but figuring out how
      much space each sub-folder takes up is the same problem we stared with,
      just with a different folder.
    </p>

    <p>
      But that’s actually great news because we can use the same procedure to
      solve this smaller problem: find the size of all the files and sub-folders
      in <em>it</em> and add them up. Eventually, as we try to get the size more
      deeply nested folders, eventually we’ll get to folders that only contain
      plain files whose sizes we can add up and return and eventually we work
      our way back up to give the answer to our question about the original
      top-most folder.
    </p>

    <p>
      Recursion can also be used to create fractals. A simple example is
      Sierpinski’s triangle in which you subdivide a triangle into 4 new
      triangles as shown below. You can then do the some procedure with each new
      triangle except the center one.
    </p>

    <figure align="center">
      <caption>A sequence of Sierpinski’s triangles</caption>
      <image source="Unit4-Data-Collections/Figures/triangleSub.png" width="81%" />
    </figure>

    <p>
      Recursion can also be used to traverse <c>String</c>s, arrays, and
      <c>ArrayList</c>s just like a loop. In fact, any loop—also known as
      <em>iterative</em> code—can be written using recursion. However in most
      languages, including Java, there are limitations on how deeply code can
      recurse which rules out using recursion for infinite or even very long
      loops, so we don’t usually use recursion when a simple loop will do. In
      theory though, any iterative code can be written recursively and vice
      versa.
    </p>

    <p>
      On the other hand, recursion is more powerful than simple loops,
      especially when dealing with branching structures like the file folder
      example. Computer scientists call such structures “trees” and they are
      incredibly common in computer programs.
    </p>

    <p>
      Recursive procedures that operate on trees often cannot be easily
      translated into simple loops, at least not without using some extra data
      structures to keep track where you are in the tree. Thus one way to think
      about recursion is as “loops for trees”. If you need to loop over a simple
      linear structure like a <c>String</c> or an array, by all mean use a
      <c>for</c> loop. And if you want to navigate a 2D array a pair of nested
      <c>for</c> loops is the way to go. But if you need to traverse a tree
      structure, recursion should be your go to.
    </p>
  </subsection>

  <subsection xml:id="factorial-method">
    <title>Factorial Method</title>
    <p>
      The following video is also on YouTube at <url
      href="https://youtu.be/V2S_8E_ubBY"
      visual="https://youtu.be/V2S_8E_ubBY">https://youtu.be/V2S_8E_ubBY</url>.
      It introduces the concept of recursion and tracing recursion with the
      factorial method.
    </p>

    <video youtube="V2S_8E_ubBY" label="video-factorial" />
    <idx>factorial</idx>
    <p>
      See the method <title_reference>factorial</title_reference> below that
      calculates the <term>factorial</term> of a number. The
      <term>factorial</term> of a number is defined as 1 for 0 and <c>n *
      factorial (n-1)</c> for any other number.
    </p>

    <program language="java" line-numbers="yes">
      <code>
public static int factorial(int n)
{
    if (n == 0)
        return 1;
    else
        return n * factorial(n-1);
}
      </code>
    </program>

    <p>
      You can also play with an interactive demonstration of the recursive
      factorial computation at <url
      href="https://gigamonkeys.com/misc/factorial/#java"
      visual="https://gigamonkeys.com/misc/factorial/#java">https://gigamonkeys.com/misc/factorial/#java</url>.
    </p>

    <activity label="recurb2fill">
      <statement>
        <p>
          Which line number in the method <c>factorial</c> above contains the
          recursive call (the call to the same method)?
        </p>

        <p>
          <fillin answer="6" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>
              Correct! This line contains a call to the same method, making it a recursive method.
            </feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>Look for a call to the same method name within the method body.</feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="FactorialTest">
      <statement>
        <p>
          Run the code below to test the factorial method. What’s the factorial
          of 6? Add another test to print out the factorial of 6. What’s the
          factorial of 1? Add another test to print out the factorial of 1.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class FactorialTest
{

    public static int factorial(int n)
    {
        if (n == 0) return 1;
        else return n * factorial(n - 1);
    }

    public static void main(String[] args)
    {
        System.out.println("factorial of 3 is: " + factorial(3));
        System.out.println("factorial of 4 is: " + factorial(4));
        System.out.println("factorial of 5 is: " + factorial(5));
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect =
                "factorial of 3 is: 6\n"
                    + "factorial of 4 is: 24\n"
                    + "factorial of 5 is: 120\n"
                    + "factorial of 6 is: 720\n"
                    + "factorial of 1 is: 1\n";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="base-case">
    <title>Base Case</title>
    <idx>base case</idx>
    <idx>
      <h>recursion</h><h>base case</h>
    </idx>

    <p>
      Every non-infinite recursive method must have at least one <term>base
      case</term> where the method can return an answer without another
      recursive call. In other words, the base case is the smallest possible
      problem (or problems) that the method knows how to solve, the ones it can
      answer directly without any more recursion.
    </p>

    <p>
      The base case is often handled by an <c>if</c> statement that checks for
      the base case and returns directly when the condition for the base case is
      met.
    </p>

    <p>
      In the factorial method, the base case is when the argument is 0 as that
      is the smallest number that the factorial method can handle since
      factorial isn’t defined for negative numbers.
    </p>

    <p>
      When we recurse through folders on our computer there are two base cases,
      a simple file, whose size we can find out directly, and an empty folder
      whose size is 0 (or maybe some other fixed amount, depending on the
      operating system). In those two cases a method to compute the space used
      by a file or folder could return immediately; in all others it would have
      to recurse to get the sizes of the files and sub-folders it contains and
      then add them up.
    </p>

    <p>
      The goal of every recursive call in a recursive method is to shrink the
      problem in some way that gets closer to the base case. You can see that in
      <c>factorial</c> where the recursive call is passing <c>n - 1</c>, one
      closer to <c>0</c>. If you write a recursive method (not required for the
      AP exam), you should make sure that every time you recurse you are
      shrinking the problem so it is closer to the base case—that’s the
      equivalent in recursion to incrementing your loop variable in a <c>for</c>
      loop.
    </p>

    <activity label="rec_base1">
      <statement>
        <p>
          Click on the line or lines that contain the test for the base case
        </p>
      </statement>

      <feedback>
        <p>
          When a base case test is true a value is returned and the recursion
          stops.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public static int factorial(int n)</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="yes">if (n == 0)</area></cline>
        <cline>        <area correct="no">return 1;</area></cline>
        <cline>    <area correct="no">else</area></cline>
        <cline>        <area correct="no">return n * factorial(n-1);</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <activity label="qrb_3">
      <statement>
        <p>
          What is the value of n when this method stops calling itself (when it
          reaches the base case)?
        </p>


          <program language="java">
            <code>
public static int product(int n)
{
   if(n == 1)
      return 1;
   else
      return n * product(n - 2);
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>0</p>
          </statement>

          <feedback>
            <p>
              Look again. What is the value of n when this method returns a
              value, without doing a recursive call?
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>1</p>
          </statement>

          <feedback>
            <p>This method stops calling itself when n equals 1 (line 3).</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>2</p>
          </statement>

          <feedback>
            <p>
              Look for a return with a number after it. When is this code
              executed?
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qrb_4">
      <statement>
        <p>
          What is/are the values of the variable bunnies when this method stops
          calling itself (when it reaches the base case)?
        </p>


          <program language="java">
            <code>
public static int bunnyEars(int bunnies)
{
   if (bunnies == 0) return 0;
   else if (bunnies == 1) return 2;
   else return 2 + bunnyEars(bunnies - 1);
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>0</p>
          </statement>

          <feedback>
            <p>This method also stops for another value of bunnies.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>1</p>
          </statement>

          <feedback>
            <p>This method also stops for another value of bunnies.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>Both 0 and 1</p>
          </statement>

          <feedback>
            <p>This method stops calling itself when bunnies is either 0 or 1.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qrb_5-new">
      <statement>
        <p>Is the following method recursive?</p>

          <program language="java">
            <code>
public static int bunnyEars(int bunnies)
{
   int total = 0;
   for (int i = 0; i &lt; bunnies; i++)
   {
      total = total + 2;
   }
   return total;
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>yes</p>
          </statement>

          <feedback>
            <p>Where is the call to the same method?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>no</p>
          </statement>

          <feedback>
            <p>
              There is no call to the same method, so it is not recursive. This
              uses iteration instead.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="tracing-recursive-methods">
    <title>Tracing Recursive Methods</title>
    <idx>call stack</idx>
    <idx>stack</idx>
    <p>
      In Java, the <term>call stack</term> keeps track of the methods that you
      have called since the main method executes. A <term>stack</term> is a way
      of organizing data that adds and removes items only from the top of the
      stack. An example is a stack of cups. You can grap a cup from the top of
      the stack or add more cups at the top of the stack.
    </p>

    <figure align="center">
      <caption>Stacks of cups</caption>
      <image source="Unit4-Data-Collections/Figures/cupStack.jpg" width="54%" />
    </figure>

    <p>
      When you are executing one method (method a) and it calls another method
      (method b) the method call is placed on the call stack along with
      information about where it was called from, which tells the run-time where
      to return to when the current method finishes executing. When method b
      finishes executing the run-time pops the method b off of the call stack
      and returns execution to the next line to be executed in method a.
    </p>

    <p>Consider the following class definition.</p>
    <figure align="center">
      <caption>Code with a divide by zero in a method.</caption>
      <image source="Unit4-Data-Collections/Figures/codeForCallStack.png" width="71%" />
    </figure>

    <p>
      The code above will cause a run-time error of division by zero when it
      runs. The <c>main</c> method calls the method <c>test1</c> (at line 20)
      which calls the method <c>test2</c> (at line 6) which has the divide by
      zero error (line 14). This can be seen in the call stack shown below which
      shows the call stack from the top (most recent method) to the bottom
      (first method call).
    </p>

    <figure align="center">
      <caption>A call stack in DrJava with a run-time error</caption>
      <image source="Unit4-Data-Collections/Figures/errorCallStack.png" width="100%" />
    </figure>

    <p>
      When a method calls itself the new method call gets added to the top of
      the call stack. Execution of the current method pauses while the recursive
      call is being processed. Each recursive call on the stack has its own set
      of local variables, including the parameter variables. Parameter values
      capture the progress of a recursive process, much like loop control
      variable values capture the progress of a loop. The parameter values
      usually change in each recursive call until we reach the base case which
      stops the recursion when a parameter reaches some base value.
    </p>

    <p>
      Let’s trace the execution of the factorial method defined below.
    </p>

    <program language="java">
      <code>
public static int factorial(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return n * factorial(n-1);
    }
}
      </code>
    </program>

    <p>
      What happens when we call <c>factorial(0)</c>? It will return 1 (line 5)
      since n is equal to 0. How about <c>factorial(1)</c>? It will return <c>1
      * factorial(0)</c>. We already know that <c>factorial(0)</c> returns 1,
      but the computer won’t <em>remember</em> that. It will execute
      <c>factorial(0)</c> and return the result (1). So <c>factorial(1)</c>
      returns <c>1 * 1 which is 1</c>.
    </p>

    <p>
      How can you show what is happening in a recursive call? Here is one way to
      do it. The lines below show the call stack upside down (with the bottom of
      the stack, or the beginning at the top and the most recent call at the
      bottom) for a call to <c>factorial(5)</c>. This is a handy way to trace a
      recursive method on the exam and you will do much better on recursive
      problems if you practice doing it this way.
    </p>

    <program language="java">
      <code>
factorial(5) returns 5 * factorial(4)
factorial(4) returns 4 * factorial(3)
factorial(3) returns 3 * factorial(2)
factorial(2) returns 2 * factorial(1)
factorial(1) returns 1 * factorial(0)
factorial(0) returns 1
      </code>
    </program>

    <p>
      Once factorial(0) executes and returns 1 that value can be substituted
      back into the previous method call, starting at the top of the stack
      (shown at the bottom here) and working our way back to the bottom of the
      stack (shown at the top here).
    </p>

    <program language="java">
      <code>
factorial(5) returns 5 * factorial(4) = 5 * 24 = 120
factorial(4) returns 4 * factorial(3) = 4 * 6 = 24
factorial(3) returns 3 * factorial(2) = 2 so 3 * 2 = 6
factorial(2) returns 2 * factorial(1) = 1 so 2 * 1 = 2
factorial(1) returns 1 * factorial(0) = 1 so 1 * 1 = 1
factorial(0) returns 1
      </code>
    </program>

    <p>
      So <c>factorial(5)</c> returns 120.
    </p>

    <p>
      You can step through this code using the Java Visualizer by clicking on
      this link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+factorial(int+n)%0A+++%7B%0A+++++if+(n+%3D%3D+0)%0A+++++++return+1%3B%0A+++++else%0A+++++++return+n+*+factorial(n-1)%3B%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(factorial(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+factorial(int+n)%0A+++%7B%0A+++++if+(n+%3D%3D+0)%0A+++++++return+1%3B%0A+++++else%0A+++++++return+n+*+factorial(n-1)%3B%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(factorial(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">factorial</url>.
    </p>

    <p>
      Another way to see the call stack in action is to download and use the
      Jeloit software (see <url href="http://cs.joensuu.fi/jeliot/"
      visual="http://cs.joensuu.fi/jeliot/">http://cs.joensuu.fi/jeliot/</url>).
    </p>

    <figure align="center">
      <caption>A call tree in Jeliot</caption>
      <image source="Unit4-Data-Collections/Figures/callTree.png" width="54%" />
    </figure>

    <activity label="qrb_5-old">
      <statement>
        <p>
          Given the method defined below what does the following return:
          factorial(6)?
        </p>


          <program language="java">
            <code>
public static int factorial(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return n * factorial(n-1);
    }
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>1</p>
          </statement>

          <feedback>
            <p>
              This would be correct if it was factorial(0), but don't forget the
              recursive calls.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>120</p>
          </statement>

          <feedback>
            <p>
              This would be correct if it was factorial(5), but this is
              factorial(6).
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>720</p>
          </statement>

          <feedback>
            <p>
              If you remember that factorial(5) was 120 then this is just 6 *
              120 = 720.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>30</p>
          </statement>

          <feedback>
            <p>It doesn't return 6 * 5 it returns 6 * factorial(5).</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qrb_6">
      <statement>
        <p>
          Given the method defined below what does the following return:
          mystery(5)?
        </p>


          <program language="java">
            <code>
public static int mystery(int n)
{
   if (n == 0)
   {
      return 1;
   }
   else
   {
      return 2 * mystery (n - 1);
   }
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>10</p>
          </statement>

          <feedback>
            <p>This would be correct if it addition instead of multiplication.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>32</p>
          </statement>

          <feedback>
            <p>This method calculates 2 raised to the nth power.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>16</p>
          </statement>

          <feedback>
            <p>Check that you didn't miss one of the recursive calls.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>64</p>
          </statement>

          <feedback>
            <p>This would be true if the call was mystery(6).</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above using the Java Visualizer by clicking
      on the following link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n)+%0A+++%7B+%0A++++++++if+(n+%3D%3D+0)+%0A+++++++++++return+1%3B%0A++++++++else+%0A+++++++++++return+2+*+mystery+(n+-+1)%3B+%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n)+%0A+++%7B+%0A++++++++if+(n+%3D%3D+0)+%0A+++++++++++return+1%3B%0A++++++++else+%0A+++++++++++return+2+*+mystery+(n+-+1)%3B+%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-2</url>.
    </p>

    <activity label="qrb_7">
      <statement>
        <p>
          Given the method defined below what does the following print:
          mystery(4,3)?
        </p>


          <program language="java">
            <code>
public static int mystery(int n, int a)
{
    if (n == 1)
    {
        return a;
    }
    return a * mystery(n-1,a);
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>12</p>
          </statement>

          <feedback>
            <p>This would be correct if it added instead of multiplied.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>81</p>
          </statement>

          <feedback>
            <p>This calculates a to nth power.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>64</p>
          </statement>

          <feedback>
            <p>
              This would be correct if it was 4 to the 3rd instead of 3 to the
              4th power.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>27</p>
          </statement>

          <feedback>
            <p>
              This would be correct if returned 1 instead of a in the base case.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>243</p>
          </statement>

          <feedback>
            <p>This would be correct if it was 3 to the 5th.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above using the Java Visualizer by clicking
      on the following link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n,+int+a)%0A+++%7B%0A+++++++if+(n+%3D%3D+1)+return+a%3B%0A+++++++return+a+*+mystery(n-1,a)%3B%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(4,3))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n,+int+a)%0A+++%7B%0A+++++++if+(n+%3D%3D+1)+return+a%3B%0A+++++++return+a+*+mystery(n-1,a)%3B%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(4,3))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-3</url>.
    </p>

    <p>
      Let’s trace the execution of the bunny ears method defined below.
    </p>

    <program language="java">
      <code>
public static int bunnyEars(int bunnies)
{
   if (bunnies == 0)
   {
       return 0;
   }
   else if (bunnies == 1)
   {
       return 2;
   }
   else {
       return 2 + bunnyEars(bunnies - 1);
   }
}
      </code>
    </program>

    <p>
      What happens when we call <c>bunnyEars(0)</c>? It will return 0 since n is
      equal to 0 (line 3). How about <c>bunnyEars(1)</c>? It will return 2 since
      n is equal to 1 (line 5). What about <c>bunnyEars(5)</c>?
    </p>

    <program language="java">
      <code>
bunnyEars(5) returns 2 + bunnyEars(4)
bunnyEars(4) returns 2 + bunnyEars(3)
bunnyEars(3) returns 2 + bunnyEars(2)
bunnyEars(2) returns 2 + bunnyEars(1)
bunnyEars(1) returns 2
      </code>
    </program>

    <p>
      This approach shows the call stack from bottom to top. Once
      <c>bunnyEars(1)</c> executes and returns 2 that value can be substituted
      back into the previous method call, starting at the top and working our
      way back toward the bottom (or beginning) of the call stack.
    </p>

    <program language="java">
      <code>
bunnyEars(5) returns 2 + bunnyEars(4) = 2 + 8 = 10
bunnyEars(4) returns 2 + bunnyEars(3) = 2 + 6 = 8
bunnyEars(3) returns 2 + bunnyEars(2) = 2 + 4 = 6
bunnyEars(2) returns 2 + bunnyEars(1) = 2 + 2 = 4
bunnyEars(1) returns 2
      </code>
    </program>

    <p>
      So <c>bunnyEars(5)</c> returns 10. You can step through this code using
      the Java Visualizer by clicking on this link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A++public+static+int+bunnyEars(int+bunnies)+%0A++%7B%0A+++++if+(bunnies+%3D%3D+0)+return+0%3B%0A+++++else+if+(bunnies+%3D%3D+1)+return+2%3B%0A+++++else+return+2+%2B+bunnyEars(bunnies+-+1)%3B+%0A++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(bunnyEars(5))%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A++public+static+int+bunnyEars(int+bunnies)+%0A++%7B%0A+++++if+(bunnies+%3D%3D+0)+return+0%3B%0A+++++else+if+(bunnies+%3D%3D+1)+return+2%3B%0A+++++else+return+2+%2B+bunnyEars(bunnies+-+1)%3B+%0A++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(bunnyEars(5))%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">bunnyEars</url>.
    </p>

    <activity label="qrb_8">
      <statement>
        <p>
          Given the method defined below what does the following print:
          mystery(1234)?
        </p>


          <program language="java">
            <code>
public static void mystery (int x) {
   System.out.print(x % 10);

   if ((x / 10) != 0)
   {
      mystery(x / 10);
   }
   System.out.print(x % 10);
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>12344321</p>
          </statement>

          <feedback>
            <p>Remember that 1234 % 10 returns the rightmost digit.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>1234</p>
          </statement>

          <feedback>
            <p>There are two calls that print something in this method.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>4321</p>
          </statement>

          <feedback>
            <p>There are two calls that print something in this method.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>43211234</p>
          </statement>

          <feedback>
            <p>
              This method prints the right most digit and then removes the
              rightmost digit for the recursive call. It prints both before and
              after the recursive call.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>32144123</p>
          </statement>

          <feedback>
            <p>
              Since 1234 % 10 returns the rightmost digit, the first thing
              printed is 4.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above using the Java Visualizer by clicking
      on the following link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+void+mystery+(int+x)+%0A+++%7B%0A++++++++System.out.print(x+%25+10)%3B+%0A%0A++++++++if+((x+/+10)+!%3D+0)+%7B%0A+++++++++++mystery(x+/+10)%3B+%0A++++++++%7D+%0A++++++++System.out.print(x+%25+10)%3B+%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++mystery(1234)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+void+mystery+(int+x)+%0A+++%7B%0A++++++++System.out.print(x+%25+10)%3B+%0A%0A++++++++if+((x+/+10)+!%3D+0)+%7B%0A+++++++++++mystery(x+/+10)%3B+%0A++++++++%7D+%0A++++++++System.out.print(x+%25+10)%3B+%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++mystery(1234)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-4</url>.
    </p>

    <activity label="qrb_9">
      <statement>
        <p>
          Given the method defined below what does the following return:
          mystery(“xyzxyxy”)? Note that this recursive method traverses a
          String.
        </p>


          <program language="java">
            <code>
public static int mystery(String str)
{
   if (str.length() == 1)
   {
       return 0;
   }
   else
   {
      if (str.substring(0,1).equals("y"))
      {
          return 1 + mystery(str.substring(1));
      }
      else
      {
          return mystery(str.substring(1));
      }
   }
}
            </code>
          </program>

      </statement>

      <choices>
        <choice>
          <statement>
            <p>7</p>
          </statement>

          <feedback>
            <p>
              This would be correct if was counting the number of characters in
              the string, but that isn't what it is doing.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>2</p>
          </statement>

          <feedback>
            <p>
              This method seems to be counting the number of y's in the string,
              but fails to check if a single character is a y.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>1</p>
          </statement>

          <feedback>
            <p>Don't forget that there are recursive calls too.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>3</p>
          </statement>

          <feedback>
            <p>
              This would be correct if the base case returned 1 if the single
              character was a y.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>0</p>
          </statement>

          <feedback>
            <p>Don't forget about the recursive calls.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above using the Java Visualizer by clicking
      on the following link: <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(String+str)+%0A+++%7B%0A++++++++if+(str.length()+%3D%3D+1)+return+0%3B%0A++++++++else%0A++++++++%7B%0A+++++++++++if+(str.substring(0,1).equals(%22y%22))+return+1+%2B+%0A++++++++++++++++++++++++++++++++mystery(str.substring(1))%3B%0A+++++++++++else+return+mystery(str.substring(1))%3B%0A++++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(%22xyzxyxy%22))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0"
      visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(String+str)+%0A+++%7B%0A++++++++if+(str.length()+%3D%3D+1)+return+0%3B%0A++++++++else%0A++++++++%7B%0A+++++++++++if+(str.substring(0,1).equals(%22y%22))+return+1+%2B+%0A++++++++++++++++++++++++++++++++mystery(str.substring(1))%3B%0A+++++++++++else+return+mystery(str.substring(1))%3B%0A++++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(%22xyzxyxy%22))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-5</url>
    </p>
  </subsection>

  <subsection xml:id="tracing-challenge-recursion">
    <title>Tracing Challenge : Recursion</title>
    <p>
      Working in pairs, trace through the following recursion problems.
    </p>

    <p>Consider the following recursive method:</p>
    <program language="java">
      <code>
public static int mystery(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return 3 * mystery (n - 1);
    }
}
      </code>
    </program>

    <p>The trace of this code for mystery(4) is shown below.</p>
    <program language="java">
      <code>
mystery(4) returns 3 * mystery(3)
mystery(3) returns 3 * mystery(2)
mystery(2) returns 3 * mystery(1)
mystery(1) returns 3 * mystery(0)
mystery(0) returns A
      </code>
    </program>

    <activity label="recBase1">
      <statement>
        <p>What is the value of A in the trace above?</p>
        <p>
          <fillin answer="1" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the value returned from <c>mystery(0)</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <p>
      Once mystery(0) returns 1 the value for each call to mystery can now be
      calculated and returned.
    </p>

    <program language="java">
      <code>
mystery(4) returns 3 * mystery(3) = 3 * X = Y
mystery(3) returns 3 * mystery(2) = 3 * 9 = 27
mystery(2) returns 3 * mystery(1) = 3 * 3 = 9
mystery(1) returns 3 * mystery(0) = 3 * 1 = 3
mystery(0) returns 1
      </code>
    </program>

    <activity label="recFBTracex1">
      <statement>
        <p>What is the value of X in the trace above?</p>
        <p>
          <fillin answer="27" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the result of <c>mystery(3)</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="recFBTracey1">
      <statement>
        <p>What is the value of Y in the trace above?</p>
        <p>
          <fillin answer="81" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the result of <c>3 * mystery(3)</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <p>Consider the following recursive method:</p>
    <program language="java">
      <code>
public static int strMethod(String str)
{
    if (str.length() == 1)
    {
        return 0;
    }
    else
    {
        if (str.substring(0,1).equals("e"))
        {
            return 1 + strMethod(str.substring(1));
        }
        else
        {
            return strMethod(str.substring(1));
        }
    }
}
      </code>
    </program>

    <program language="java">
      <code>
strMethod("every") returns 1 + strMethod("very")
strMethod("very") returns strMethod("ery")
strMethod("ery") returns 1 + strMethod("ry")
strMethod("ry") returns strMethod("y")
strMethod("y") returns B
      </code>
    </program>

    <activity label="recFBBase2">
      <statement>
        <p>What is the value of B in the trace above?</p>
        <p>
          <fillin answer="0" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the value returned from <c>strMethod("y")</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <p>
      Once <c>strMethod("y")</c> returns, the value from each recursive call on
      the stack can be calculated and returned.
    </p>

    <program language="java">
      <code>
strMethod("every") returns 1 + strMethod("very") = Z
strMethod("very") returns strMethod("ery") = Y
strMethod("ery") returns 1 + strMethod("ry") = 1 + X
strMethod("ry") returns strMethod("y") = 0
strMethod("y") returns 0
      </code>
    </program>

    <activity label="recFBRetX2">
      <statement>
        <p>What is the value of X in the trace above?</p>
        <p>
          <fillin answer="0" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the value returned from <c>strMethod("ry")</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="recFBRetY2">
      <statement>
        <p>What is the value of Y in the trace above?</p>
        <p>
          <fillin answer="1" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the value returned from <c>strMethod("ery")</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="recFBRetZ2">
      <statement>
        <p>What is the value of Z in the trace above?</p>
        <p>
          <fillin answer="2" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct!</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              What is the value returned from <c>strMethod("every")</c>?
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>
  </subsection>

  <subsection xml:id="summary-42">
    <title>Summary</title>
    <p>
      <ul>
        <li>
          <p>
            (AP 4.16.A.1) A <term>recursive method</term> is a method that calls
            itself.
          </p>
        </li>

        <li>
          <p>
            (AP 4.16.A.1) Recursive methods contain at least one <term>base
            case</term>, which halts the recursion, and at least one
            <term>recursive call</term>. (unless it is a case of <term>infinite
            recursion</term>).
          </p>
        </li>

        <li>
          <p>(AP 4.16.A.1) Recursion is another form of repetition.</p>
        </li>

        <li>
          <p>
            (AP 4.16.A.2) Each recursive call has its own set of local
            variables, including the parameters. Parameter values capture the
            progress of a recursive process, much like loop control variable
            values capture the progress of a loop.
          </p>
        </li>

        <li>
          <p>
            (AP 4.16.A.3) Any recursive solution can be replicated through the
            use of an iterative approach and vice versa. (although the recursive
            solution may have memory limitations for the recursive call stack,
            and the iterative approach may require additional data structures).
          </p>
        </li>

        <li>
          <p>
            Note that writing recursive code is outside the scope of the AP
            Computer Science A course and exam.
          </p>
        </li>

        <li>
          <p>
            Recursion can be used to traverse <c>String</c>s, arrays, and
            <c>ArrayList</c>s.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
