<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="topic-4-16-recursion">
  <title>What is Recursion?</title><introduction>
    
    <p><term>Recursion</term> is when a method calls itself. See the example method below.</p>
    <program language="java">
    <code>
public static void neverEnd()
{
  System.out.println("This is the method that never ends!");
  neverEnd();
}
</code>
  </program>
    <p>This method will print out “This is the method that never ends!” and then call
            itself, which will print out the message again, and then call itself, and so on.
            This is called <term>infinite recursion</term>, which is a recursion that never ends. Of
            course, this particular method is not very useful. (Actually, in practice it
            <em>will</em> end, crashing with a <c>StackOverFlowError</c> because there is a limit on how
            many times you can recurse.)</p>
  </introduction>
  <subsection>
            <title>Why use Recursion?</title>
            
            
            <p>Recursion is most useful for solving problems where the structure of the problem
                allows it to be broken into smaller, but similar problems, whose solutions can
                be combined into the solution to the original problem.</p>
            <p>For example, suppose you wanted to find out how much space a folder on your
                computer uses? Well, if you knew how much space each of the files and
                sub-folders in that folder used, you could add them up and get the answer.
                Getting the size of a regular file is usually easy, but figuring out how much
                space each sub-folder takes up is the same problem we stared with, just with a
                different folder.</p>
            <p>But that’s actually great news because we can use the same procedure to solve
                this smaller problem: find the size of all the files and sub-folders in <em>it</em> and
                add them up. Eventually, as we try to get the size more deeply nested folders,
                eventually we’ll get to folders that only contain plain files whose sizes we can
                add up and return and eventually we work our way back up to give the answer to
                our question about the original top-most folder.</p>
            <p>Recursion can also be used to create fractals. A simple example is Sierpinski’s
                triangle in which you subdivide a triangle into 4 new triangles as shown below.
                You can then do the some procedure with each new triangle except the center one.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">A sequence of Sierpinski’s triangles</caption><image source="Unit4-Data-Collections/Figures/triangleSub.png" width="81%%"/></figure>
            <p>Recursion can also be used to traverse <c>String</c>s, arrays, and <c>ArrayList</c>s just like a loop. In fact, any loop—also known as <em>iterative</em> code—can be
                written using recursion. However in most languages, including Java, there are
                limitations on how deeply code can recurse which rules out using recursion for
                infinite or even very long loops so we don’t usually use recursion when a simple
                loop will do.</p>
            <p>On the other hand, recursion is more powerful than simple loops, especially when
                dealing with branching structures like the file folder example. Computer
                scientists call such structures “trees” and they incredibly common in computer
                programs.</p>
            <p>Recursive procedures that operate on trees often cannot be easily translated
                into simple loops, at least not without using some extra data structures to keep
                track where you are in the tree. Thus one way to think about recursion is as
                “loops for trees”. If you need to loop over a simple linear structure like a
                <c>String</c> or an array, by all mean use a <c>for</c> loop. And if you want to
                navigate a 2D array a pair of nested <c>for</c> loops is the way to go. But if you
                need to traverse a tree structure, recursion should be your go to.</p>
        </subsection>
  <subsection>
            <title>Factorial Method</title>
            <p>The following video is also on YouTube at <url href="https://youtu.be/V2S_8E_ubBY" visual="https://youtu.be/V2S_8E_ubBY">https://youtu.be/V2S_8E_ubBY</url>.  It introduces the concept of recursion and tracing recursion with the factorial method.</p>

    <video youtube="V2S_8E_ubBY"/>
                
            
            <p>See the method <title_reference>factorial</title_reference> below that calculates the <term>factorial</term> of a number.  The <term>factorial</term> of a number is defined as 1 for 0 and <c>n * factorial (n-1)</c> for any other number.</p>
            <program language="java"><code>
public static int factorial(int n)
{
    if (n == 0)
        return 1;
    else
        return n * factorial(n-1);
}
</code></program>
            <p>You can also play with an interactive demonstration of the recursive factorial
                computation at <url href="https://gigamonkeys.com/misc/factorial/#java" visual="https://gigamonkeys.com/misc/factorial/#java">https://gigamonkeys.com/misc/factorial/#java</url>.</p>

        <exercise label="recurb2fill">
            <statement>
    <p> Which line in the method factorial contains the recursive call (the call to the same method)? <var/>  </p></statement><setup><var><condition string="^\s*6$\s*$"><feedback><p>Correct.  This line contains a call to the same method, which makes it a recursive method.</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>Look for a call to the same method name</p></feedback></condition></var></setup></exercise>
<exercise label="FactorialTest">
    <statement>
            <p>Run the code below to test the factorial method. What’s the factorial of 6? Add another test to print out the factorial of 6. What’s the factorial of 1? Add another test to print out the factorial of 1.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class FactorialTest
{

    public static int factorial(int n)
    {
        if (n == 0) return 1;
        else return n * factorial(n - 1);
    }

    public static void main(String[] args)
    {
        System.out.println("factorial of 3 is: " + factorial(3));
        System.out.println("factorial of 4 is: " + factorial(4));
        System.out.println("factorial of 5 is: " + factorial(5));
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect =
                "factorial of 3 is: 6\n"
                    + "factorial of 4 is: 24\n"
                    + "factorial of 5 is: 120\n"
                    + "factorial of 6 is: 720\n"
                    + "factorial of 1 is: 1\n";
        boolean passed = getResults(expect, output, "Expected output from main");
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Base Case</title>
            
            
            <p>Every non-infinite recursive method must have at least one <term>base case</term> where
                the method can return an answer without another recursive call. In other words,
                the base case is the smallest possible problem (or problems) that the method
                knows how to solve, the ones it can answer directly without any more recursion.</p>
            <p>The base case is often handled by an <c>if</c> statement that checks for the base
                case and returns directly when the condition for the base case is met.</p>
            <p>In the factorial method, the base case is when the argument is 0 as that is the
                smallest number that the factorial method can handle since factorial isn’t
                defined for negative numbers.</p>
            <p>When we recurse through folders on our computer there are two base cases, a
                simple file, whose size we can find out directly, and an empty folder whose size
                is 0 (or maybe some other fixed amount, depending on the operating system). In
                those two cases a method to compute the space used by a file or folder could
                return immediately; in all others it would have to recurse to get the sizes of
                the files and sub-folders it contains and then add them up.</p>
            <p>The goal of every recursive call in a recursive method is to shrink the problem
                in some way that gets closer to the base case. You can see that in <c>factorial</c>
                where the recursive call is passing <c>n - 1</c>, one closer to <c>0</c>. If you write
                a recursive method (not required for the AP exam), you should make sure that
                every time you recurse you are shrinking the problem so it is closer to the base
                case—that’s the equivalent in recursion to incrementing your loop variable in a
                <c>for</c> loop.</p>

<exercise label="rec_base1">
    <statement><p>Click on the line or lines that contain the test for the base case</p></statement>
<feedback><p>When a base case test is true a value is returned and the recursion stops.</p></feedback>
<areas>
<cline><area correct="no">public static int factorial(int n)</area></cline>
<cline><area correct="no">{</area></cline>
<cline>    <area correct="yes">if (n == 0)</area></cline>
<cline>        <area correct="no">return 1;</area></cline>
<cline>    <area correct="no">else</area></cline>
<cline>        <area correct="no">return n * factorial(n-1);</area></cline>
<cline><area correct="no">}</area></cline>
</areas></exercise>
    <exercise label="qrb_3">
        <statement>

            <p> What is the value of n when this method stops calling itself (when it reaches the base case)?</p>
            <blockquote>
                <program language="java"><code>
public static int product(int n)
{
   if(n == 1)
      return 1;
   else
      return n * product(n - 2);
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>0</p>
                </statement>
                <feedback>
                    <p>Look again.  What is the value of n when this method returns a value, without doing a recursive call?</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>1</p>
                </statement>
                <feedback>
                    <p>This method stops calling itself when n equals 1 (line 3).</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>2</p>
                </statement>
                <feedback>
                    <p>Look for a return with a number after it.  When is this code executed?</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="qrb_4">
        <statement>

            <p> What is/are the values of the variable bunnies when this method stops calling itself (when it reaches the base case)?</p>
            <blockquote>
                <program language="java"><code>
public static int bunnyEars(int bunnies)
{
   if (bunnies == 0) return 0;
   else if (bunnies == 1) return 2;
   else return 2 + bunnyEars(bunnies - 1);
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>0</p>
                </statement>
                <feedback>
                    <p>This method also stops for another value of bunnies.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>1</p>
                </statement>
                <feedback>
                    <p>This method also stops for another value of bunnies.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Both 0 and 1</p>
                </statement>
                <feedback>
                    <p>This method stops calling itself when bunnies is either 0 or 1.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="qrb_5-new">
        <statement>

            <p> Is the following method recursive?</p>
            <blockquote>
                <program language="java"><code>
public static int bunnyEars(int bunnies)
{
   int total = 0;
   for (int i = 0; i &lt; bunnies; i++)
   {
      total = total + 2;
   }
   return total;
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>yes</p>
                </statement>
                <feedback>
                    <p>Where is the call to the same method?</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>no</p>
                </statement>
                <feedback>
                    <p>There is no call to the same method, so it is not recursive. This uses iteration instead.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
        </subsection>
  <subsection>
            <title>Tracing Recursive Methods</title>
            
            
            <p>In Java, the <term>call stack</term> keeps track of the methods that you have called since the main method executes.   A <term>stack</term> is a way of organizing data that adds and removes items only from the top of the stack.  An example is a stack of cups.  You can grap a cup from the top of the stack or add more cups at the top of the stack.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Stacks of cups</caption><image source="Unit4-Data-Collections/Figures/cupStack.jpg" width="54%%"/></figure>
            <p>When you are executing one method (method a) and it calls another method (method b) the method call is placed on the call stack along with information about where it was called from, which tells the run-time where to return to when the current method finishes executing.  When method b finishes executing the run-time pops the method b off of the call stack and returns execution to the next line to be executed in method a.</p>
            <p>Consider the following class definition.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Code with a divide by zero in a method.</caption><image source="Unit4-Data-Collections/Figures/codeForCallStack.png" width="71%%"/></figure>
            <p>The code above will cause a run-time error of division by zero when it runs.  The <c>main</c> method calls the method <c>test1</c> (at line 20) which calls the method <c>test2</c> (at line 6) which has the divide by zero error (line 14).  This can be seen in the call stack shown below which shows the call stack from the top (most recent method) to the bottom (first method call).</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">A call stack in DrJava with a run-time error</caption><image source="Unit4-Data-Collections/Figures/errorCallStack.png" width="100%%"/></figure>
            <p>When a method calls itself the new method call gets added to the top of the call stack. Execution of the current method pauses while the recursive call is being processed. Each recursive call on the stack has its own set of local variables, including the parameter variables. The parameter values progressively change in each recursive call until we reach the base case which stops the recursion.</p>
            <p>Let’s trace the execution of the factorial method defined below.</p>
            <program language="java"><code>
public static int factorial(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return n * factorial(n-1);
    }
}
</code></program>
            <p>What happens when we call <c>factorial(0)</c>?  It will return 1 (line 5) since n is equal to 0.  How about <c>factorial(1)</c>?  It will return <c>1 * factorial(0)</c>.  We already know that <c>factorial(0)</c> returns 1, but the computer won’t <em>remember</em> that.  It will execute <c>factorial(0)</c> and return the result (1).   So  <c>factorial(1)</c> returns <c>1 * 1 which is 1</c>.</p>
            <p>How can you show what is happening in a recursive call?  Here is one way to do it.  The lines below show the call stack upside down (with the bottom of the stack, or the beginning at the top and the most recent call at the bottom) for a call to <c>factorial(5)</c>.  This is a handy way to trace a recursive method on the exam and you will do much better on recursive problems if you practice doing it this way.</p>
            <program language="java"><code>
factorial(5) returns 5 * factorial(4)
factorial(4) returns 4 * factorial(3)
factorial(3) returns 3 * factorial(2)
factorial(2) returns 2 * factorial(1)
factorial(1) returns 1 * factorial(0)
factorial(0) returns 1
</code></program>
            <p>Once factorial(0) executes and returns 1 that value can be substituted back into the previous method call, starting at the top of the stack (shown at the bottom here) and working our way back to the bottom of the stack (shown at the top here).</p>
            <program language="java"><code>
factorial(5) returns 5 * factorial(4) = 5 * 24 = 120
factorial(4) returns 4 * factorial(3) = 4 * 6 = 24
factorial(3) returns 3 * factorial(2) = 2 so 3 * 2 = 6
factorial(2) returns 2 * factorial(1) = 1 so 2 * 1 = 2
factorial(1) returns 1 * factorial(0) = 1 so 1 * 1 = 1
factorial(0) returns 1
</code></program>
            <p>So <c>factorial(5)</c> returns 120.</p>
            <p>You can step through this code using the Java Visualizer by clicking on this link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+factorial(int+n)%0A+++%7B%0A+++++if+(n+%3D%3D+0)%0A+++++++return+1%3B%0A+++++else%0A+++++++return+n+*+factorial(n-1)%3B%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(factorial(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+factorial(int+n)%0A+++%7B%0A+++++if+(n+%3D%3D+0)%0A+++++++return+1%3B%0A+++++else%0A+++++++return+n+*+factorial(n-1)%3B%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(factorial(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">factorial</url>.</p>
            <p>Another way to see the call stack in action is to download and use the Jeloit software (see <url href="http://cs.joensuu.fi/jeliot/" visual="http://cs.joensuu.fi/jeliot/">http://cs.joensuu.fi/jeliot/</url>).</p>
            
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">A call tree in Jeliot</caption><image source="Unit4-Data-Collections/Figures/callTree.png" width="54%%"/></figure>

    <exercise label="qrb_5-old">
        <statement>

            <p>  Given the method defined below what does the following return: factorial(6)?</p>
            <blockquote>
                <program language="java"><code>
public static int factorial(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return n * factorial(n-1);
    }
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>1</p>
                </statement>
                <feedback>
                    <p>This would be correct if it was factorial(0), but don't forget the recursive calls.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>120</p>
                </statement>
                <feedback>
                    <p>This would be correct if it was factorial(5), but this is factorial(6).</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>720</p>
                </statement>
                <feedback>
                    <p>If you remember that factorial(5) was 120 then this is just 6 * 120 = 720.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>30</p>
                </statement>
                <feedback>
                    <p>It doesn't return 6 * 5 it returns 6 * factorial(5).</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="qrb_6">
        <statement>

            <p>  Given the method defined below what does the following return: mystery(5)?</p>
            <blockquote>
                <program language="java"><code>
public static int mystery(int n)
{
   if (n == 0)
   {
      return 1;
   }
   else
   {
      return 2 * mystery (n - 1);
   }
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>10</p>
                </statement>
                <feedback>
                    <p>This would be correct if it addition instead of multiplication.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>32</p>
                </statement>
                <feedback>
                    <p>This method calculates 2 raised to the nth power.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>16</p>
                </statement>
                <feedback>
                    <p>Check that you didn't miss one of the recursive calls.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>64</p>
                </statement>
                <feedback>
                    <p>This would be true if the call was mystery(6).</p>
                </feedback>
            </choice>
</choices>

    </exercise>
            <p>You can step through the code above using the Java Visualizer by clicking on the following link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n)+%0A+++%7B+%0A++++++++if+(n+%3D%3D+0)+%0A+++++++++++return+1%3B%0A++++++++else+%0A+++++++++++return+2+*+mystery+(n+-+1)%3B+%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n)+%0A+++%7B+%0A++++++++if+(n+%3D%3D+0)+%0A+++++++++++return+1%3B%0A++++++++else+%0A+++++++++++return+2+*+mystery+(n+-+1)%3B+%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(5))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-2</url>.</p>

    <exercise label="qrb_7">
        <statement>

            <p>  Given the method defined below what does the following print: mystery(4,3)?</p>
            <blockquote>
                <program language="java"><code>
public static int mystery(int n, int a)
{
    if (n == 1)
    {
        return a;
    }
    return a * mystery(n-1,a);
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>12</p>
                </statement>
                <feedback>
                    <p>This would be correct if it added instead of multiplied.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>81</p>
                </statement>
                <feedback>
                    <p>This calculates a to nth power.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>64</p>
                </statement>
                <feedback>
                    <p>This would be correct if it was 4 to the 3rd instead of 3 to the 4th power.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>27</p>
                </statement>
                <feedback>
                    <p>This would be correct if returned 1 instead of a in the base case.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>243</p>
                </statement>
                <feedback>
                    <p>This would be correct if it was 3 to the 5th.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
            <p>You can step through the code above using the Java Visualizer by clicking on the following link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n,+int+a)%0A+++%7B%0A+++++++if+(n+%3D%3D+1)+return+a%3B%0A+++++++return+a+*+mystery(n-1,a)%3B%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(4,3))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(int+n,+int+a)%0A+++%7B%0A+++++++if+(n+%3D%3D+1)+return+a%3B%0A+++++++return+a+*+mystery(n-1,a)%3B%0A+++%7D+%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(4,3))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-3</url>.</p>
            <p>Let’s trace the execution of the bunny ears method defined below.</p>
            <program language="java"><code>
public static int bunnyEars(int bunnies)
{
   if (bunnies == 0)
   {
       return 0;
   }
   else if (bunnies == 1)
   {
       return 2;
   }
   else {
       return 2 + bunnyEars(bunnies - 1);
   }
}
</code></program>
            <p>What happens when we call <c>bunnyEars(0)</c>?  It will return 0 since n is equal to 0 (line 3).  How about <c>bunnyEars(1)</c>?  It will return 2 since n is equal to 1 (line 5). What about <c>bunnyEars(5)</c>?</p>
            <program language="java"><code>
bunnyEars(5) returns 2 + bunnyEars(4)
bunnyEars(4) returns 2 + bunnyEars(3)
bunnyEars(3) returns 2 + bunnyEars(2)
bunnyEars(2) returns 2 + bunnyEars(1)
bunnyEars(1) returns 2
</code></program>
            <p>This approach shows the call stack from bottom to top.  Once <c>bunnyEars(1)</c> executes and returns 2 that value can be substituted back into the previous method call, starting at the top and working our way back toward the bottom (or beginning) of the call stack.</p>
            <program language="java"><code>
bunnyEars(5) returns 2 + bunnyEars(4) = 2 + 8 = 10
bunnyEars(4) returns 2 + bunnyEars(3) = 2 + 6 = 8
bunnyEars(3) returns 2 + bunnyEars(2) = 2 + 4 = 6
bunnyEars(2) returns 2 + bunnyEars(1) = 2 + 2 = 4
bunnyEars(1) returns 2
</code></program>
            <p>So <c>bunnyEars(5)</c> returns 10.  You can step through this code using the Java Visualizer by clicking on this link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A++public+static+int+bunnyEars(int+bunnies)+%0A++%7B%0A+++++if+(bunnies+%3D%3D+0)+return+0%3B%0A+++++else+if+(bunnies+%3D%3D+1)+return+2%3B%0A+++++else+return+2+%2B+bunnyEars(bunnies+-+1)%3B+%0A++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(bunnyEars(5))%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A++public+static+int+bunnyEars(int+bunnies)+%0A++%7B%0A+++++if+(bunnies+%3D%3D+0)+return+0%3B%0A+++++else+if+(bunnies+%3D%3D+1)+return+2%3B%0A+++++else+return+2+%2B+bunnyEars(bunnies+-+1)%3B+%0A++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(bunnyEars(5))%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">bunnyEars</url>.</p>

    <exercise label="qrb_8">
        <statement>

            <p>  Given the method defined below what does the following print: mystery(1234)?</p>
            <blockquote>
                <program language="java"><code>
public static void mystery (int x) {
   System.out.print(x % 10);

   if ((x / 10) != 0)
   {
      mystery(x / 10);
   }
   System.out.print(x % 10);
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>12344321</p>
                </statement>
                <feedback>
                    <p>Remember that 1234 % 10 returns the rightmost digit.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>1234</p>
                </statement>
                <feedback>
                    <p>There are two calls that print something in this method.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>4321</p>
                </statement>
                <feedback>
                    <p>There are two calls that print something in this method.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>43211234</p>
                </statement>
                <feedback>
                    <p>This method prints the right most digit and then removes the rightmost digit for the recursive call.  It prints both before and after the recursive call.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>32144123</p>
                </statement>
                <feedback>
                    <p>Since 1234 % 10 returns the rightmost digit, the first thing printed is 4.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
            <p>You can step through the code above using the Java Visualizer by clicking on the following link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+void+mystery+(int+x)+%0A+++%7B%0A++++++++System.out.print(x+%25+10)%3B+%0A%0A++++++++if+((x+/+10)+!%3D+0)+%7B%0A+++++++++++mystery(x+/+10)%3B+%0A++++++++%7D+%0A++++++++System.out.print(x+%25+10)%3B+%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++mystery(1234)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+void+mystery+(int+x)+%0A+++%7B%0A++++++++System.out.print(x+%25+10)%3B+%0A%0A++++++++if+((x+/+10)+!%3D+0)+%7B%0A+++++++++++mystery(x+/+10)%3B+%0A++++++++%7D+%0A++++++++System.out.print(x+%25+10)%3B+%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++mystery(1234)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-4</url>.</p>

    <exercise label="qrb_9">
        <statement>

            <p>  Given the method defined below what does the following return: mystery(“xyzxyxy”)? Note that this recursive method traverses a String.</p>
            <blockquote>
                <program language="java"><code>
public static int mystery(String str)
{
   if (str.length() == 1)
   {
       return 0;
   }
   else
   {
      if (str.substring(0,1).equals("y"))
      {
          return 1 + mystery(str.substring(1));
      }
      else
      {
          return mystery(str.substring(1));
      }
   }
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>7</p>
                </statement>
                <feedback>
                    <p>This would be correct if was counting the number of characters in the string, but that isn't what it is doing.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>2</p>
                </statement>
                <feedback>
                    <p>This method seems to be counting the number of y's in the string, but fails to check if a single character is a y.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>1</p>
                </statement>
                <feedback>
                    <p>Don't forget that there are recursive calls too.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>3</p>
                </statement>
                <feedback>
                    <p>This would be correct if the base case returned 1 if the single character was a y.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>0</p>
                </statement>
                <feedback>
                    <p>Don't forget about the recursive calls.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
            <p>You can step through the code above using the Java Visualizer by clicking on the following link: <url href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(String+str)+%0A+++%7B%0A++++++++if+(str.length()+%3D%3D+1)+return+0%3B%0A++++++++else%0A++++++++%7B%0A+++++++++++if+(str.substring(0,1).equals(%22y%22))+return+1+%2B+%0A++++++++++++++++++++++++++++++++mystery(str.substring(1))%3B%0A+++++++++++else+return+mystery(str.substring(1))%3B%0A++++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(%22xyzxyxy%22))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0" visual="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+mystery(String+str)+%0A+++%7B%0A++++++++if+(str.length()+%3D%3D+1)+return+0%3B%0A++++++++else%0A++++++++%7B%0A+++++++++++if+(str.substring(0,1).equals(%22y%22))+return+1+%2B+%0A++++++++++++++++++++++++++++++++mystery(str.substring(1))%3B%0A+++++++++++else+return+mystery(str.substring(1))%3B%0A++++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++System.out.println(mystery(%22xyzxyxy%22))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Ex-11-3-5</url></p>
        </subsection>
  <subsection>
            <title>Tracing Challenge : Recursion</title>
            <p>Working in pairs, trace through the following recursion problems.</p>
            <p>Consider the following recursive method:</p>
            <program language="java"><code>
public static int mystery(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        return 3 * mystery (n - 1);
    }
}
</code></program>
            <p>The trace of this code for mystery(4) is shown below.</p>
            <program language="java"><code>
mystery(4) returns 3 * mystery(3)
mystery(3) returns 3 * mystery(2)
mystery(2) returns 3 * mystery(1)
mystery(1) returns 3 * mystery(0)
mystery(0) returns A
</code></program>

        <exercise label="recBase1">
            <statement>
    <p> What is the value of A in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^1$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the value returned from mystery(0)?</p></feedback></condition></var></setup></exercise>            <p>Once mystery(0) returns 1 the value for each call to mystery can now be calculated and returned.</p>
            <program language="java"><code>
mystery(4) returns 3 * mystery(3) = 3 * X = Y
mystery(3) returns 3 * mystery(2) = 3 * 9 = 27
mystery(2) returns 3 * mystery(1) = 3 * 3 = 9
mystery(1) returns 3 * mystery(0) = 3 * 1 = 3
mystery(0) returns 1
</code></program>

        <exercise label="recFBTracex1">
            <statement>
    <p> What is the value of X in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^27$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the result of mystery(3)?</p></feedback></condition></var></setup></exercise>
        <exercise label="recFBTracey1">
            <statement>
    <p> What is the value of Y in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^81$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the result of 3 * mystery(3)?</p></feedback></condition></var></setup></exercise>            <p>Consider the following recursive method:</p>
            <program language="java"><code>
public static int strMethod(String str)
{
    if (str.length() == 1)
    {
        return 0;
    }
    else
    {
        if (str.substring(0,1).equals("e"))
        {
            return 1 + strMethod(str.substring(1));
        }
        else
        {
            return strMethod(str.substring(1));
        }
    }
}
</code></program>
            <program language="java"><code>
strMethod("every") returns 1 + strMethod("very")
strMethod("very") returns strMethod("ery")
strMethod("ery") returns 1 + strMethod("ry")
strMethod("ry") returns strMethod("y")
strMethod("y") returns B
</code></program>

        <exercise label="recFBBase2">
            <statement>
    <p> What is the value of B in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^0$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the value returned from strMethod(“y”)?</p></feedback></condition></var></setup></exercise>            <p>Once <c>strMethod("y")</c> returns, the value from each recursive call on the stack can be calculated and returned.</p>
            <program language="java"><code>
strMethod("every") returns 1 + strMethod("very") = Z
strMethod("very") returns strMethod("ery") = Y
strMethod("ery") returns 1 + strMethod("ry") = 1 + X
strMethod("ry") returns strMethod("y") = 0
strMethod("y") returns 0
</code></program>

        <exercise label="recFBRetX2">
            <statement>
    <p> What is the value of X in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^0$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the value returned from strMethod(“ry”)?</p></feedback></condition></var></setup></exercise>
        <exercise label="recFBRetY2">
            <statement>
    <p> What is the value of Y in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^1$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the value returned from strMethod(“ery”)?</p></feedback></condition></var></setup></exercise>
        <exercise label="recFBRetZ2">
            <statement>
    <p> What is the value of Z in the trace above? <var/>  </p></statement><setup><var><condition string="^\s*^2$\s*$"><feedback><p>Correct!</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>What is the value returned from strMethod(“every”)?</p></feedback></condition></var></setup></exercise>        </subsection>
  <subsection>
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>A recursive method is a method that calls itself.</p>
                </li>
                <li>
                    <p>Recursive methods that don’t recurse infinitely must contain at least one base
                        case when the method can return an answer immediately.</p>
                </li>
                <li>
                    <p>Each recursive call, like any method call, has its own set of local variables,
                        including its parameters.</p>
                </li>
                <li>
                    <p>Parameter values capture the progress of a recursive process, much like loop
                        variable values capture the progress of a loop.</p>
                </li>
                <li>
                    <p>Any iterative procedure can be implemented with recursion but may run into
                        limitations on how deep the call stack can get.</p>
                </li>
                <li>
                    <p>Some recursive procedures can only be translated into iterative code by using
                        extra data structures to keep track of information that is implicit in the
                        structure of recursive calls in recursive code.</p>
                </li>
                <li>
                    <p>Writing recursive program code is outside the scope of the course and AP Exam.</p>
                </li>
                <li>
                    <p>Recursion can be used to traverse <c>String</c>s, arrays, and <c>ArrayList</c>s.</p>
                </li>
            </ul></p>
        </subsection>
  <exercises>
    <exercise label="recurb1fill">
            <statement>
    <p> Which line in the method neverEnd (shown above) contains the recursive call (the call to the same method)? <var/>  </p></statement><setup><var><condition string="^\s*4$\s*$"><feedback><p>Correct.  This line contains a call to the same method, which makes it a recursive method.</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>Look for a call to the same method name</p></feedback></condition></var></setup></exercise>
    <exercise label="qrb_1">
        <statement>

        <p>  Is the following method recursive?</p>
        <blockquote>
            <program language="java"><code>
public static int mystery()
{
   int total = 0;
   for (int i=10; i&gt;0; i--)
   {
      total = total + i;
   }
   return total;
}
</code></program>
        </blockquote>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Yes</p>
                </statement>
                <feedback>
                    <p>Where is the call to the same method?</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>No</p>
                </statement>
                <feedback>
                    <p>There is no call to the same method, so this can not be a recursive method. It uses iteration instead.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qrb_2">
        <statement>

        <p> Is the following method recursive?</p>
        <blockquote>
            <program language="java"><code>
public static int mystery2(int x)
{
   if (x == 1) return 1;
   else return x + mystery2(x-1);
}
</code></program>
        </blockquote>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>Yes</p>
                </statement>
                <feedback>
                    <p>Yes, any method that contains at least one call to the same method is recursive.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>No</p>
                </statement>
                <feedback>
                    <p>Look again.  Check if the method contains a call to itself.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
  </exercises>
</section>
