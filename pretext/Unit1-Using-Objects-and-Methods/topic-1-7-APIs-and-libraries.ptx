<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="topic-1-7-APIs-and-libraries">
  <title>APIs and Libraries</title><introduction>
    
    <idx>API</idx>
 <idx>library</idx>
 <idx>package</idx>
 <idx>class</idx>
 <idx>attribute</idx>
 <idx>method</idx>
 <idx>dot\ operator</idx>
 <idx>behavior</idx>

    <p>We have been using the <c>System.out.println()</c> method to print to the screen. This method is part of the Java <term>API (Application Programming Interface)</term>. A <term>method</term> is a block of code that performs a specific task. APIs are connected to <term>libraries</term> which are collections of classes written by other programmers that provide a set of methods that can be used to perform specific tasks. An API specification tells the programmer how to use those classes with methods in a library.</p>
    <p>APIs and libraries are essential to programming because they allow you to use code that has already been written by others. This saves you time and allows you to focus on the specific task you are trying to accomplish.</p>
    <p>Classes in the APIs and libraries are grouped into packages. A <term>package</term> is a collection of related classes and interfaces (which are similar to classes) that can be <term>imported</term> into a program to be used.  A package is like a folder of classes in a library’s file directory and is used to avoid name conflicts. Later on, we will learn to <c>import</c> other Java packages to use in our code, but there is a package that is already built into Java called <c>java.lang</c> that we are already using.</p>
    <p>The terms library, API, and package are often used interchangeably to mean similar things. A library is a collection of classes or code written by other programmers that you can use. An API describes how you use the library. And a package is how Java organizes a library to be used.</p>
  </introduction>
  <subsection xml:id="java-lang-package">
            <title>java.lang Package</title>
            <p>The <c>java.lang</c> package contains built-in classes and interfaces that are fundamental to the Java programming language, such as the <c>String</c> class and the <c>System</c> class which we use in <c>System.out.println</c>. Take a look at the documentation for the <c>java.lang</c> package at <url href="https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html" visual="https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html</url>. Can you find the <c>System</c> class in the documentation?</p>
            <p><term>Documentation</term> found in API specifications and libraries is essential to understanding the attributes and behaviors of a class defined by the API. The <c>System</c> class has an object called <c>out</c> that is type <c>PrintStream</c>, and the <c>PrintStream</c> class has a method called <c>println()</c> that we use to print to the screen. How many <c>println()</c> methods are there in the PrintStream class documented at <url href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html" visual="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html</url>?  One for each type that it can print!</p>

        <activity label="count-println">
            <statement>
    <p> How many <c>println</c> methods are there in the <c>PrintStream</c> class documented at <url href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html" visual="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html</url>? <var/>  </p></statement><setup><var><condition number="[10, 10]"><feedback><p>Correct.  One for each type</p></feedback></condition><condition string="^\s*.*\s*$"><feedback><p>Only count the println methods, not print or printf methods.</p></feedback></condition></var></setup></activity>
<activity label="API_vocab_match">
    <statement><p>Drag the definition from the left and drop it on the correct concept on the right. Click the "Check Me" button to see if you are correct.</p></statement>
    <feedback><p>Review the summaries above.</p></feedback>
<matches><match order="1"><premise>A collection of classes written by other programmers</premise><response>library</response></match><match order="2"><premise>A collection of related classes organized to be imported into your code</premise><response>package</response></match><match order="3"><premise>A specification that tells the programmer how to use classes in a library</premise><response>API</response></match><match order="4"><premise>The building blocks of Java and object-oriented programming</premise><response>class</response></match><match order="5"><premise>A block of code that performs a specific task</premise><response>method</response></match></matches></activity>
    <activity label="purpose_apis">
        <statement>

            <p> What is the purpose of APIs and libraries in programming?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>To write new code from scratch</p>
                </statement>
                <feedback>
                    <p>Incorrect. APIs and libraries allow you to use code written by others.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>To use code written by others</p>
                </statement>
                <feedback>
                    <p>Correct! APIs and libraries are used to use code written by others.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>To create programming languages</p>
                </statement>
                <feedback>
                    <p>Incorrect. APIs and libraries are not for creating programming languages.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>To compile code</p>
                </statement>
                <feedback>
                    <p>Incorrect. APIs and libraries are not for compiling code.</p>
                </feedback>
            </choice>
</choices>

    </activity>
        </subsection>
  <subsection xml:id="turtle-library">
            <title>Turtle Library</title>
            <p>The <c>Turtle</c> Java library, written by one of the author’s of this book, Dr. Barbara Ericson, allows you to create drawings using an animated turtle that moves around the screen. The turtle can move forward, turn, and draw lines. The turtle library is a collection of classes that can be imported into your code and is built in to this e-book.</p>
            <p><term>Classes</term> are the building blocks of Java and object-oriented programming. A class defines a specific reference type.  Programmers often create new classes like <c>Turtle</c> so that it can be used as a new data type. Classes like <c>Turtle</c> and class libraries can be utilized to create objects like a particular turtle named <c>yertle</c>.  A class defines the data and behavior for all objects of that type.</p>
            <p>The following picture of a turtle shows some of the Turtle <term>attributes</term> like name, width, height, color in the body of the turtle and its <term>methods</term> like forward(), backward(), written around the turtle.</p>
            <figure align="center"><caption>Turtle Attributes and Behaviors</caption><image source="Unit1-Using-Objects-and-Methods/Figures/turtleOOD.png" width="71%" alt="Turtle attributes and behaviors"/></figure>
            <p><term>Attributes</term> (which are sometimes called <term>fields</term> in documentation) refer to the data related to the class and are stored in variables. <term>Behaviors</term> refer to what objects of the class can do (or what can be done with it) and are defined by methods. The <c>Turtle</c> class has attributes like <c>name</c>, <c>height</c>, and <c>width</c> that store data about the turtle, and it has behaviors/methods like <c>forward()</c> and <c>turnLeft()</c> that allow the turtle to move and turn.  We will learn more about classes, objects, attributes, and methods in the next lessons, but this lesson introduces them to explore APIs.</p>
            <p>How can you tell attributes and methods apart when you look at library documentation? One easy way is that methods will always have parentheses after them, for example <c>forward()</c> or <c>println()</c>. Sometimes these are empty, but still necessary, and sometimes they contain data that the method needs to do its job, for example what to print. Attributes are variables and will not have parentheses after them. Here’s the API documentation that lists all of the Turtle methods (but not the attributes):
                <url href="https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html" visual="https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html">https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html</url>.</p>
            <p>Try the Java program below that creates a Turtle object called <c>yertle</c> using the Turtle class. The following code is used to tell the turtle to move forward and then turn right. The <term>dot operator</term> (.) is used to run an object’s methods, just like in the <c>System.out.println()</c> method.  (If the code below does not work or is too slow in your browser, you can also see the <c>Turtle</c> code in action at this <url href="https://replit.com/@BerylHoffman/Java-Swing-Turtle#Main.java" visual="https://replit.com/@BerylHoffman/Java-Swing-Turtle#Main.java">replit link</url> (refresh page after forking and if it gets stuck) or download the files <url href="https://github.com/bhoffman0/CSAwesome2/raw/main/_sources/Unit1-Using-Objects-and-Methods/TurtleJavaSwingCode.zip" visual="https://github.com/bhoffman0/CSAwesome2/raw/main/_sources/Unit1-Using-Objects-and-Methods/TurtleJavaSwingCode.zip">here</url> to use in your own IDE.)</p>
            <program language="java"><code>
yertle.forward();
yertle.turnRight();
</code></program>

<activity label="TurtleAPI">
    <statement>
            <p>Try clicking the run button below to see what the following program does. Then add 1 more line of code on line 16 to make yertle go forward() again.
               </p>

    </statement>
    <program interactive="activecode" language="java" datafile="turtleClasses.jar,turtleClasses2.jar">
<code>
import java.awt.*;
import java.util.*;

public class TurtleTest
{
    public static void main(String[] args)
    {
        // Do not change the next 2 lines
        World habitat = new World(300, 300);
        Turtle yertle = new Turtle(habitat);

        // Code to make yertle move forward and turn right
        yertle.forward();
        yertle.turnRight();
        // Add a line of code to make yertle go forward() again



        // Do not change
        habitat.show(true);
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("TurtleTest");
    }
    @Test
    public void test1()
    {
        String code = getCode();
        String expect = "yertle.forward";

        int count = countOccurences(code, expect);
        boolean passed = (count &gt;= 2);
        passed = getResults("2+", "" + count, "yertle.forward() count", passed);

        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>

    <activity label="turtle_dir">
        <statement>

            <p> Which way does a turtle face when it is first created?</p>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>North</p>
                </statement>
                <feedback>
                    <p>Turtles start off facing north which is toward the top of the page.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>South</p>
                </statement>
                <feedback>
                    <p>Which way does yertle first move in the example above?</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>East</p>
                </statement>
                <feedback>
                    <p>Which way does yertle first move in the example above?</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>West</p>
                </statement>
                <feedback>
                    <p>Which way does yertle first move in the example above?</p>
                </feedback>
            </choice>
</choices>

    </activity>

    <activity label="turtle_type">
        <statement>

            <p> What type of thing is Turtle in the program above?</p>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>class</p>
                </statement>
                <feedback>
                    <p>Yes, Turtle is a class that defines the data and behaviors for all turtles.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>object</p>
                </statement>
                <feedback>
                    <p>yertle is an object of type Turtle.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>attribute</p>
                </statement>
                <feedback>
                    <p>An attribute is something the object knows about itself.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>method</p>
                </statement>
                <feedback>
                    <p>A method is something an object can do like go forward.</p>
                </feedback>
            </choice>
</choices>

    </activity>

    <activity label="type_turn_right">
        <statement>

            <p> What type of thing is turnRight in the program above?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>object</p>
                </statement>
                <feedback>
                    <p>An object has data and behavior.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>class</p>
                </statement>
                <feedback>
                    <p>A class defines the data and behavior for all objects of that type.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>attribute</p>
                </statement>
                <feedback>
                    <p>An attribute is something the object knows about itself.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>method</p>
                </statement>
                <feedback>
                    <p>A behavior or method is something an object can do like turn right.</p>
                </feedback>
            </choice>
</choices>

    </activity>

    <activity label="type_position">
        <statement>

            <p> What type of thing is the position of a turtle in a world?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>object</p>
                </statement>
                <feedback>
                    <p>An object has data and behavior.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>class</p>
                </statement>
                <feedback>
                    <p>A class defines the data and behavior for all objects of that type.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>attribute</p>
                </statement>
                <feedback>
                    <p>An attribute is something the object knows about itself like its position.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>method</p>
                </statement>
                <feedback>
                    <p>A method is something an object can do like turn right.</p>
                </feedback>
            </choice>
</choices>

    </activity>

    <activity label="attributes_class">
        <statement>

            <p> What are attributes of a class?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Methods that perform tasks</p>
                </statement>
                <feedback>
                    <p>Incorrect. Attributes are not methods.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Data related to the class stored in variables</p>
                </statement>
                <feedback>
                    <p>Correct! Attributes are data related to the class stored in variables.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The arguments of a class</p>
                </statement>
                <feedback>
                    <p>Incorrect. Classes do not have arguments.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Packages that contain the class</p>
                </statement>
                <feedback>
                    <p>Incorrect. Attributes are not packages.</p>
                </feedback>
            </choice>
</choices>

    </activity>
            <image source="Unit1-Using-Objects-and-Methods/Figures/turtleForwardLeftForward.png" width="36%"/>
<activity label="parsons_TurtleL" numbered="yes" adaptive="yes" indentation="hide" language="java"><statement>
            <p>The following program uses a turtle to draw a sideways capital L as seen in the image, but the lines are mixed up.  The program should do all necessary set-up. Then it should ask the turtle to turn right, go forward, turn left, and then go forward 50 pixels. Next, it should ask the habitat to show itself. Drag the needed blocks of statements from the left column to the right column and put them in the right order.  There are 2 extra blocks that are not needed in a correct solution.  Then click on Check Me to see if you are right. You will be told if any of the lines are in the wrong order or are the wrong blocks.</p>
</statement>
<blocks><block order="12">
<cline>import java.util.*;</cline>
<cline>import java.awt.*;</cline>
</block><block order="2">
<cline>public class TurtleTest {</cline>
</block><block order="9">
<cline>    public static void main(String[] args) {</cline>
</block><block order="6">
<cline>        World habitat = new World(300,300);</cline>
<cline>        Turtle yertle = new Turtle(habitat);</cline>
</block><block order="4">
<choice correct="yes"><cline>        yertle.turnRight();</cline>
</choice><choice><cline>        yertle.right(); </cline>
</choice></block><block order="7">
<choice correct="yes"><cline>        yertle.forward();</cline>
</choice><choice><cline>        yertle.forward() </cline>
</choice></block><block order="5">
<cline>        yertle.turnLeft();</cline>
</block><block order="10">
<cline>        yertle.forward(50);</cline>
</block><block order="3">
<cline>        habitat.show(true);</cline>
</block><block order="11">
<cline>    } // end main</cline>
<cline>} // end class</cline>
</block></blocks></activity>        </subsection>
  <subsection xml:id="coding-challenge-turtle-drawing">
            <title>Coding Challenge : Turtle Drawing</title>
            <p>Make yertle the Turtle draw a shape.  For example, have it draw a square or a zigzag shape or a block letter by calling the forward method and a turn method multiple times. We encourage you to work in pairs for this challenge. In the next lessons, we will draw more complicated shapes. Here are some simple turtle methods that you could use or check the API at <url href="https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html" visual="https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html">https://www2.cs.uic.edu/~i101/doc/SimpleTurtle.html</url>:</p>
            <p><ul>
                <li>
                    <p><c>yertle.forward();</c></p>
                </li>
                <li>
                    <p><c>yertle.turnLeft();</c></p>
                </li>
                <li>
                    <p><c>yertle.turnRight();</c></p>
                </li>
                <li>
                    <p><c>yertle.backward();</c></p>
                </li>
                <li>
                    <p><c>yertle.penUp();</c></p>
                </li>
                <li>
                    <p><c>yertle.penDown();</c></p>
                </li>
            </ul></p>

<activity label="challenge1-7-TurtleShape">
    <statement>
            <p>Have yertle draw a shape, for example a square or a zigzag shape or a block letter by calling the forward method and a turn method multiple times.</p>

    </statement>
    <program interactive="activecode" language="java" datafile="turtleClasses.jar,turtleClasses2.jar">
<code>
import java.awt.*;
import java.util.*;

public class TurtleShape
{
    public static void main(String[] args)
    {
        World habitat = new World(500, 500);
        Turtle yertle = new Turtle(habitat);

        // Use yertle's forward and turnRight or turnLeft methods to draw a shape




        // Do not change the line below!
        habitat.show(true);
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("TurtleShape");
    }

    @Test
    public void test2()
    {
        String code = getCode();
        String right = ".turnRight()";
        String left = ".turnLeft()";

        int countR = countOccurences(code, right);
        int countL = countOccurences(code, left);
        int count = countR + countL;

        boolean passed = (count &gt;= 3);

        passed =
                getResults(
                        "3+ turns",
                        "" + count + "+ turns",
                        "3+ turnRight() or turnLeft()",
                        passed);
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String code = getCode();
        String forwards = ".forward";
        String backwards = ".backward";

        int forward = countOccurences(code, forwards);
        int backward = countOccurences(code, backwards);
        int moves = forward + backward;

        boolean passed = (moves &gt;= 4);

        passed =
                getResults(
                        "4+ moves", "" + moves +
                        "+ moves",
                        "forward or backward", passed);
        assertTrue(passed);
    }

    @Test
    public void test4()
    {
        String[] code = getCode().split("\n");
        int expect = 25;

        boolean passed = code.length &gt;= expect;

        passed =
                getResults(
                        expect + "+ line(s)",
                        "" + code.length + " lines(s)",
                        "More than " + expect + " lines of code",
                        passed);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</activity>
        </subsection>
  <subsection xml:id="summary-12">
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>(AP 1.7.A.1) <term>Libraries</term> are collections of classes written by other programmers.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.1) An <term>Application Programming Interface (API)</term> specification informs the programmer how to use classes in a library.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.1) Documentation found in API specifications and libraries is essential to understanding the attributes and behaviors of a class defined by the API.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.1) Classes in the APIs and libraries are grouped into <term>packages</term> that can be imported into a program.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.1) A <term>class</term> defines a specific reference type and is the building block of object-oriented programming. Existing classes and class libraries can be utilized to create objects.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.2) <term>Attributes</term> refer to the data related to the class and are stored in variables.</p>
                </li>
                <li>
                    <p>(AP 1.7.A.2) <term>Behaviors</term> refer to what instances of the class can do (or what can be done with it) and are defined by methods.</p>
                </li>
            </ul></p>
            <DataFileNode line="408" runestone_options="{'hide': None, 'subchapter': 'topic-1-7-APIs-and-libraries', 'chapter': 'Unit1-Using-Objects-and-Methods', 'basecourse': 'csawesome2beta', 'optional': '', 'optclass': '', 'divid': 'turtleClasses.jar', 'qnumber': 'Q-12', 'cols': 65, 'rows': 20, 'filecontent': '  import java.awt.Image;\n  import java.awt.image.BufferedImage;\n\n  /**\n   * Interface to describe a digital picture.  A digital picture can have an\n   * associated file name.  It can have a title.  It has pixels\n   * associated with it and you can get and set the pixels.  You\n   * can get an Image from a picture or a BufferedImage.  You can load\n   * it from a file name or image.  You can show a picture.  You can\n   * explore a picture.  You can create a new image for it.\n   *\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  public interface DigitalPicture\n  {\n    public String getFileName(); // get the file name that the picture came from\n    public String getTitle(); // get the title of the picture\n    public void setTitle(String title); // set the title of the picture\n    public int getWidth(); // get the width of the picture in pixels\n    public int getHeight(); // get the height of the picture in pixels\n    public Image getImage(); // get the image from the picture\n    public BufferedImage getBufferedImage(); // get the buffered image\n    public int getBasicPixel(int x, int y); // get the pixel information as an int\n    public void setBasicPixel(int x, int y, int rgb); // set the pixel information\n    public Pixel getPixel(int x, int y); // get the pixel information as an object\n    public Pixel[] getPixels(); // get all pixels in row-major order\n    public Pixel[][] getPixels2D(); // get 2-D array of pixels in row-major order\n    public void load(Image image); // load the image into the picture\n    public boolean load(String fileName); // load the picture from a file\n    public void show(); // show the picture\n    public boolean write(String fileName); // write out a file\n  }\n  import java.awt.Graphics;\n\n  /**\n   * Interface to used to communicate between a model\n   * and its display\n   *\n   * Copyright Georgia Institute of Technology 2004\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  public interface ModelDisplay\n  {\n    /** method to notify the thing that displays that\n     * the model has changed */\n    public void modelChanged();\n\n    /** method to add the model to the world\n     * @param model the model object to add */\n    public void addModel(Object model);\n\n    /**\n     * Method to remove the model from the world\n     * @param model the model object to remove */\n    public void remove(Object model);\n\n    /**\n     * Method that returns the graphics context\n     * for this model display\n     * @return the graphics context\n     */\n    public Graphics getGraphics();\n\n    /**\n     * Method to clear the background\n     */\n    public void clearBackground();\n\n    /** Method to get the width of the display\n     * @return the width in pixels of the display\n     */\n    public int getWidth();\n\n    /** Method to get the height of the display\n     * @return the height in pixels of the display\n     */\n    public int getHeight();\n  }\n  import java.awt.*;\n  import java.awt.geom.*;\n\n  /**\n   * This class represents a displayable path segment\n   * it has a color, width, and a Line2D object\n   * Copyright Georgia Institute of Technology 2005\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class PathSegment\n  {\n    //////////////// fields /////////////////////\n    private Color color;\n    private int width;\n    private Line2D.Float line;\n\n    //////////////// constructors ///////////////\n\n    /**\n     * Constructor that takes the color, width,\n     * and line\n     */\n    public PathSegment (Color theColor, int theWidth,\n                        Line2D.Float theLine)\n    {\n      this.color = theColor;\n      this.width = theWidth;\n      this.line = theLine;\n    }\n\n    //////////////// methods ////////////////////\n\n    /**\n     * Method to paint this path segment\n     * @param g the graphics context\n     */\n    public void paintComponent(Graphics g)\n    {\n      Graphics2D g2 = (Graphics2D) g;\n      BasicStroke penStroke = new BasicStroke(this.width);\n      g2.setStroke(penStroke);\n      g2.setColor(this.color);\n      g2.draw(this.line);\n    }\n\n  } // end of class\n  import java.awt.*;\n  import java.awt.geom.*;\n  import javax.swing.*;\n  import java.util.List;\n  import java.util.ArrayList;\n  import java.util.Iterator;\n\n  /**\n   * Class to represent a pen which has a color, width,\n   * and a list of path segments that it should draw.\n   * A pen also knows if it is up or down\n   *\n   * Copyright Georgia Institute of Technology 2004\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class Pen\n  {\n    ////////////////// fields //////////////////////\n\n    /** track if up or down */\n    private boolean penDown = true;\n\n    /** color of ink */\n    private Color color = Color.green;\n\n    /** width of stroke */\n    private int width = 1;\n\n    /** list of path segment objects to draw */\n    private List&lt;PathSegment&gt; pathSegmentList =\n      new ArrayList&lt;PathSegment&gt;();\n\n    //////////////// constructors ///////////////////\n\n    /**\n     * Constructor that takes no arguments\n     */\n    public Pen() { }\n\n    /**\n     * Constructor that takes all the ink color, and width\n     * @param color the ink color\n     * @param width the width in pixels\n     */\n    public Pen(Color color, int width)\n    {\n      this.color = color;\n      this.width = width;\n    }\n\n    /**\n     * Constructor that takes the ink color, width, and penDown flag\n     * @param color the ink color\n     * @param width the width in pixels\n     * @param penDown the flag if the pen is down\n     */\n    public Pen(Color color, int width, boolean penDown)\n    {\n      // use the other constructor to set these\n      this(color,width);\n\n      // set the pen down flag\n      this.penDown = penDown;\n    }\n\n    ////////////////// methods ///////////////////////\n\n    /**\n     * Method to get pen down status\n     * @return true if the pen is down else false\n     */\n    public boolean isPenDown() { return penDown; }\n\n    /**\n     * Method to set the pen down value\n     * @param value the new value to use\n     */\n    public void setPenDown(boolean value) { penDown = value; }\n\n    /**\n     * Method to get the pen (ink) color\n     * @return the ink color\n     */\n    public Color getColor() { return color; }\n\n    /**\n     * Method to set the pen (ink) color\n     * @param color the color to use\n     */\n    public void setColor(Color color) { this.color = color;}\n\n    /**\n     * Method to get the width of the pen\n     * @return the width in pixels\n     */\n    public int getWidth() { return width; }\n\n    /**\n     * Method to set the width of the pen\n     * @param width the width to use in pixels\n     */\n    public void setWidth(int width) { this.width = width; }\n\n    /**\n     * Method to add a path segment if the pen is down\n     * @param x1 the first x\n     * @param y1 the first y\n     * @param x2 the second x\n     * @param y2 the second y\n     */\n    public synchronized void addMove(int x1, int y1, int x2, int y2)\n    {\n      if (penDown)\n      {\n        PathSegment pathSeg =\n          new PathSegment(this.color,this.width,\n                          new Line2D.Float(x1,y1,x2,y2));\n        pathSegmentList.add(pathSeg);\n      }\n    }\n\n    /**\n     * Method to clear the path stored for this pen\n     */\n    public void clearPath()\n    {\n      pathSegmentList.clear();\n    }\n\n    /**\n     * Metod to paint the pen path\n     * @param g the graphics context\n     */\n    public synchronized void paintComponent(Graphics g)\n    {\n\n      Color oldcolor = g.getColor();\n\n      // loop through path segment list and\n      Iterator iterator = pathSegmentList.iterator();\n      PathSegment pathSeg = null;\n\n      // loop through path segments\n      while (iterator.hasNext())\n      {\n        pathSeg = (PathSegment) iterator.next();\n        pathSeg.paintComponent(g);\n      }\n\n      g.setColor(oldcolor);\n    }\n\n  } // end of class\n  import java.awt.*;\n  import java.awt.font.*;\n  import java.awt.geom.*;\n  import java.awt.image.BufferedImage;\n  import java.text.*;\n  import java.util.*;\n  import java.util.List; // resolves problem with java.awt.List and java.util.List\n\n  /**\n   * A class that represents a picture.  This class inherits from\n   * SimplePicture and allows the student to add functionality to\n   * the Picture class.\n   *\n   * @author Barbara Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class Picture extends SimplePicture\n  {\n    ///////////////////// constructors //////////////////////////////////\n\n    /**\n     * Constructor that takes no arguments\n     */\n    public Picture ()\n    {\n      /* not needed but use it to show students the implicit call to super()\n       * child constructors always call a parent constructor\n       */\n      super();\n    }\n\n    /**\n     * Constructor that takes a file name and creates the picture\n     * @param fileName the name of the file to create the picture from\n     */\n    public Picture(String fileName)\n    {\n      // let the parent class handle this fileName\n      super(fileName);\n    }\n\n    /**\n     * Constructor that takes the height and width\n     * @param height the height of the desired picture\n     * @param width the width of the desired picture\n     */\n    public Picture(int width, int height)\n    {\n      // let the parent class handle this width and height\n      super(width,height);\n    }\n\n    /**\n     * Constructor that takes a picture and creates a\n     * copy of that picture\n     * @param copyPicture the picture to copy\n     */\n    public Picture(Picture copyPicture)\n    {\n      // let the parent class do the copy\n      super(copyPicture);\n    }\n\n    /**\n     * Constructor that takes a buffered image\n     * @param image the buffered image to use\n     */\n    public Picture(BufferedImage image)\n    {\n      super(image);\n    }\n\n    ////////////////////// methods ///////////////////////////////////////\n\n    /**\n     * Method to return a string with information about this picture.\n     * @return a string with information about the picture such as fileName,\n     * height and width.\n     */\n    public String toString()\n    {\n      String output = &quot;Picture, filename &quot; + getFileName() +\n        &quot; height &quot; + getHeight()\n        + &quot; width &quot; + getWidth();\n      return output;\n\n    }\n\n  } // this } is the end of class Picture, put all new methods before this\n\n  import java.awt.Color;\n\n  /**\n   * Class that references a pixel in a picture. Pixel\n   * stands for picture element where picture is\n   * abbreviated pix.  A pixel has a column (x) and\n   * row (y) location in a picture.  A pixel knows how\n   * to get and set the red, green, blue, and alpha\n   * values in the picture.  A pixel also knows how to get\n   * and set the color using a Color object.\n   *\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class Pixel\n  {\n\n    ////////////////////////// fields ///////////////////////////////////\n\n    /** the digital picture this pixel belongs to */\n    private DigitalPicture picture;\n\n    /** the x (column) location of this pixel in the picture; (0,0) is top left */\n    private int x;\n\n    /** the y (row) location of this pixel in the picture; (0,0) is top left */\n    private int y;\n\n    ////////////////////// constructors /////////////////////////////////\n\n    /**\n     * A constructor that takes the x and y location for the pixel and\n     * the picture the pixel is coming from\n     * @param picture the picture that the pixel is in\n     * @param x the x location of the pixel in the picture\n     * @param y the y location of the pixel in the picture\n     */\n    public Pixel(DigitalPicture picture, int x, int y)\n    {\n      // set the picture\n      this.picture = picture;\n\n      // set the x location\n      this.x = x;\n\n      // set the y location\n      this.y = y;\n\n    }\n\n    ///////////////////////// methods //////////////////////////////\n\n    /**\n     * Method to get the x location of this pixel.\n     * @return the x location of the pixel in the picture\n     */\n    public int getX() { return x; }\n\n    /**\n     * Method to get the y location of this pixel.\n     * @return the y location of the pixel in the picture\n     */\n    public int getY() { return y; }\n\n    /**\n     * Method to get the row (y value)\n     * @return the row (y value) of the pixel in the picture\n     */\n    public int getRow() { return y; }\n\n    /**\n     * Method to get the column (x value)\n     * @return the column (x value) of the pixel\n     */\n    public int getCol() { return x; }\n\n    /**\n     * Method to get the amount of alpha (transparency) at this pixel.\n     * It will be from 0-255.\n     * @return the amount of alpha (transparency)\n     */\n    public int getAlpha() {\n\n      /* get the value at the location from the picture as a 32 bit int\n       * with alpha, red, green, blue each taking 8 bits from left to right\n       */\n      int value = picture.getBasicPixel(x,y);\n\n      // get the alpha value (starts at 25 so shift right 24)\n      // then and it with all 1\'s for the first 8 bits to keep\n      // end up with from 0 to 255\n      int alpha = (value &gt;&gt; 24) &amp; 0xff;\n\n      return alpha;\n    }\n\n    /**\n     * Method to get the amount of red at this pixel.  It will be\n     * from 0-255 with 0 being no red and 255 being as much red as\n     * you can have.\n     * @return the amount of red from 0 for none to 255 for max\n     */\n    public int getRed() {\n\n      /* get the value at the location from the picture as a 32 bit int\n       * with alpha, red, green, blue each taking 8 bits from left to right\n       */\n      int value = picture.getBasicPixel(x,y);\n\n      // get the red value (starts at 17 so shift right 16)\n      // then AND it with all 1\'s for the first 8 bits to\n      // end up with a resulting value from 0 to 255\n      int red = (value &gt;&gt; 16) &amp; 0xff;\n\n      return red;\n    }\n\n    /**\n     * Method to get the red value from a pixel represented as an int\n     * @param value the color value as an int\n     * @return the amount of red\n     */\n    public static int getRed(int value)\n    {\n      int red = (value &gt;&gt; 16) &amp; 0xff;\n      return red;\n    }\n\n    /**\n     * Method to get the amount of green at this pixel.  It will be\n     * from 0-255 with 0 being no green and 255 being as much green as\n     * you can have.\n     * @return the amount of green from 0 for none to 255 for max\n     */\n    public int getGreen() {\n\n      /* get the value at the location from the picture as a 32 bit int\n       * with alpha, red, green, blue each taking 8 bits from left to right\n       */\n      int value = picture.getBasicPixel(x,y);\n\n      // get the green value (starts at 9 so shift right 8)\n      int green = (value &gt;&gt;  8) &amp; 0xff;\n\n      return green;\n    }\n\n    /**\n     * Method to get the green value from a pixel represented as an int\n     * @param value the color value as an int\n     * @return the amount of green\n     */\n    public static int getGreen(int value)\n    {\n      int green = (value &gt;&gt; 8) &amp; 0xff;\n      return green;\n    }\n\n    /**\n     * Method to get the amount of blue at this pixel.  It will be\n     * from 0-255 with 0 being no blue and 255 being as much blue as\n     * you can have.\n     * @return the amount of blue from 0 for none to 255 for max\n     */\n    public int getBlue() {\n\n      /* get the value at the location from the picture as a 32 bit int\n       * with alpha, red, green, blue each taking 8 bits from left to right\n       */\n      int value = picture.getBasicPixel(x,y);\n\n      // get the blue value (starts at 0 so no shift required)\n      int blue = value &amp; 0xff;\n\n      return blue;\n    }\n\n    /**\n     * Method to get the blue value from a pixel represented as an int\n     * @param value the color value as an int\n     * @return the amount of blue\n     */\n    public static int getBlue(int value)\n    {\n      int blue = value &amp; 0xff;\n      return blue;\n    }\n\n    /**\n     * Method to get a color object that represents the color at this pixel.\n     * @return a color object that represents the pixel color\n     */\n    public Color getColor()\n    {\n       /* get the value at the location from the picture as a 32 bit int\n       * with alpha, red, green, blue each taking 8 bits from left to right\n       */\n      int value = picture.getBasicPixel(x,y);\n\n      // get the red value (starts at 17 so shift right 16)\n      // then AND it with all 1\'s for the first 8 bits to\n      // end up with a resulting value from 0 to 255\n      int red = (value &gt;&gt; 16) &amp; 0xff;\n\n      // get the green value (starts at 9 so shift right 8)\n      int green = (value &gt;&gt;  8) &amp; 0xff;\n\n      // get the blue value (starts at 0 so no shift required)\n      int blue = value &amp; 0xff;\n\n      return new Color(red,green,blue);\n    }\n\n    /**\n     * Method to set the pixel color to the passed in color object.\n     * @param newColor the new color to use\n     */\n    public void setColor(Color newColor)\n    {\n      // set the red, green, and blue values\n      int red = newColor.getRed();\n      int green = newColor.getGreen();\n      int blue = newColor.getBlue();\n\n      // update the associated picture\n      updatePicture(this.getAlpha(),red,green,blue);\n    }\n\n    /**\n     * Method to update the picture based on the passed color\n     * values for this pixel\n     * @param alpha the alpha (transparency) at this pixel\n     * @param red the red value for the color at this pixel\n     * @param green the green value for the color at this pixel\n     * @param blue the blue value for the color at this pixel\n     */\n    public void updatePicture(int alpha, int red, int green, int blue)\n    {\n      // create a 32 bit int with alpha, red, green blue from left to right\n      int value = (alpha &lt;&lt; 24) + (red &lt;&lt; 16) + (green &lt;&lt; 8) + blue;\n\n      // update the picture with the int value\n      picture.setBasicPixel(x,y,value);\n    }\n\n    /**\n     * Method to correct a color value to be within 0 to 255\n     * @param the value to use\n     * @return a value within 0 to 255\n     */\n    private static int correctValue(int value)\n    {\n      if (value &lt; 0)\n        value = 0;\n      if (value &gt; 255)\n        value = 255;\n      return value;\n    }\n\n    /**\n     * Method to set the red to a new red value\n     * @param value the new value to use\n     */\n    public void setRed(int value)\n    {\n      // set the red value to the corrected value\n      int red = correctValue(value);\n\n      // update the pixel value in the picture\n      updatePicture(getAlpha(), red, getGreen(), getBlue());\n    }\n\n    /**\n     * Method to set the green to a new green value\n     * @param value the value to use\n     */\n    public void setGreen(int value)\n    {\n      // set the green value to the corrected value\n      int green = correctValue(value);\n\n      // update the pixel value in the picture\n      updatePicture(getAlpha(), getRed(), green, getBlue());\n    }\n\n    /**\n     * Method to set the blue to a new blue value\n     * @param value the new value to use\n     */\n    public void setBlue(int value)\n    {\n      // set the blue value to the corrected value\n      int blue = correctValue(value);\n\n      // update the pixel value in the picture\n      updatePicture(getAlpha(), getRed(), getGreen(), blue);\n    }\n\n     /**\n     * Method to set the alpha (transparency) to a new alpha value\n     * @param value the new value to use\n     */\n    public void setAlpha(int value)\n    {\n      // make sure that the alpha is from 0 to 255\n      int alpha = correctValue(value);\n\n      // update the associated picture\n      updatePicture(alpha, getRed(), getGreen(), getBlue());\n    }\n\n    /**\n    * Method to get the distance between this pixel\'s color and the passed color\n    * @param testColor the color to compare to\n    * @return the distance between this pixel\'s color and the passed color\n    */\n   public double colorDistance(Color testColor)\n   {\n     double redDistance = this.getRed() - testColor.getRed();\n     double greenDistance = this.getGreen() - testColor.getGreen();\n     double blueDistance = this.getBlue() - testColor.getBlue();\n     double distance = Math.sqrt(redDistance * redDistance +\n                                 greenDistance * greenDistance +\n                                 blueDistance * blueDistance);\n     return distance;\n   }\n\n   /**\n    * Method to compute the color distances between two color objects\n    * @param color1 a color object\n    * @param color2 a color object\n    * @return the distance between the two colors\n    */\n   public static double colorDistance(Color color1,Color color2)\n   {\n     double redDistance = color1.getRed() - color2.getRed();\n     double greenDistance = color1.getGreen() - color2.getGreen();\n     double blueDistance = color1.getBlue() - color2.getBlue();\n     double distance = Math.sqrt(redDistance * redDistance +\n                                 greenDistance * greenDistance +\n                                 blueDistance * blueDistance);\n     return distance;\n   }\n\n   /**\n    * Method to get the average of the colors of this pixel\n    * @return the average of the red, green, and blue values\n    */\n   public double getAverage()\n   {\n     double average = (getRed() + getGreen() + getBlue()) / 3.0;\n     return average;\n   }\n\n    /**\n     * Method to return a string with information about this pixel\n     * @return a string with information about this pixel\n     */\n    public String toString()\n    {\n      return &quot;Pixel row=&quot; + getRow() +\n        &quot; col=&quot; + getCol() +\n        &quot; red=&quot; + getRed() +\n        &quot; green=&quot; + getGreen() +\n        &quot; blue=&quot; + getBlue();\n    }\n\n  }\n  import javax.imageio.ImageIO;\n  import java.awt.image.BufferedImage;\n  import javax.swing.ImageIcon;\n  import java.awt.*;\n  import java.io.*;\n  import java.awt.geom.*;\n\n  import java.io.ByteArrayOutputStream;\n  // import javax.xml.bind.DatatypeConverter;\n  // Using java.util.Base64 instead of javax.xml.bind\n  import java.util.Base64;\n  import java.util.Scanner;\n\n  /**\n   * A class that represents a simple picture.  A simple picture may have\n   * an associated file name and a title.  A simple picture has pixels,\n   * width, and height.  A simple picture uses a BufferedImage to\n   * hold the pixels. You can also explore a simple picture.\n   *\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class SimplePicture implements DigitalPicture\n  {\n\n    /////////////////////// Fields /////////////////////////\n\n    /**\n     * the file name associated with the simple picture\n     */\n    private String fileName;\n\n    /**\n     * the path name for the file\n     */\n    private String pathName;\n\n    /**\n     * the title of the simple picture\n     */\n    private String title;\n\n    /**\n     * buffered image to hold pixels for the simple picture\n     */\n    private BufferedImage bufferedImage;\n\n    /**\n     * extension for this file (jpg or bmp)\n     */\n    private String extension;\n\n\n   /////////////////////// Constructors /////////////////////////\n\n   /**\n    * A Constructor that takes no arguments.  It creates a picture with\n    * a width of 200 and a height of 100 that is all white.\n    * A no-argument constructor must be given in order for a class to\n    * be able to be subclassed.  By default all subclasses will implicitly\n    * call this in their parent\'s no-argument constructor unless a\n    * different call to super() is explicitly made as the first line\n    * of code in a constructor.\n    */\n   public SimplePicture()\n   {this(200,100);}\n\n   /**\n    * A Constructor that takes a file name and uses the file to create\n    * a picture\n    * @param fileName the file name to use in creating the picture\n    */\n   public SimplePicture(String fileName)\n   {\n\n     // load the picture into the buffered image\n     load(fileName);\n\n   }\n\n   /**\n    * A constructor that takes the width and height desired for a picture and\n    * creates a buffered image of that size.  This constructor doesn\'t\n    * show the picture.  The pixels will all be white.\n    * @param width the desired width\n    * @param height the desired height\n    */\n   public  SimplePicture(int width, int height)\n   {\n     bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n     title = &quot;None&quot;;\n     fileName = &quot;None&quot;;\n     extension = &quot;jpg&quot;;\n     setAllPixelsToAColor(Color.white);\n   }\n\n   /**\n    * A constructor that takes the width and height desired for a picture and\n    * creates a buffered image of that size.  It also takes the\n    * color to use for the background of the picture.\n    * @param width the desired width\n    * @param height the desired height\n    * @param theColor the background color for the picture\n    */\n   public  SimplePicture(int width, int height, Color theColor)\n   {\n     this(width,height);\n     setAllPixelsToAColor(theColor);\n   }\n\n   /**\n    * A Constructor that takes a picture to copy information from\n    * @param copyPicture the picture to copy from\n    */\n   public SimplePicture(SimplePicture copyPicture)\n   {\n     if (copyPicture.fileName != null)\n     {\n        this.fileName = new String(copyPicture.fileName);\n        this.extension = copyPicture.extension;\n     }\n     if (copyPicture.title != null)\n        this.title = new String(copyPicture.title);\n     if (copyPicture.bufferedImage != null)\n     {\n       this.bufferedImage = new BufferedImage(copyPicture.getWidth(),\n                                              copyPicture.getHeight(), BufferedImage.TYPE_INT_RGB);\n       this.copyPicture(copyPicture);\n     }\n   }\n\n   /**\n    * A constructor that takes a buffered image\n    * @param image the buffered image\n    */\n   public SimplePicture(BufferedImage image)\n   {\n     this.bufferedImage = image;\n     title = &quot;None&quot;;\n     fileName = &quot;None&quot;;\n     extension = &quot;jpg&quot;;\n   }\n\n   ////////////////////////// Methods //////////////////////////////////\n\n   /**\n    * Method to get the extension for this picture\n    * @return the extension (jpg, bmp, giff, etc)\n    */\n   public String getExtension() { return extension; }\n\n   /**\n    * Method that will copy all of the passed source picture into\n    * the current picture object\n    * @param sourcePicture  the picture object to copy\n    */\n   public void copyPicture(SimplePicture sourcePicture)\n   {\n     Pixel sourcePixel = null;\n     Pixel targetPixel = null;\n\n     // loop through the columns\n     for (int sourceX = 0, targetX = 0;\n          sourceX &lt; sourcePicture.getWidth() &amp;&amp;\n          targetX &lt; this.getWidth();\n          sourceX++, targetX++)\n     {\n       // loop through the rows\n       for (int sourceY = 0, targetY = 0;\n            sourceY &lt; sourcePicture.getHeight() &amp;&amp;\n            targetY &lt; this.getHeight();\n            sourceY++, targetY++)\n       {\n         sourcePixel = sourcePicture.getPixel(sourceX,sourceY);\n         targetPixel = this.getPixel(targetX,targetY);\n         targetPixel.setColor(sourcePixel.getColor());\n       }\n     }\n\n   }\n\n   /**\n    * Method to set the color in the picture to the passed color\n    * @param color the color to set to\n    */\n   public void setAllPixelsToAColor(Color color)\n   {\n     // loop through all x\n     for (int x = 0; x &lt; this.getWidth(); x++)\n     {\n       // loop through all y\n       for (int y = 0; y &lt; this.getHeight(); y++)\n       {\n         getPixel(x,y).setColor(color);\n       }\n     }\n   }\n\n   /**\n    * Method to get the buffered image\n    * @return the buffered image\n    */\n   public BufferedImage getBufferedImage()\n   {\n      return bufferedImage;\n   }\n\n   /**\n    * Method to get a graphics object for this picture to use to draw on\n    * @return a graphics object to use for drawing\n    */\n   public Graphics getGraphics()\n   {\n     return bufferedImage.getGraphics();\n   }\n\n   /**\n    * Method to get a Graphics2D object for this picture which can\n    * be used to do 2D drawing on the picture\n    */\n   public Graphics2D createGraphics()\n   {\n     return bufferedImage.createGraphics();\n   }\n\n   /**\n    * Method to get the file name associated with the picture\n    * @return  the file name associated with the picture\n    */\n   public String getFileName() { return fileName; }\n\n   /**\n    * Method to set the file name\n    * @param name the full pathname of the file\n    */\n   public void setFileName(String name)\n   {\n     fileName = name;\n   }\n\n   /**\n    * Method to get the title of the picture\n    * @return the title of the picture\n    */\n   public String getTitle()\n   { return title; }\n\n   /**\n    * Method to set the title for the picture\n    * @param title the title to use for the picture\n    */\n   public void setTitle(String title)\n   {\n     this.title = title;\n   }\n\n   /**\n    * Method to get the width of the picture in pixels\n    * @return the width of the picture in pixels\n    */\n   public int getWidth() { return bufferedImage.getWidth(); }\n\n   /**\n    * Method to get the height of the picture in pixels\n    * @return  the height of the picture in pixels\n    */\n   public int getHeight() { return bufferedImage.getHeight(); }\n\n   /**\n    * Method to get an image from the picture\n    * @return  the buffered image since it is an image\n    */\n   public Image getImage()\n   {\n     return bufferedImage;\n   }\n\n   /**\n    * Method to return the pixel value as an int for the given x and y location\n    * @param x the x coordinate of the pixel\n    * @param y the y coordinate of the pixel\n    * @return the pixel value as an integer (alpha, red, green, blue)\n    */\n   public int getBasicPixel(int x, int y)\n   {\n      return bufferedImage.getRGB(x,y);\n   }\n\n   /**\n    * Method to set the value of a pixel in the picture from an int\n    * @param x the x coordinate of the pixel\n    * @param y the y coordinate of the pixel\n    * @param rgb the new rgb value of the pixel (alpha, red, green, blue)\n    */\n   public void setBasicPixel(int x, int y, int rgb)\n   {\n     bufferedImage.setRGB(x,y,rgb);\n   }\n\n   /**\n    * Method to get a pixel object for the given x and y location\n    * @param x  the x location of the pixel in the picture\n    * @param y  the y location of the pixel in the picture\n    * @return a Pixel object for this location\n    */\n   public Pixel getPixel(int x, int y)\n   {\n     // create the pixel object for this picture and the given x and y location\n     Pixel pixel = new Pixel(this,x,y);\n     return pixel;\n   }\n\n   /**\n    * Method to get a one-dimensional array of Pixels for this simple picture\n    * @return a one-dimensional array of Pixel objects starting with y=0\n    * to y=height-1 and x=0 to x=width-1.\n    */\n   public Pixel[] getPixels()\n   {\n     int width = getWidth();\n     int height = getHeight();\n     Pixel[] pixelArray = new Pixel[width * height];\n\n     // loop through height rows from top to bottom\n     for (int row = 0; row &lt; height; row++)\n       for (int col = 0; col &lt; width; col++)\n         pixelArray[row * width + col] = new Pixel(this,col,row);\n\n     return pixelArray;\n   }\n\n   /**\n    * Method to get a two-dimensional array of Pixels for this simple picture\n    * @return a two-dimensional array of Pixel objects in row-major order.\n    */\n   public Pixel[][] getPixels2D()\n   {\n     int width = getWidth();\n     int height = getHeight();\n     Pixel[][] pixelArray = new Pixel[height][width];\n\n     // loop through height rows from top to bottom\n     for (int row = 0; row &lt; height; row++)\n       for (int col = 0; col &lt; width; col++)\n         pixelArray[row][col] = new Pixel(this,col,row);\n\n     return pixelArray;\n   }\n\n   /**\n    * Method to load the buffered image with the passed image\n    * @param image  the image to use\n    */\n   public void load(Image image)\n   {\n     // get a graphics context to use to draw on the buffered image\n     Graphics2D graphics2d = bufferedImage.createGraphics();\n\n     // draw the image on the buffered image starting at 0,0\n     graphics2d.drawImage(image,0,0,null);\n\n     // show the new image\n     show();\n   }\n\n   /**\n    * Method to show the picture in a picture frame\n    */\n   public void show()\n   {\n       try {\n           ByteArrayOutputStream output = new ByteArrayOutputStream();\n           ImageIO.write(this.bufferedImage, &quot;png&quot;, output);\n           String result =\n           // DatatypeConverter.printBase64Binary(output.toByteArray());\n           // using java.util.Base64 instead of java.xml.bind.DataTypeConverter\n           Base64.getEncoder().encodeToString(output.toByteArray());\n           System.out.println(&quot;&amp;lt;img src=\\\'data:image/&quot; + this.extension + &quot;;base64,&quot; + result + &quot;\\\'/&gt;&quot;);\n       } catch (IOException e) {\n           System.out.println(&quot;Errors occured in image conversion&quot;);\n       }\n   }\n\n   /**\n    * Method to load the picture from the passed file name\n    * @param fileName the file name to use to load the picture from\n    * @throws IOException if the picture isn\'t found\n    */\n   public void loadOrFail(String fileName) throws IOException\n   {\n      // set the current picture\'s file name\n     this.fileName = fileName;\n\n     // set the extension\n     int posDot = fileName.lastIndexOf(\'.\');\n     if (posDot &gt;= 0)\n       this.extension = fileName.substring(posDot + 1);\n\n      //get file location\n      String[] paths = fileName.split(&quot;/&quot;);\n      this.pathName = &quot;&quot;;\n      if(paths.length != 1) {\n          for(int i = 0; i &lt; paths.length - 1; i++) {\n              this.pathName = this.pathName + paths[i] + &quot;/&quot;;\n          }\n      }\n     // if the current title is null use the file name\n     if (title == null)\n       title = fileName;\n\n     File file = new File(this.fileName);\n\n     if (!file.canRead())\n     {\n       throw new IOException(this.fileName +\n                           &quot; could not be opened. Check that you specified the path&quot;);\n     }\n     bufferedImage = ImageIO.read(file);\n\n\n   }\n\n\n   /**\n    * Method to read the contents of the picture from a filename\n    * without throwing errors\n    * @param fileName the name of the file to write the picture to\n    * @return true if success else false\n    */\n   public boolean load(String fileName)\n   {\n       try {\n           this.loadOrFail(fileName);\n           return true;\n\n       } catch (Exception ex) {\n           System.out.println(&quot;There was an error trying to open &quot; + fileName);\n           bufferedImage = new BufferedImage(600,200,\n                                             BufferedImage.TYPE_INT_RGB);\n           addMessage(&quot;Couldn\'t load &quot; + fileName,5,100);\n           return false;\n       }\n\n   }\n\n   /**\n    * Method to load the picture from the passed file name\n    * this just calls load(fileName) and is for name compatibility\n    * @param fileName the file name to use to load the picture from\n    * @return true if success else false\n    */\n   public boolean loadImage(String fileName)\n   {\n       return load(fileName);\n   }\n\n   /**\n    * Method to draw a message as a string on the buffered image\n    * @param message the message to draw on the buffered image\n    * @param xPos  the x coordinate of the leftmost point of the string\n    * @param yPos  the y coordinate of the bottom of the string\n    */\n   public void addMessage(String message, int xPos, int yPos)\n   {\n     // get a graphics context to use to draw on the buffered image\n     Graphics2D graphics2d = bufferedImage.createGraphics();\n\n     // set the color to white\n     graphics2d.setPaint(Color.white);\n\n     // set the font to Helvetica bold style and size 16\n     graphics2d.setFont(new Font(&quot;Helvetica&quot;,Font.BOLD,16));\n\n     // draw the message\n     graphics2d.drawString(message,xPos,yPos);\n\n   }\n\n   /**\n    * Method to draw a string at the given location on the picture\n    * @param text the text to draw\n    * @param xPos the left x for the text\n    * @param yPos the top y for the text\n    */\n   public void drawString(String text, int xPos, int yPos)\n   {\n     addMessage(text,xPos,yPos);\n   }\n\n   /**\n     * Method to create a new picture by scaling the current\n     * picture by the given x and y factors\n     * @param xFactor the amount to scale in x\n     * @param yFactor the amount to scale in y\n     * @return the resulting picture\n     */\n    public Picture scale(double xFactor, double yFactor)\n    {\n      // set up the scale transform\n      AffineTransform scaleTransform = new AffineTransform();\n      scaleTransform.scale(xFactor,yFactor);\n\n      // create a new picture object that is the right size\n      Picture result = new Picture((int) (getHeight() * yFactor),\n                                   (int) (getWidth() * xFactor));\n\n      // get the graphics 2d object to draw on the result\n      Graphics graphics = result.getGraphics();\n      Graphics2D g2 = (Graphics2D) graphics;\n\n      // draw the current image onto the result image scaled\n      g2.drawImage(this.getImage(),scaleTransform,null);\n\n      return result;\n    }\n\n    /**\n     * Method to create a new picture of the passed width.\n     * The aspect ratio of the width and height will stay\n     * the same.\n     * @param width the desired width\n     * @return the resulting picture\n     */\n    public Picture getPictureWithWidth(int width)\n    {\n      // set up the scale transform\n      double xFactor = (double) width / this.getWidth();\n      Picture result = scale(xFactor,xFactor);\n      return result;\n    }\n\n    /**\n     * Method to create a new picture of the passed height.\n     * The aspect ratio of the width and height will stay\n     * the same.\n     * @param height the desired height\n     * @return the resulting picture\n     */\n    public Picture getPictureWithHeight(int height)\n    {\n      // set up the scale transform\n      double yFactor = (double) height / this.getHeight();\n      Picture result = scale(yFactor,yFactor);\n      return result;\n    }\n\n   /**\n    * Method to load a picture from a file name and show it in a picture frame\n    * @param fileName the file name to load the picture from\n    * @return true if success else false\n    */\n   public boolean loadPictureAndShowIt(String fileName)\n   {\n     boolean result = true;  // the default is that it worked\n\n     // try to load the picture into the buffered image from the file name\n     result = load(fileName);\n\n     // show the picture in a picture frame\n     show();\n\n     return result;\n   }\n\n   /**\n    * Method to write the contents of the picture to a file with\n    * the passed name\n    * @param fileName the name of the file to write the picture to\n    */\n   public void writeOrFail(String fileName) throws IOException\n   {\n     String extension = this.extension; // the default is current\n\n     // create the file object\n     File file = new File(fileName);\n\n     // get the extension\n     int posDot = fileName.indexOf(\'.\');\n     if (posDot &gt;= 0)\n         extension = fileName.substring(posDot + 1);\n\n     // write the contents of the buffered image to the file\n     ImageIO.write(bufferedImage, extension, file);\n\n   }\n\n   /**\n    * Method to write the contents of the picture to a file with\n    * the passed name without throwing errors\n    * @param fileName the name of the file to write the picture to\n    * @return true if success else false\n    */\n   public boolean write(String fileName)\n   {\n       try {\n           this.writeOrFail(fileName);\n           return true;\n       } catch (Exception ex) {\n           System.out.println(&quot;There was an error trying to write &quot; + fileName);\n           ex.printStackTrace();\n           return false;\n       }\n\n   }\n\n    /**\n     * Method to get the coordinates of the enclosing rectangle after this\n     * transformation is applied to the current picture\n     * @return the enclosing rectangle\n     */\n    public Rectangle2D getTransformEnclosingRect(AffineTransform trans)\n    {\n      int width = getWidth();\n      int height = getHeight();\n      double maxX = width - 1;\n      double maxY = height - 1;\n      double minX, minY;\n      Point2D.Double p1 = new Point2D.Double(0,0);\n      Point2D.Double p2 = new Point2D.Double(maxX,0);\n      Point2D.Double p3 = new Point2D.Double(maxX,maxY);\n      Point2D.Double p4 = new Point2D.Double(0,maxY);\n      Point2D.Double result = new Point2D.Double(0,0);\n      Rectangle2D.Double rect = null;\n\n      // get the new points and min x and y and max x and y\n      trans.deltaTransform(p1,result);\n      minX = result.getX();\n      maxX = result.getX();\n      minY = result.getY();\n      maxY = result.getY();\n      trans.deltaTransform(p2,result);\n      minX = Math.min(minX,result.getX());\n      maxX = Math.max(maxX,result.getX());\n      minY = Math.min(minY,result.getY());\n      maxY = Math.max(maxY,result.getY());\n      trans.deltaTransform(p3,result);\n      minX = Math.min(minX,result.getX());\n      maxX = Math.max(maxX,result.getX());\n      minY = Math.min(minY,result.getY());\n      maxY = Math.max(maxY,result.getY());\n      trans.deltaTransform(p4,result);\n      minX = Math.min(minX,result.getX());\n      maxX = Math.max(maxX,result.getX());\n      minY = Math.min(minY,result.getY());\n      maxY = Math.max(maxY,result.getY());\n\n      // create the bounding rectangle to return\n      rect = new Rectangle2D.Double(minX,minY,maxX - minX + 1, maxY - minY + 1);\n      return rect;\n    }\n\n    /**\n     * Method to get the coordinates of the enclosing rectangle after this\n     * transformation is applied to the current picture\n     * @return the enclosing rectangle\n     */\n    public Rectangle2D getTranslationEnclosingRect(AffineTransform trans)\n    {\n      return getTransformEnclosingRect(trans);\n    }\n\n   /**\n    * Method to return a string with information about this picture\n    * @return a string with information about the picture\n    */\n   public String toString()\n   {\n     String output = &quot;Simple Picture, filename &quot; + fileName +\n       &quot; height &quot; + getHeight() + &quot; width &quot; + getWidth();\n     return output;\n   }\n\n  } // end of SimplePicture class\n  import javax.swing.*;\n  import java.awt.*;\n  import java.awt.font.*;\n  import java.awt.geom.*;\n  import java.util.Observer;\n  import java.util.Random;\n\n  /**\n   * Class that represents a Logo-style turtle.  The turtle\n   * starts off facing north.\n   * A turtle can have a name, has a starting x and y position,\n   * has a heading, has a width, has a height, has a visible\n   * flag, has a body color, can have a shell color, and has a pen.\n   * The turtle will not go beyond the model display or picture\n   * boundaries.\n   *\n   * You can display this turtle in either a picture or in\n   * a class that implements ModelDisplay.\n   *\n   * Copyright Georgia Institute of Technology 2004\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class SimpleTurtle\n  {\n    ///////////////// fields ////////////////////////\n\n    /** count of the number of turtles created */\n    private static int numTurtles = 0;\n\n    /** array of colors to use for the turtles */\n    private static Color[] colorArray = { Color.green, Color.cyan, new Color(204,0,204), Color.gray};\n\n    /** who to notify about changes to this turtle */\n    private ModelDisplay modelDisplay = null;\n\n    /** picture to draw this turtle on */\n    private Picture picture = null;\n\n    /** width of turtle in pixels */\n    private int width = 15;\n\n    /** height of turtle in pixels */\n    private int height = 18;\n\n    /** current location in x (center) */\n    private int xPos = 0;\n\n    /** current location in y (center) */\n    private int yPos = 0;\n\n    /** heading angle */\n    private double heading = 0;  // default is facing north\n\n    /** pen to use for this turtle */\n    private Pen pen = new Pen();\n\n    /** color to draw the body in */\n    private Color bodyColor = null;\n\n    /** color to draw the shell in */\n    private Color shellColor = null;\n\n    /** color of information string */\n    private Color infoColor = Color.black;\n\n    /** flag to say if this turtle is visible */\n    private boolean visible = true;\n\n    /** flag to say if should show turtle info */\n    private boolean showInfo = false;\n\n    /** the name of this turtle */\n    private String name = &quot;No name&quot;;\n\n    ////////////////// constructors ///////////////////\n\n    /**\n     * Constructor that takes the x and y position for the\n     * turtle\n     * @param x the x pos\n     * @param y the y pos\n     */\n    public SimpleTurtle(int x, int y)\n    {\n      xPos = x;\n      yPos = y;\n      bodyColor = colorArray[numTurtles % colorArray.length];\n      setPenColor(bodyColor);\n      numTurtles++;\n    }\n\n    /**\n     * Constructor that takes the x and y position and the\n     * model displayer\n     * @param x the x pos\n     * @param y the y pos\n     * @param display the model display\n     */\n    public SimpleTurtle(int x, int y, ModelDisplay display)\n    {\n      this(x,y); // invoke constructor that takes x and y\n      modelDisplay = display;\n      display.addModel(this);\n    }\n\n    /**\n     * Constructor that takes a model display and adds\n     * a turtle in the middle of it\n     * @param display the model display\n     */\n    public SimpleTurtle(ModelDisplay display)\n    {\n      // invoke constructor that takes x and y\n      this((int) (display.getWidth() / 2),\n           (int) (display.getHeight() / 2));\n      modelDisplay = display;\n      display.addModel(this);\n\n    }\n\n    /**\n     * Constructor that takes the x and y position and the\n     * picture to draw on\n     * @param x the x pos\n     * @param y the y pos\n     * @param picture the picture to draw on\n     */\n    public SimpleTurtle(int x, int y, Picture picture)\n    {\n      this(x,y); // invoke constructor that takes x and y\n      this.picture = picture;\n      this.visible = false; // default is not to see the turtle\n    }\n\n    /**\n     * Constructor that takes the\n     * picture to draw on and will appear in the middle\n     * @param picture the picture to draw on\n     */\n    public SimpleTurtle(Picture picture)\n    {\n      // invoke constructor that takes x and y\n      this((int) (picture.getWidth() / 2),\n           (int) (picture.getHeight() / 2));\n      this.picture = picture;\n      this.visible = false; // default is not to see the turtle\n    }\n\n    //////////////////// methods /////////////////////////\n\n    /**\n     * Get the distance from the passed x and y location\n     * @param x the x location\n     * @param y the y location\n     */\n    public double getDistance(int x, int y)\n    {\n      int xDiff = x - xPos;\n      int yDiff = y - yPos;\n      return (Math.sqrt((xDiff * xDiff) + (yDiff * yDiff)));\n    }\n\n    /**\n     * Method to turn to face another simple turtle\n     */\n    public void turnToFace(SimpleTurtle turtle)\n    {\n      turnToFace(turtle.xPos,turtle.yPos);\n    }\n\n     /**\n     * Method to turn towards the given x and y\n     * @param x the x to turn towards\n     * @param y the y to turn towards\n     */\n    public void turnToFace(int x, int y)\n    {\n      double dx = x - this.xPos;\n      double dy = y - this.yPos;\n      double arcTan = 0.0;\n      double angle = 0.0;\n\n      // avoid a divide by 0\n      if (dx == 0)\n      {\n        // if below the current turtle\n        if (dy &gt; 0)\n          heading = 180;\n\n        // if above the current turtle\n        else if (dy &lt; 0)\n          heading = 0;\n      }\n      // dx isn\'t 0 so can divide by it\n      else\n      {\n        arcTan = Math.toDegrees(Math.atan(dy / dx));\n        if (dx &lt; 0)\n          heading = arcTan - 90;\n        else\n          heading = arcTan + 90;\n      }\n\n      // notify the display that we need to repaint\n      updateDisplay();\n    }\n\n    /**\n     * Method to get the picture for this simple turtle\n     * @return the picture for this turtle (may be null)\n     */\n    public Picture getPicture() { return this.picture; }\n\n    /**\n     * Method to set the picture for this simple turtle\n     * @param pict the picture to use\n     */\n    public void setPicture(Picture pict) { this.picture = pict; }\n\n    /**\n     * Method to set the speed of animation by setting the delay to between 0-100.\n     * 50 is the default. We pass this to the World\'s setSpeed method.\n     * @param d\n     */\n    public void setSpeed(int d) {\n       ((World)modelDisplay).setSpeed(d);\n    }\n\n    /**\n     * Method to get the model display for this simple turtle\n     * @return the model display if there is one else null\n     */\n    public ModelDisplay getModelDisplay() { return this.modelDisplay; }\n\n    /**\n     * Method to set the model display for this simple turtle\n     * @param theModelDisplay the model display to use\n     */\n    public void setModelDisplay(ModelDisplay theModelDisplay)\n    { this.modelDisplay = theModelDisplay; }\n\n    /**\n     * Method to get value of show info\n     * @return true if should show info, else false\n     */\n    public boolean getShowInfo() { return this.showInfo; }\n\n    /**\n     * Method to show the turtle information string\n     * @param value the value to set showInfo to\n     */\n    public void setShowInfo(boolean value) { this.showInfo = value; }\n\n    /**\n     * Method to get the shell color\n     * @return the shell color\n     */\n    public Color getShellColor()\n    {\n      Color color = null;\n      if (this.shellColor == null &amp;&amp; this.bodyColor != null)\n        color = bodyColor.darker();\n      else color = this.shellColor;\n      return color;\n    }\n\n    /**\n     * Method to set the shell color\n     * @param color the color to use\n     */\n    public void setShellColor(Color color) {  this.shellColor = color; }\n\n    /**\n     * Method to get the body color\n     * @return the body color\n     */\n    public Color getBodyColor() { return this.bodyColor; }\n\n    /**\n     * Method to set the body color which\n     * will also set the pen color\n     * @param color the color to use\n     */\n    public void setBodyColor(Color color)\n    {\n      this.bodyColor = color;\n      setPenColor(this.bodyColor);\n    }\n\n    /**\n     * Method to set the color of the turtle.\n     * This will set the body color\n     * @param color the color to use\n     */\n    public void setColor(Color color) { this.setBodyColor(color); }\n\n    /**\n     * Method to get the information color\n     * @return the color of the information string\n     */\n    public Color getInfoColor() { return this.infoColor; }\n\n    /**\n     * Method to set the information color\n     * @param color the new color to use\n     */\n    public void setInfoColor(Color color) { this.infoColor = color; }\n\n    /**\n     * Method to return the width of this object\n     * @return the width in pixels\n     */\n    public int getWidth() { return this.width; }\n\n    /**\n     * Method to return the height of this object\n     * @return the height in pixels\n     */\n    public int getHeight() { return this.height; }\n\n    /**\n     * Method to set the width of this object\n     * @param theWidth in width in pixels\n     */\n    public void setWidth(int theWidth) { this.width = theWidth; }\n\n    /**\n     * Method to set the height of this object\n     * @param theHeight the height in pixels\n     */\n    public void setHeight(int theHeight) { this.height = theHeight; }\n\n    /**\n     * Method to get the current x position\n     * @return the x position (in pixels)\n     */\n    public int getXPos() { return this.xPos; }\n\n    /**\n     * Method to get the current y position\n     * @return the y position (in pixels)\n     */\n    public int getYPos() { return this.yPos; }\n\n    /**\n     * Method to get the pen\n     * @return the pen\n     */\n    public Pen getPen() { return this.pen; }\n\n    /**\n     * Method to set the pen\n     * @param thePen the new pen to use\n     */\n    public void setPen(Pen thePen) { this.pen = thePen; }\n\n    /**\n     * Method to check if the pen is down\n     * @return true if down else false\n     */\n    public boolean isPenDown() { return this.pen.isPenDown(); }\n\n    /**\n     * Method to set the pen down boolean variable\n     * @param value the value to set it to\n     */\n    public void setPenDown(boolean value) { this.pen.setPenDown(value); }\n\n    /**\n     * Method to lift the pen up\n     */\n    public void penUp() { this.pen.setPenDown(false);}\n\n    /**\n     * Method to set the pen down\n     */\n    public void penDown() { this.pen.setPenDown(true);}\n\n    /**\n     * Method to get the pen color\n     * @return the pen color\n     */\n    public Color getPenColor() { return this.pen.getColor(); }\n\n    /**\n     * Method to set the pen color\n     * @param color the color for the pen ink\n     */\n    public void setPenColor(Color color) { this.pen.setColor(color); }\n\n    /**\n     * Method to set the pen width\n     * @param width the width to use in pixels\n     */\n    public void setPenWidth(int width) { this.pen.setWidth(width); }\n\n    /**\n     * Method to get the pen width\n     * @return the width of the pen in pixels\n     */\n    public int getPenWidth() { return this.pen.getWidth(); }\n\n    /**\n     * Method to clear the path (history of\n     * where the turtle has been)\n     */\n    public void clearPath()\n    {\n      this.pen.clearPath();\n    }\n\n    /**\n     * Method to get the current heading\n     * @return the heading in degrees\n     */\n    public double getHeading() { return this.heading; }\n\n    /**\n     * Method to set the heading\n     * @param heading the new heading to use\n     */\n    public void setHeading(double heading)\n    {\n      this.heading = heading;\n    }\n\n    /**\n     * Method to get the name of the turtle\n     * @return the name of this turtle\n     */\n    public String getName() { return this.name; }\n\n    /**\n     * Method to set the name of the turtle\n     * @param theName the new name to use\n     */\n    public void setName(String theName)\n    {\n      this.name = theName;\n    }\n\n    /**\n     * Method to get the value of the visible flag\n     * @return true if visible else false\n     */\n    public boolean isVisible() { return this.visible;}\n\n    /**\n     * Method to hide the turtle (stop showing it)\n     * This doesn\'t affect the pen status\n     */\n    public void hide() { this.setVisible(false); }\n\n    /**\n     * Method to show the turtle (doesn\'t affect\n     * the pen status\n     */\n    public void show() { this.setVisible(true); }\n\n    /**\n     * Method to set the visible flag\n     * @param value the value to set it to\n     */\n    public void setVisible(boolean value)\n    {\n      // if the turtle wasn\'t visible and now is\n      if (visible == false &amp;&amp; value == true)\n      {\n        // update the display\n        this.updateDisplay();\n      }\n\n      // set the visibile flag to the passed value\n      this.visible = value;\n    }\n\n    /**\n     * Method to update the display of this turtle and\n     * also check that the turtle is in the bounds\n     */\n    public synchronized void updateDisplay()\n    {\n      // check that x and y are at least 0\n      if (xPos &lt; 0)\n        xPos = 0;\n      if (yPos &lt; 0)\n        yPos = 0;\n\n      // if picture\n      if (picture != null)\n      {\n        if (xPos &gt;= picture.getWidth())\n          xPos = picture.getWidth() - 1;\n        if (yPos &gt;= picture.getHeight())\n          yPos = picture.getHeight() - 1;\n        Graphics g = picture.getGraphics();\n        paintComponent(g);\n      }\n      else if (modelDisplay != null)\n      {\n        if (xPos &gt;= modelDisplay.getWidth())\n          xPos = modelDisplay.getWidth() - 1;\n        if (yPos &gt;= modelDisplay.getHeight())\n          yPos = modelDisplay.getHeight() - 1;\n        modelDisplay.modelChanged();\n      }\n    }\n\n    /**\n     * Method to move the turtle foward 100 pixels\n     */\n    public void forward() { forward(100); }\n\n    /**\n     * Method to move the turtle forward the given number of pixels\n     * @param pixels the number of pixels to walk forward in the heading direction\n     */\n    public void forward(int pixels)\n    {\n      int oldX = xPos;\n      int oldY = yPos;\n\n      // change the current position\n      xPos = oldX + (int) (pixels * Math.sin(Math.toRadians(heading)));\n      yPos = oldY + (int) (pixels * -Math.cos(Math.toRadians(heading)));\n\n      // add a move from the old position to the new position to the pen\n      pen.addMove(oldX,oldY,xPos,yPos);\n\n      // update the display to show the new line\n      updateDisplay();\n    }\n\n    /**\n     * Method to go backward by 100 pixels\n     */\n    public void backward()\n    {\n      backward(100);\n    }\n\n    /**\n     * Method to go backward a given number of pixels\n     * @param pixels the number of pixels to walk backward\n     */\n    public void backward(int pixels)\n    {\n      forward(-pixels);\n    }\n\n    /**\n     * Method to move to turtle to the given x and y location\n     * @param x the x value to move to\n     * @param y the y value to move to\n     */\n    public void moveTo(int x, int y)\n    {\n      this.pen.addMove(xPos,yPos,x,y);\n      this.xPos = x;\n      this.yPos = y;\n      this.updateDisplay();\n    }\n\n    /**\n     * Method to turn left\n     */\n    public void turnLeft()\n    {\n     this.turn(-90);\n    }\n\n    /**\n     * Method to turn right\n     */\n    public void turnRight()\n    {\n      this.turn(90);\n    }\n\n    /**\n     * Method to turn the turtle the passed degrees\n     * use negative to turn left and pos to turn right\n     * @param degrees the amount to turn in degrees\n     */\n    public void turn(double degrees)\n    {\n      this.heading = (heading + degrees) % 360;\n      this.updateDisplay();\n    }\n\n    /**\n     * Method to draw a passed picture at the current turtle\n     * location and rotation in a picture or model display\n     * @param dropPicture the picture to drop\n     */\n    public synchronized void drop(Picture dropPicture)\n    {\n      Graphics2D g2 = null;\n\n      // only do this if drawing on a picture\n      if (picture != null)\n        g2 = (Graphics2D) picture.getGraphics();\n      else if (modelDisplay != null)\n        g2 = (Graphics2D) modelDisplay.getGraphics();\n\n      // if g2 isn\'t null\n      if (g2 != null)\n      {\n\n        // save the current tranform\n        AffineTransform oldTransform = g2.getTransform();\n\n        // rotate to turtle heading and translate to xPos and yPos\n        g2.rotate(Math.toRadians(heading),xPos,yPos);\n\n        // draw the passed picture\n        g2.drawImage(dropPicture.getImage(),xPos,yPos,null);\n\n        // reset the tranformation matrix\n        g2.setTransform(oldTransform);\n\n        //  draw the pen\n        pen.paintComponent(g2);\n      }\n    }\n\n    /**\n     * Method to paint the turtle\n     * @param g the graphics context to paint on\n     */\n    public synchronized void paintComponent(Graphics g)\n    {\n      // cast to 2d object\n      Graphics2D g2 = (Graphics2D) g;\n\n      // if the turtle is visible\n      if (visible)\n      {\n        // save the current tranform\n        AffineTransform oldTransform = g2.getTransform();\n\n        // rotate the turtle and translate to xPos and yPos\n        g2.rotate(Math.toRadians(heading),xPos,yPos);\n\n        // determine the half width and height of the shell\n        int halfWidth = (int) (width/2); // of shell\n        int halfHeight = (int) (height/2); // of shell\n        int quarterWidth = (int) (width/4); // of shell\n        int thirdHeight = (int) (height/3); // of shell\n        int thirdWidth = (int) (width/3); // of shell\n\n        // draw the body parts (head)\n        g2.setColor(bodyColor);\n        g2.fillOval(xPos - quarterWidth,\n                    yPos - halfHeight - (int) (height/3),\n                    halfWidth, thirdHeight);\n        g2.fillOval(xPos - (2 * thirdWidth),\n                    yPos - thirdHeight,\n                    thirdWidth,thirdHeight);\n        g2.fillOval(xPos - (int) (1.6 * thirdWidth),\n                    yPos + thirdHeight,\n                    thirdWidth,thirdHeight);\n        g2.fillOval(xPos + (int) (1.3 * thirdWidth),\n                    yPos - thirdHeight,\n                    thirdWidth,thirdHeight);\n        g2.fillOval(xPos + (int) (0.9 * thirdWidth),\n                    yPos + thirdHeight,\n                    thirdWidth,thirdHeight);\n\n\n        // draw the shell\n        g2.setColor(getShellColor());\n        g2.fillOval(xPos - halfWidth,\n                    yPos - halfHeight, width, height);\n\n        // draw the info string if the flag is true\n        if (showInfo)\n          drawInfoString(g2);\n\n        // reset the tranformation matrix\n        g2.setTransform(oldTransform);\n      }\n\n      //  draw the pen\n      pen.paintComponent(g);\n    }\n\n    /**\n     * Method to draw the information string\n     * @param g the graphics context\n     */\n    public synchronized void drawInfoString(Graphics g)\n    {\n      g.setColor(infoColor);\n      g.drawString(this.toString(),xPos + (int) (width/2),yPos);\n    }\n\n    /**\n     * Method to return a string with informaiton\n     * about this turtle\n     * @return a string with information about this object\n     */\n    public String toString()\n    {\n      return this.name + &quot; turtle at &quot; + this.xPos + &quot;, &quot; +\n        this.yPos + &quot; heading &quot; + this.heading + &quot;.&quot;;\n    }\n\n  } // end of class\n  import java.util.*;\n  import java.awt.*;\n\n  /**\n   * Class that represents a turtle which is similar to a Logo turtle.\n   * This class inherts from SimpleTurtle and is for students\n   * to add methods to.\n   *\n   * Copyright Georgia Institute of Technology 2004\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class Turtle extends SimpleTurtle\n  {\n    ////////////////// constructors ///////////////////////\n\n    /** Constructor that takes the x and y and a picture to\n     * draw on\n     * @param x the starting x position\n     * @param y the starting y position\n     * @param picture the picture to draw on\n     */\n    public Turtle (int x, int y, Picture picture)\n    {\n      // let the parent constructor handle it\n      super(x,y,picture);\n    }\n\n    /** Constructor that takes the x and y and a model\n     * display to draw it on\n     * @param x the starting x position\n     * @param y the starting y position\n     * @param modelDisplayer the thing that displays the model\n     */\n    public Turtle (int x, int y,\n                   ModelDisplay modelDisplayer)\n    {\n      // let the parent constructor handle it\n      super(x,y,modelDisplayer);\n    }\n\n    /** Constructor that takes the model display\n     * @param modelDisplay the thing that displays the model\n     */\n    public Turtle (ModelDisplay modelDisplay)\n    {\n      // let the parent constructor handle it\n      super(modelDisplay);\n    }\n\n    /**\n     * Constructor that takes a picture to draw on\n     * @param p the picture to draw on\n     */\n    public Turtle (Picture p)\n    {\n      // let the parent constructor handle it\n      super(p);\n    }\n\n  } // this is the end of class Turtle, put all new methods before this\n  /**\n   * https://github.com/ha-shine/Giffer\n   */\n  import java.awt.Graphics2D;\n  import java.awt.Image;\n  import java.awt.image.BufferedImage;\n  import java.io.File;\n  import java.io.IOException;\n  import java.util.Iterator;\n\n  import javax.imageio.IIOException;\n  import javax.imageio.IIOImage;\n  import javax.imageio.ImageIO;\n  import javax.imageio.ImageTypeSpecifier;\n  import javax.imageio.ImageWriter;\n  import javax.imageio.metadata.IIOInvalidTreeException;\n  import javax.imageio.metadata.IIOMetadata;\n  import javax.imageio.metadata.IIOMetadataNode;\n  import javax.imageio.stream.ImageOutputStream;\n\n  /*\n   * Giffer is a simple java class to make my life easier in creating gif images.\n   *\n   * Usage :\n   * There are two methods for creating gif images\n   * To generate from files, just pass the array of filename Strings to this method\n   * Giffer.generateFromFiles(String[] filenames, String output, int delay, boolean loop)\n   *\n   * Or as an alternative you can use this method which accepts an array of BufferedImage\n   * Giffer.generateFromBI(BufferedImage[] images, String output, int delay, boolean loop)\n   *\n   * output is the name of the output file\n   * delay is time between frames, accepts hundredth of a time. Yeah it\'s weird, blame Oracle\n   * loop is the boolean for whether you want to make the image loopable.\n   */\n\n  public abstract class Giffer {\n\n      // Generate gif from an array of filenames\n      // Make the gif loopable if loop is true\n      // Set the delay for each frame according to the delay (ms)\n      // Use the name given in String output for output file\n      public static void generateFromFiles(String[] filenames, String output, int delay, boolean loop)\n          throws IIOException, IOException\n      {\n          int length = filenames.length;\n          BufferedImage[] img_list = new BufferedImage[length];\n\n          for (int i = 0; i &lt; length; i++)\n          {\n              BufferedImage img = ImageIO.read(new File(filenames[i]));\n              img_list[i] = img;\n          }\n\n          generateFromBI(img_list, output, delay, loop);\n      }\n\n      // Generate gif from BufferedImage array\n      // Make the gif loopable if loop is true\n      // Set the delay for each frame according to the delay, 100 = 1s\n      // Use the name given in String output for output file\n      public static void generateFromBI(BufferedImage[] images, String output, int delay, boolean loop)\n              throws IIOException, IOException\n      {\n          int maxWidth = 0;\n          int maxHeight = 0;\n          ImageWriter gifWriter = getWriter();\n          ImageOutputStream ios = getImageOutputStream(output);\n          IIOMetadata metadata = getMetadata(gifWriter, delay, loop);\n\n          //Get bigger Width and Height\n          for (BufferedImage img: images)\n          {\n              if(img.getHeight() &gt; maxHeight){\n                  maxHeight = img.getHeight();\n              }\n              if(img.getWidth() &gt; maxWidth){\n                  maxWidth = img.getWidth();\n              }\n          }\n\n          gifWriter.setOutput(ios);\n          gifWriter.prepareWriteSequence(null);\n          for (BufferedImage img: images)\n          {\n              BufferedImage dimg = new BufferedImage(maxWidth, maxHeight, BufferedImage.TYPE_INT_ARGB);\n              Image tmp = img.getScaledInstance(img.getWidth(), img.getHeight(), Image.SCALE_DEFAULT);\n              Graphics2D g2d = dimg.createGraphics();\n              int centerWidth = (maxWidth / 2) - (img.getWidth()/2) ;\n              g2d.drawImage(tmp, centerWidth, 0, null);\n              g2d.dispose();\n\n              IIOImage temp = new IIOImage(dimg, null, metadata);\n              gifWriter.writeToSequence(temp, null);\n          }\n\n          gifWriter.endWriteSequence();\n      }\n\n      // Retrieve gif writer\n      private static ImageWriter getWriter() throws IIOException\n      {\n          Iterator&lt;ImageWriter&gt; itr = ImageIO.getImageWritersByFormatName(&quot;gif&quot;);\n          if(itr.hasNext())\n              return (ImageWriter)itr.next();\n\n          throw new IIOException(&quot;GIF writer doesn\'t exist on this JVM!&quot;);\n      }\n\n      // Retrieve output stream from the given file name\n      private static ImageOutputStream getImageOutputStream(String output) throws IOException\n      {\n          File outfile = new File(output);\n          return ImageIO.createImageOutputStream(outfile);\n      }\n\n      // Prepare metadata from the user input, add the delays and make it loopable\n      // based on the method parameters\n      private static IIOMetadata getMetadata(ImageWriter writer, int delay, boolean loop)\n          throws IIOInvalidTreeException\n      {\n          // Get the whole metadata tree node, the name is javax_imageio_gif_image_1.0\n          // Not sure why I need the ImageTypeSpecifier, but it doesn\'t work without it\n          ImageTypeSpecifier img_type = ImageTypeSpecifier.createFromBufferedImageType(BufferedImage.TYPE_INT_ARGB);\n          IIOMetadata metadata = writer.getDefaultImageMetadata(img_type, null);\n          String native_format = metadata.getNativeMetadataFormatName();\n          IIOMetadataNode node_tree = (IIOMetadataNode)metadata.getAsTree(native_format);\n\n          // Set the delay time you can see the format specification on this page\n          // https://docs.oracle.com/javase/7/docs/api/javax/imageio/metadata/doc-files/gif_metadata.html\n          IIOMetadataNode graphics_node = getNode(&quot;GraphicControlExtension&quot;, node_tree);\n          graphics_node.setAttribute(&quot;delayTime&quot;, String.valueOf(delay));\n          graphics_node.setAttribute(&quot;disposalMethod&quot;, &quot;none&quot;);\n          graphics_node.setAttribute(&quot;userInputFlag&quot;, &quot;FALSE&quot;);\n\n          if(loop)\n              makeLoopy(node_tree);\n\n          metadata.setFromTree(native_format, node_tree);\n\n          return metadata;\n      }\n\n      // Add an extra Application Extension node if the user wants it to be loopable\n      // I am not sure about this part, got the code from StackOverflow\n      // TODO: Study about this\n      private static void makeLoopy(IIOMetadataNode root)\n      {\n          IIOMetadataNode app_extensions = getNode(&quot;ApplicationExtensions&quot;, root);\n          IIOMetadataNode app_node = getNode(&quot;ApplicationExtension&quot;, app_extensions);\n\n          app_node.setAttribute(&quot;applicationID&quot;, &quot;NETSCAPE&quot;);\n          app_node.setAttribute(&quot;authenticationCode&quot;, &quot;2.0&quot;);\n          app_node.setUserObject(new byte[]{ 0x1, (byte) (0 &amp; 0xFF), (byte) ((0 &gt;&gt; 8) &amp; 0xFF)});\n\n          app_extensions.appendChild(app_node);\n          root.appendChild(app_extensions);\n      }\n\n      // Retrieve the node with the name from the parent root node\n      // Append the node if the node with the given name doesn\'t exist\n      private static IIOMetadataNode getNode(String node_name, IIOMetadataNode root)\n      {\n          IIOMetadataNode node = null;\n\n          for (int i = 0; i &lt; root.getLength(); i++)\n          {\n              if(root.item(i).getNodeName().compareToIgnoreCase(node_name) == 0)\n              {\n                  node = (IIOMetadataNode) root.item(i);\n                  return node;\n              }\n          }\n\n          // Append the node with the given name if it doesn\'t exist\n          node = new IIOMetadataNode(node_name);\n          root.appendChild(node);\n\n          return node;\n      }\n  }\n  import javax.swing.*;\n  import java.util.List;\n  import java.util.ArrayList;\n  import java.util.Iterator;\n  import java.util.Observer;\n  import java.awt.*;\n\n  import java.net.*;\n  import java.io.*;\n  // import javax.xml.bind.DatatypeConverter;\n  // Using java.util.Base64 instead of javax.xml.bind\n  import java.util.Base64;\n  import javax.imageio.*;\n  import java.awt.image.*;\n  import javax.imageio.stream.*;\n\n\n  /**\n   * Class to represent a 2d world that can hold turtles and\n   * display them\n   *\n   * Copyright Georgia Institute of Technology 2004\n   * @author Barb Ericson ericson@cc.gatech.edu\n   */\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public class World implements ModelDisplay\n  {\n    ////////////////// fields ///////////////////////\n\n    /** should automatically repaint when model changed */\n    private boolean autoRepaint = true;\n\n    /** the background color for the world */\n    private Color background = Color.white;\n\n    /** the width of the world */\n    private int width = 640;\n\n    /** the height of the world */\n    private int height = 480;\n\n    /** speed/delay in drawing */\n    private int delay = 50;\n\n    /** the list of turtles in the world */\n    private List&lt;Turtle&gt; turtleList = new ArrayList&lt;Turtle&gt;();\n\n    /** background picture */\n    private Picture picture = null;\n\n    /* All world changes*/\n    private List&lt;Picture&gt; worldHistory = new ArrayList&lt;Picture&gt;();\n\n\n    ////////////////// the constructors ///////////////\n\n    /**\n     * Constructor that takes no arguments\n     */\n    public World()\n    {\n      // set up the world and make it visible\n      initWorld(true);\n    }\n\n    /**\n     * Constructor that takes a boolean to\n     * say if this world should be visible\n     * or not\n     * @param visibleFlag if true will be visible\n     * else if false will not be visible\n     */\n    public World(boolean visibleFlag)\n    {\n      initWorld(visibleFlag);\n    }\n\n    /**\n     * Constructor that takes a width and height for this\n     * world\n     * @param w the width for the world\n     * @param h the height for the world\n     */\n    public World(int w, int h)\n    {\n      width = w;\n      height = h;\n\n      // set up the world and make it visible\n      initWorld(true);\n    }\n\n    ///////////////// methods ///////////////////////////\n\n    /**\n     * Method to initialize the world\n     * @param visibleFlag the flag to make the world\n     * visible or not\n     */\n    private void initWorld(boolean visibleFlag)\n    {\n      // create the background picture\n      picture = new Picture(width,height);\n      this.modelChanged();\n    }\n\n    /**\n     * Method to get the graphics context for drawing on\n     * @return the graphics context of the background picture\n     */\n    public Graphics getGraphics() { return picture.getGraphics(); }\n\n    /**\n     * Method to clear the background picture\n     */\n    public void clearBackground() { picture = new Picture(width,height); }\n\n    /**\n     * Method to get the background picture\n     * @return the background picture\n     */\n    public Picture getPicture() { return picture; }\n\n    /**\n     * Method to set the background picture\n     * @param pict the background picture to use\n     */\n    public void setPicture(Picture pict) { picture = pict; }\n\n    /**\n     * Method to paint this component\n     * @param g the graphics context\n     */\n    public synchronized void paintComponent(Graphics g)\n    {\n      Turtle turtle = null;\n\n      // draw the background image\n      g.drawImage(picture.getImage(),0,0,null);\n\n      // loop drawing each turtle on the background image\n      Iterator iterator = turtleList.iterator();\n      while (iterator.hasNext())\n      {\n        turtle = (Turtle) iterator.next();\n        turtle.paintComponent(g);\n      }\n    }\n\n    /**\n     * Method to get the last turtle in this world\n     * @return the last turtle added to this world\n     */\n    public Turtle getLastTurtle()\n    {\n      return (Turtle) turtleList.get(turtleList.size() - 1);\n    }\n\n\n    /**\n     * Method to add a model to this model displayer\n     * @param model the model object to add\n     */\n    public void addModel(Object model)\n    {\n      turtleList.add((Turtle) model);\n    }\n\n    /**\n     * Method to check if this world contains the passed\n     * turtle\n     * @return true if there else false\n     */\n    public boolean containsTurtle(Turtle turtle)\n    {\n      return (turtleList.contains(turtle));\n    }\n\n    /**\n     * Method to remove the passed object from the world\n     * @param model the model object to remove\n     */\n    public void remove(Object model)\n    {\n      turtleList.remove(model);\n    }\n\n    /**\n     * Method to get the width in pixels\n     * @return the width in pixels\n     */\n    public int getWidth() { return width; }\n\n    /**\n     * Method to get the height in pixels\n     * @return the height in pixels\n     */\n    public int getHeight() { return height; }\n\n    /**\n     * Method to set the speed of animation by setting the delay to between 0-100.\n     * 50 is the default.\n     * @param speed\n     */\n    public void setSpeed(int d) {\n       if (d &gt;= 0 &amp;&amp; d &lt;= 100)\n           delay = d;\n    }\n\n    /**\n     * Method that allows the model to notify the display\n     */\n    public void modelChanged()\n    {\n       Picture p = new Picture(this.width, this.height);\n       this.paintComponent(p.getGraphics());\n       this.worldHistory.add(p);\n    }\n\n    /**\n     * Method to set the automatically repaint flag\n     * @param value if true will auto repaint\n     */\n    public void setAutoRepaint(boolean value) { autoRepaint = value; }\n\n    /**\n     * Method to show the frame\n     */\n    public void show()\n    {\n      this.show(false);\n    }\n\n    public void show(boolean showHistory) {\n        this.paintComponent(this.picture.getGraphics());\n        if(showHistory) {\n            try {\n                BufferedImage[] images = new BufferedImage[this.worldHistory.size()];\n                for(int i = 0; i &lt; this.worldHistory.size(); i++) {\n                    images[i] = ((Picture) this.worldHistory.get(i)).getBufferedImage();\n                }\n                Giffer.generateFromBI(images, &quot;history.gif&quot;, delay, false);\n\n                File history = new File(&quot;history.gif&quot;);\n\n                URL url = history.toURI().toURL();\n\n                byte[] imageBytes = downloadUrl(url);\n                String result =\n                //DatatypeConverter.printBase64Binary(imageBytes);\n                //BH: using java.util.Base64 instead of javax.xml.bind.DataTypeConverter\n                Base64.getEncoder().encodeToString(imageBytes);\n\n                System.gc();\n                history.delete();\n                double rand = Math.random();\n                System.out.println(&quot;&amp;lt;img src=\\\'data:image/gif;base64,&quot; + result + &quot;\\\'/&gt;&quot;);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        } else {\n            this.picture.show();\n        }\n    }\n\n    private byte[] downloadUrl(URL toDownload) {\n      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n      try {\n          byte[] chunk = new byte[4096];\n          int bytesRead;\n          InputStream stream = toDownload.openStream();\n\n          while ((bytesRead = stream.read(chunk)) &gt; 0) {\n              outputStream.write(chunk, 0, bytesRead);\n          }\n          //toDownload.close();\n\n      } catch (IOException e) {\n          e.printStackTrace();\n          return null;\n      }\n\n      return outputStream.toByteArray();\n  }\n\n    /**\n     * Method to get the list of turtles in the world\n     * @return a list of turtles in the world\n     */\n    public List getTurtleList()\n    { return turtleList;}\n\n    /**\n     * Method to get an iterator on the list of turtles\n     * @return an iterator for the list of turtles\n     */\n    public Iterator getTurtleIterator()\n    { return turtleList.iterator();}\n\n    /**\n     * Method that returns information about this world\n     * in the form of a string\n     * @return a string of information about this world\n     */\n    public String toString()\n    {\n      return &quot;A &quot; + getWidth() + &quot; by &quot; + getHeight() +\n        &quot; world with &quot; + turtleList.size() + &quot; turtles in it.&quot;;\n    }\n\n  } // end of World class\n', 'hidden': 'data-hidden', 'edit': 'false', 'question_label': '2.7.4.1'}" source="/mnt/c/Users/hoffmanb/Documents/GitHub/csawesome2/_fixed_sources/Unit1-Using-Objects-and-Methods/topic-1-7-APIs-and-libraries.rst">
            </DataFileNode>
        </subsection>
</section>
