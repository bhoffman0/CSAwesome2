<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="mutators-setters">
  <title>Mutators / Setters</title><introduction>
    
    <p>As we saw in the last section, since we typically make instance variables
            <c>private</c>, we have to define getters if we want to allow code outside the
            class to access the value of particular instance variables.</p>
    <p>By the same token, if we want to allow code outside the class to <title_reference>change</title_reference> the
            value of an instance variable we have to provide what is formally called a
            <term>mutator method</term> but which everyone actually calls a <term>setter</term>. A setter is a
            void method with a name that starts with <c>set</c> and that takes a single
            argument of the same type as the instance variable to be set. The effect of a
            setter, as you would probably expect, is to assign the provided value to the
            instance variable.</p>
    <p>Just as you shouldn’t reflexively write a getter for every instance variable,
            you should think even harder about whether you want to write a setter. Not all
            instance variables are meant to be manipulated directly by code outside the
            class.</p>
    <p>For example, consider the <c>Turtle</c> class. It provides getters <c>getXPos</c> and
            <c>getYPos</c> but it does not provide corresponding setters. There are, however,
            methods that change a <c>Turtle</c>’s position like <c>forward</c> and <c>moveTo</c>.
            But they do more than just changing the values of instance variables; they also
            take care of drawing lines on the screen if the pen is down. By not providing
            setters for those instance variables, the authors of the <c>Turtle</c> class can
            assume the a <c>Turtle</c>’s position won’t change other than by going through
            one of the approved movement methods. In general, you shouldn’t write a setter
            until you find a real reason to do so.</p>
  </introduction>
  <subsection>
            <title>How to write a setter</title>
            <p>Here are some examples of how to write a setter for an instance variable:</p>
            <program language="java"><input>
class ExampleTemplate
{
    // Instance variable declaration
    private typeOfVar varName;

    // Setter method template
    public void setVarName(typeOfVar newValue)
    {
        varName = newValue;
    }
}
</input></program>
            <p>Here’s an example of the <c>Student</c> class with a setter for the <c>name</c> variable:</p>
            <program language="java"><input>
class Student
{
    // Instance variable name
    private String name;

    /**
     * setName sets name to newName
     *
     * @param newName
     */
    public void setName(String newName)
    {
        name = newName;
    }

    public static void main(String[] args)
    {
        // To call a set method, use objectName.setVar(newValue)
        Student s = new Student();
        s.setName("Ayanna");
    }
}
</input></program>
            <p>Notice the difference between setters and getters in the following figure.
                Getters return an instance variable’s value and have the same return type as
                this variable and no parameters. Setters have a void return type and take a new
                value as a parameter to change the value of the instance variable.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Figure 1: Comparison of setters and getters</caption><image source="Unit3-Class-Creation/Figures/get-set-comparison.png" width="100%%"/></figure>
            <p><problematic refid="id2">|CodingEx|</problematic> <term>Coding Exercise</term></p>
            <p>Try the <c>Student</c> class below which has had some setters added. Notice that
                there is no <c>setId</c> method even though there is a <c>getId</c>. This is
                presumably because in the system this class is part of, while it makes sense for
                a student to change their name or email, their id should never change.</p>
            <p>You will need to fix one error. The <c>main</c> method is in a separate class
                <c>TesterClass</c> and does not have access to the <c>private</c> instance variables
                in the <c>`Student</c> class. Change the <c>main</c> method so that it uses a
                <c>public</c> setter to change the value instead.</p>

<exercise label="StudentObjExample2">
    <statement>
            <p>Fix the main method to include a call to the appropriate set method.</p>

    </statement>
    <program interactive="activecode" language="java">
        <input>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println(s1);
        s1.setName("Skyler 2");
        // Main doesn't have access to email, use set method!
        s1.email = "skyler2@gmail.com";
        System.out.println(s1);
    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // Setters

    public void setName(String newName)
    {
        name = newName;
    }

    public void setEmail(String newEmail)
    {
        email = newEmail;
    }

    // Getters

    public String getName()
    {
        return name;
    }

    public String getEmail()
    {
        return email;
    }

    public int getId()
    {
        return id;
    }

    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}

</input><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

// activeCode StudentObjExample2
public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("TesterClass");
    }

    @Test
    public void test1()
    {
        String target = "s1.setEmail(\"skyler2@gmail.com\");";
        boolean passed = checkCodeContains("call to setEmail()", target);
        assertTrue(passed);
    }

    @Test
    public void testMain()
    {
        String output = getMethodOutput("main");
        String expect = "123456: Skyler, skyler@sky.com\n123456: Skyler 2, skyler2@gmail.com";

        boolean passed = getResults(expect, output, "Checking main()", true);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
            <p><problematic refid="id4">|Exercise|</problematic> <term>Check your understanding</term></p>

    <exercise label="setSignature">
        <statement>

            <p>5-5-2: Consider the class Party which keeps track of the number of people at the party.</p>
            <program language="java"><input>
public class Party
{
    // number of people at the party
    private int numOfPeople;

    /* Missing header of set method */
    {
        numOfPeople = people;
    }
}
</input></program>
            <p>Which of the following method signatures could replace the missing header for the set method in the code above so that the method will work as intended?</p>
</statement><choices><choice><statement id="setSignature_opt_a">            <p>public int getNum(int people)</p>
</statement><feedback id="setSignature_opt_a">
            <p>The set method should not have a return value and is usually named set, not get.</p>
</feedback></choice><choice><statement id="setSignature_opt_b">            <p>public int setNum()</p>
</statement><feedback id="setSignature_opt_b">
            <p>The set method should not have a return value and needs a parameter.</p>
</feedback></choice><choice><statement id="setSignature_opt_c">            <p>public int setNum(int people)</p>
</statement><feedback id="setSignature_opt_c">
            <p>The set method should not have a return value.</p>
</feedback></choice><choice correct="yes"><statement id="setSignature_opt_d">            <p>public void setNum(int people)</p>
</statement><feedback id="setSignature_opt_d">
            <p>Yes, the set method should take a parameter called people and have a void return value. The name of the set method is usually set followed by the full instance variable name, but it does not have to be an exact match.</p>
</feedback></choice><choice><statement id="setSignature_opt_e">            <p>public int setNumOfPeople(int p)</p>
</statement><feedback id="setSignature_opt_e">
            <p>The parameter of this set method should be called people in order to match the code in the method body.</p>
</feedback></choice></choices>

    </exercise>

<exercise label="AccessorMutator">
    <statement><p>Drag the definition from the left and drop it on the correct word on the right.  Click the "Check Me" button to see if you are correct.</p></statement>
    <feedback><p>Review the vocabulary.</p></feedback>
<matches><match order="1"><premise>gets and returns the value of an instance variable</premise><response>accessor method</response></match><match order="2"><premise>sets the instance variable to a value in its parameter</premise><response>mutator method</response></match><match order="3"><premise>initializes the instance variables to values</premise><response>constructor</response></match><match order="4"><premise>accessible from outside the class</premise><response>public</response></match><match order="5"><premise>accessible only inside the class</premise><response>private</response></match></matches></exercise>            <p>Mutator methods do not have to have a name with “set” in it, although most do. They can be any methods that change the value of an instance variable or a static variable in the class, as can be seen in the AP Practice questions below.</p>
        </subsection>
  <subsection>
            <title><problematic refid="id6">|Groupwork|</problematic> Programming Challenge : Class Pet Setters</title>
            <image source="Unit3-Class-Creation/Figures/animalclinic.png" width="27%%" alt="Animal Clinic"/>
            <p><ol marker="1">
                <li>
                    <p>Copy your Awesome Animal Clinic Pet class from the <url href="https://runestone.academy/ns/books/published/csawesome/Unit5-Writing-Classes/topic-5-4-accessor-methods.html#groupwork-programming-challenge-class-pet" visual="https://runestone.academy/ns/books/published/csawesome/Unit5-Writing-Classes/topic-5-4-accessor-methods.html#groupwork-programming-challenge-class-pet">last lesson</url> into this Active Code window.</p>
                </li>
                <li>
                    <p>Add set methods for each of the 5 instance variables. Make sure you use good commenting!</p>
                </li>
                <li>
                    <p>Test each of the set methods in the main method.</p>
                </li>
            </ol></p>

<exercise label="challenge-5-5-Pet-Class">
    <statement>
            <p>Create a <c>Pet</c> class that keeps track of the name, age, weight, type of
                animal, and breed for records at an animal clinic with a constructor, a
                <c>toString</c> method, and getters and setters for each instance variable.</p>

    </statement>
    <program interactive="activecode" language="java">
        <input>
/**
 * Pet class (complete comments)
 *
 * @author
 * @since
 */
class Pet
{
    // complete class definition with set methods

}

public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        // Create 2 Pet objects and test all your set methods

    }
}

 </input><tests>
 import static org.junit.Assert.*;

 import org.junit.*;

 import java.io.*;

 // activecode challenge-5-5-Pet-Class
 public class RunestoneTests extends CodeTestHelper
 {
     public RunestoneTests()
     {
         super("TesterClass");
     }

     @Test
     public void testConstructors()
     {
         changeClass("Pet");
         int count = 0;

         for (int i = 0; i &lt; 6; i++)
         {
             if (checkConstructor(i).equals("pass")) count++;
         }

         boolean passed = count &gt;= 1;

         getResults("2+", "" + count, "Checking for constructor", passed);
         assertTrue(passed);
     }

     @Test
     public void testPrivateVariables()
     {
         changeClass("Pet");
         String expect = "5 Private";
         String output = testPrivateInstanceVariables();

         boolean passed = getResults(expect, output, "Checking Private Instance Variables");
         assertTrue(passed);
     }

     @Test
     public void test1()
     {
         String code = getCode();
         String target = "public * get*()";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking accessor (get) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test2()
     {
         String code = getCode();
         String target = "public void set*(*)";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking mutator (set) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test3()
     {
         String target = "public String toString()";
         boolean passed = checkCodeContains("toString() method", target);
         assertTrue(passed);
     }

     @Test
     public void test4()
     {
         String code = getCode();
         String target = "Pet * = new Pet(";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 2;

         getResults("2", "" + num, "Checking main method creates 2 Pet objects", passed);
         assertTrue(passed);
     }

     @Test
     public void testMain()
     {
         String output = getMethodOutput("main");

         String expect = "3+ line(s) of text";
         String actual = " line(s) of text";

         int len = output.split("\n").length;

         if (output.length() &gt; 0)
         {
             actual = len + actual;
         }
         else
         {
             actual = output.length() + actual;
         }
         boolean passed = len &gt;= 3;

         getResults(expect, actual, "Checking main method prints info for 3 Pet objects", passed);
         assertTrue(passed);
     }
 }
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>A void method does not return a value. Its header contains the keyword
                        <c>void</c> before the method name.</p>
                </li>
                <li>
                    <p>A <term>mutator method</term> or <term>setter</term> is a void method that changes the values of an instance or static
                        variable.</p>
                </li>
            </ul></p>
        </subsection>
  <subsection>
            <title>AP Practice</title>

    <exercise label="AP5-5-1">
        <statement>

            <p>5-5-5: Consider the following class definition.</p>
            <program language="java"><input>
public class Liquid
{
    private int currentTemp;

    public Liquid(int temp)
    {
        currentTemp = temp;
    }

    public void resetTemp()
    {
        currentTemp = newTemp;
    }
}
</input></program>
            <p>Which of the following best identifies the reason the class does not compile?</p>
</statement><choices><choice><statement id="AP5-5-1_opt_a">            <p>The constructor header does not have a return type.</p>
</statement><feedback id="AP5-5-1_opt_a">
            <p>The constructor should not have a return type.</p>
</feedback></choice><choice><statement id="AP5-5-1_opt_b">            <p>The resetTemp method is missing a return type.</p>
</statement><feedback id="AP5-5-1_opt_b">
            <p>Mutator methods usually have a void return type.</p>
</feedback></choice><choice><statement id="AP5-5-1_opt_c">            <p>The constructor should not have a parameter.</p>
</statement><feedback id="AP5-5-1_opt_c">
            <p>Constructors can have parameters.</p>
</feedback></choice><choice correct="yes"><statement id="AP5-5-1_opt_d">            <p>The resetTemp method should have a parameter.</p>
</statement><feedback id="AP5-5-1_opt_d">
            <p>Correct! The resetTemp method should have a parameter for the newTemp value to set the currentTemp.</p>
</feedback></choice><choice><statement id="AP5-5-1_opt_e">            <p>The instance variable currentTemp should be public instead of private.</p>
</statement><feedback id="AP5-5-1_opt_e">
            <p>Instance variables should be private variables.</p>
</feedback></choice></choices>

    </exercise>

    <exercise label="AP5-5-2">
        <statement>

            <p>5-5-6: In the <c>Party</c> class below, the <c>addPeople</c> method is intended to increase the value of the instance variable <c>numOfPeople</c> by the value of the parameter <c>additionalPeople</c>. The method does not work as intended.</p>
            <program language="java"><input>
public class Party
{
    private int numOfPeople;

    public Party(int n)
    {
        numOfPeople = n;
    }

    public int addPeople(int additionalPeople) // Line 10
            {
        numOfPeople += additionalPeople; // Line 12
    }
}
</input></program>
            <p>Which of the following changes should be made so that the class definition compiles without error and the method <c>addPeople</c> works as intended?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Replace line 12 with numOfPeople = additionalPeople;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 12 with return additionalPeople;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 12 with additionalPeople += 3;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 10 with public addPeople (int additionalPeople)</p>
                </statement>
                <feedback>
                    <p>Mutator methods should have a void return type.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Replace line 10 with public void addPeople(int additionalPeople)</p>
                </statement>
                <feedback>
                    <p>Mutator methods should have a void return type.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
        </subsection>
</section>
