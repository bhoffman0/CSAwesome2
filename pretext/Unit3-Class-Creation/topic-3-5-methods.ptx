<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="topic-3-5-methods">
  <title>Methods: How to Write Them</title><introduction>
    
    <p>In object-oriented programming, the three main parts of a class are:</p>
    <p>
      <ul>
            <li>
                <p>the <term>instance variables</term> which hold attributes or values associated with each object,</p>
            </li>
            <li>
                <p>the <term>constructors</term> whose job is to initialize the instance variables,</p>
            </li>
            <li>
                <p>and the <term>methods</term> which contain the code for the behaviors of an object and which can use the instance variables defined in the class.</p>
            </li>
        </ul>
    </p>
    <p>In Unit 1, we used <c>Turtle</c> objects and called methods like <c>forward</c> which changed the <c>x</c> and <c>y</c> coordinates (instance variables) of the turtle. We also defined static methods that did not work with objects.  In this unit, we will learn how to write our own methods in our own classes.</p>
  </introduction>
  <subsection>
            <title>Defining and Calling Methods</title>
            <p>A <term>method</term> is a block of code that performs a specific task. Methods are defined inside a class and can access the instance variables of the class.  For example, the print() method below prints the instance variables of the Person class. Methods are usually public.</p>
            <program language="java"><code>
public class Person
{
    // instance variables
    private String name;
    private String email;

    // Method definition: uses instance variables name and email
    public void print()
    {
        System.out.println("Name: " + name);
        System.out.println("Email: " + email);
    }

    public static void main(String[] args)
    {
        Person p = new Person();
        p.print();  // Method call
    }
}
</code></program>
            <p>There are three steps to creating and calling a method:</p>
            <p><ol marker="1">
                <li>
                    <p><term>Object of the Class</term>: Declare an object of your class in the main method or from outside the class.</p>
                    <blockquote>
                        <program language="java"><code>
// Step 1: declare an object in main or from outside the class
Classname objectName = new Classname();
</code></program>
                    </blockquote>
                </li>
                <li>
                    <p><term>Method Call</term>: whenever you want to use the method, call objectName.methodName();</p>
                    <blockquote>
                        <program language="java"><code>
// Step 2: call the object's method
objectName.methodName(); //Step 2
</code></program>
                    </blockquote>
                </li>
                <li>
                    <p><term>Method Definition</term>:  write the method’s <term>header</term> and <term>body</term> code like below:</p>
                    <blockquote>
                        <program language="java"><code>
// Step 3: Define the method in the class
// method header
public void methodName()
{
      // method body for the code
}
</code></program>
                    </blockquote>
                </li>
            </ol></p>
            <p>The following flowchart can be used to compare three different ways of calling methods. Class (static) methods are called using the class name. Instance methods which are discussing in this lesson are called using an object of the class. If you are calling the instance method from the main method or from another class, you must first create an object of that class and then call its methods using <c>object.methodName()</c>. If you are calling the method from within the same class, you can just call the method using <c>methodName()</c> which will refer to the current object.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Comparing Method Calls to Static and Instance Methods</caption><image source="Unit3-Class-Creation/Figures/FlowChartCallingMethods.png" width="98%%" alt="Comparing method calls to static and instance methods"/></figure>

<exercise label="PersonPrint">
    <statement>
            <p>Try the following code. Add a print() method in the Person class that prints out all the attributes (name, email, phonenumber) of a person object.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class Person
{
    // instance variables
    private String name;
    private String email;
    private String phonenumber;

    // Constructor
    public Person(String n, String e, String p)
    {
        name = n;
        email = e;
        phonenumber = p;
    }

    // TODO: Add a print() method that prints out all the attributes (name, email, phonenumber)


    public static void main(String[] args)
    {
        Person p1 = new Person("Taylor", "swift@gmail.com", "123-456-7890");
        p1.print();
    }
}
</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void test1()
    {
        String target = "public void print()";
        boolean passed = checkCodeContains("public void print() method", target);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>void Methods</title>
            <p>A <term>void method</term> is a method that does not return a value. It is used when you want to perform an action but do not need to return a value. The method header for a void method looks like this:</p>
            <program language="java"><code>
public void methodName()
{
    // method body
}
</code></program>
            <p>The <c>print</c> method above is a void method. It does not return a value, but it does print out the name and email of the person. In the sections below, we will learn about setter methods that are also void methods.</p>
        </subsection>
  <subsection>
            <title>Non-void Methods</title>
            <p>A <term>non-void method</term> is a method that returns a single value. Its body must have a <term>return</term> statement, usually at the end, that returns a variable’s value or an expression. Its header includes the <term>return type</term> (the type of the value in the return statement) in place of the keyword <c>void</c>. The method header for a non-void method looks like this:</p>
            <program language="java"><code>
public returnType methodName()
{
    // method body
    return value;
}
</code></program>
            <p>In Unit 1, we used static non-void methods like `` Math.random()`` which returned a random number. We also used non-void methods that belonged to Turtle objects like <c>getXPos()</c> and <c>getYPos()</c> that returned the x and y coordinates of the turtle. The most common non-void methods in Java are methods that start with <c>get</c> and return the value of an instance variable. We will learn about these in the next section.</p>
            <p>In non-void methods, a return expression compatible with the return type is evaluated, and the value is returned. This is referred to as <term>return by value</term>.
                The <c>return</c> keyword is used to return the flow of control to the point where the method or constructor was called. Any code that is sequentially after a return statement will never be executed, so usually non-void methods end with a return statement. Executing a return statement inside a selection or iteration statement will halt the statement and exit the method or constructor.</p>
            <note>
                <p>Some common errors when writing and using non-void methods are:</p>
                <p><ul>
                    <li>
                        <p>Forgetting a return type like <c>int</c> before the method name.</p>
                    </li>
                    <li>
                        <p>Forgetting to use the <c>return</c> keyword to return a value at the end of
                            the method.</p>
                    </li>
                    <li>
                        <p>Returning too soon from a method. If you have a return statement in a
                            selection or iteration statement, the method will exit at that point and not execute the rest of the code.</p>
                    </li>
                    <li>
                        <p>Forgetting to do something with the value returned from a method, like
                            assigning it to a variable or printing it out.</p>
                    </li>
                </ul></p>
            </note>
        </subsection>
  <subsection>
            <title>Accessors / Getters</title>
            <p>Since the instance variables in a class are usually marked as <c>private</c> to the
                class, if you want code outside the class to be able to access the value of an
                instance variable, you need to write what is formally called an <term>accessor
                    methods</term> but which everyone actually just calls a <term>getter</term>. A getter is a
                <c>public</c> method that takes no arguments and returns the value of the
                <c>private</c> instance variable.</p>
            <p>If you used a language like App Inventor in an AP CSP class, you may have used
                setter and getter blocks. In App Inventor, you cannot make your own classes, but
                you can declare UI objects like Button1, Button2 from the Button class and use
                their get/set methods for any property like below. (We’ll talk about setters in
                Java in the next section.)</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">App Inventor Set and Get blocks for object Button1</caption><image source="Unit3-Class-Creation/Figures/AppInvSetGet.png" width="54%%"/></figure>
            <p>You don’t need to write a getter for every instance variable in a class but if
                you want code outside the class to be able to get the value of one of your
                instance variables, you’ll need to write a getter that looks like the following.</p>
            <program language="java"><code>
class ExampleTemplate
{

    // Instance variable declaration
    private typeOfVar varName;

    // Accessor (getter) method template
    public typeOfVar getVarName()
    {
        return varName;
    }
}
</code></program>
            <p>Notice that the getter’s return type is the same as the type of the instance
                variable and all the body of the getter does is return the value of the variable
                using a <c>return</c> statement. (We’ll talk more about the <c>return</c> statement in
                section 5.6 but for now just notice that it is followed by an expression whose
                value must be the same type as the return type in the method’s header. In a
                getter that will definitely be true as long as the type of the instance variable
                and the return type of the getter are the same.)</p>
            <p>Here’s an example of an accessor method called <c>getName</c> for the <c>Student</c>
                class which also demonstrates how to call <c>getName</c> using a <c>Student</c>
                object:</p>
            <program language="java"><code>
class Student
{

  //Instance variable name
  private String name;

  /** getName() example
   *  @return name */
  public String getName()
  {
     return name;
  }

  public static void main(String[] args)
  {
     // To call a get method, use objectName.getVarName()
     Student s = new Student();
     System.out.println("Name: " + s.getName() );
  }
</code></program>
            <p>Note, that getters only return the <em>value</em> of the variable.</p>
            <p>Try the following code. Note that this active code window has 2 classes! The main method is in a separate <term>Tester</term> or <term>Driver</term> class. It does not have access to the private instance variables in the other Student class. Note that when you use multiple classes in an IDE, you usually put them in separate files, and you give the files the same name as the public class in them. In active code and IDEs, you can put 2 classes in 1 file, as demonstrated here, but only 1 of them can be public and have a main method in it. You can also view the fixed code in the <url href="http://www.pythontutor.com/visualize.html#code=public%20class%20TesterClass%20%0A%20%20%7B%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20Student%20s1%20%3D%20new%20Student%28%22Skyler%22,%20%22skyler%40sky.com%22,%20123456%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Name%3A%22%20%2B%20%20s1.getName%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Email%3A%22%20%2B%20%20s1.getEmail%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22ID%3A%20%22%20%2B%20s1.getId%28%29%20%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%7D%0A%20%20%0A%20%20class%20Student%20%0A%20%20%7B%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20int%20id%3B%0A%20%20%20%20%20%0A%20%20%20%20%20public%20Student%28String%20initName,%20String%20initEmail,%20int%20initId%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20id%20%3D%20initId%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20accessor%20methods%20-%20getters%20%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20name%20*/%0A%20%20%20%20%20public%20String%20getName%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20name%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getEmail%28%29%20%20%40return%20email%20*/%0A%20%20%20%20%20public%20String%20getEmail%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20email%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20id%20*/%0A%20%20%20%20%20public%20int%20getId%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20id%3B%0A%20%20%20%20%20%7D%0A%20%20%7D&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" visual="http://www.pythontutor.com/visualize.html#code=public%20class%20TesterClass%20%0A%20%20%7B%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20Student%20s1%20%3D%20new%20Student%28%22Skyler%22,%20%22skyler%40sky.com%22,%20123456%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Name%3A%22%20%2B%20%20s1.getName%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Email%3A%22%20%2B%20%20s1.getEmail%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22ID%3A%20%22%20%2B%20s1.getId%28%29%20%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%7D%0A%20%20%0A%20%20class%20Student%20%0A%20%20%7B%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20int%20id%3B%0A%20%20%20%20%20%0A%20%20%20%20%20public%20Student%28String%20initName,%20String%20initEmail,%20int%20initId%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20id%20%3D%20initId%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20accessor%20methods%20-%20getters%20%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20name%20*/%0A%20%20%20%20%20public%20String%20getName%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20name%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getEmail%28%29%20%20%40return%20email%20*/%0A%20%20%20%20%20public%20String%20getEmail%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20email%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20id%20*/%0A%20%20%20%20%20public%20int%20getId%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20id%3B%0A%20%20%20%20%20%7D%0A%20%20%7D&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java visualizer</url>.</p>

<exercise label="StudentObjExample">
    <statement>
            <p>Try the following code. Note that it has a bug! It tries to access the private instance variable email from outside the class Student.  Change the main method in Tester class so that it uses the appropriate public accessor method (get method) to access the email value instead.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println("Name:" + s1.getName());
        // Fix the bug here!
        System.out.println("Email:" + s1.email);
        System.out.println("ID: " + s1.getId());
    }
}

/** Class Student keeps track of name, email, and id of a Student. */
class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // accessor methods - getters
    /** getName() @return name */
    public String getName()
    {
        return name;
    }

    /** getEmail() @return email */
    public String getEmail()
    {
        return email;
    }

    /** getName() @return id */
    public int getId()
    {
        return id;
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "Name:Skyler\nEmail:skyler@sky.com\nID: 123456";
        boolean passed = getResults(expect, output, "Checking for expected output");
        assertTrue(passed);
    }

    @Test
    public void testMethodCall() throws IOException
    {
        String target = "s1.getEmail()";
        boolean passed = checkCodeContains("call to accessor method for email", target);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title><c>toString</c></title>
            <p>While not strictly speaking a getter, another important method that returns a
                value is the <c>toString</c> method. This method is called automatically by Java in
                a number of situations when it needs to convert an object to a <c>String</c>. Most
                notably the methods <c>System.out.print</c> and <c>System.out.println</c> use it to
                convert a object argument into a <c>String</c> to be printed and when objects are
                added to <c>String</c>s with <c>+</c> and <c>+=</c> their <c>String</c> representation
                comes from calling their <c>toString</c> method.</p>
            <p>Here is the <c>Student</c> class again, but this time with a <c>toString</c> method.
                Note that when we call <c>System.out.println(s1)</c> it will automatically call the
                <c>toString</c> method to get a <c>String</c> representation of the <c>Student</c>
                object. The <c>toString</c> method will return a <c>String</c> that is then printed out.
                Watch how the control moves to the <c>toString</c> method and then comes back to <c>main</c>
                in the Java visualizer by using the Show CodeLens button.</p>

<exercise label="StudentToString">
    <statement>
            <p>See the toString() method in action. Add another student object and print it out.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println(s1);
        // TODO: add another student s2 and print it out


    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // toString() method
    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void test1() throws IOException
    {
        String target = "System.out.println(s2)";
        boolean passed = checkCodeContains("System.out.println(s2)", target);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Mutators / Setters</title>
            <p>In complement to the accessor/getter methods, if we want to allow code outside the class to <title_reference>change</title_reference> the
                value of an instance variable we have to provide what is formally called a
                <term>mutator method</term> but which everyone actually calls a <term>setter</term>. A setter is a
                void method with a name that starts with <c>set</c> and that takes a single
                argument of the same type as the instance variable to be set. The effect of a
                setter, as you would probably expect, is to assign the provided value to the
                instance variable.</p>
            <p>Just as you shouldn’t reflexively write a getter for every instance variable,
                you should think even harder about whether you want to write a setter. Not all
                instance variables are meant to be manipulated directly by code outside the
                class.</p>
            <p>For example, consider the <c>Turtle</c> class. It provides getters <c>getXPos</c> and
                <c>getYPos</c> but it does not provide corresponding setters. There are, however,
                methods that change a <c>Turtle</c>’s position like <c>forward</c> and <c>moveTo</c>.
                But they do more than just changing the values of instance variables; they also
                take care of drawing lines on the screen if the pen is down. By not providing
                setters for those instance variables, the authors of the <c>Turtle</c> class can
                assume the a <c>Turtle</c>’s position won’t change other than by going through
                one of the approved movement methods. In general, you shouldn’t write a setter
                until you find a real reason to do so.</p>
            <p>Here are some examples of how to write a setter for an instance variable:</p>
            <program language="java"><code>
class ExampleTemplate
{
    // Instance variable declaration
    private typeOfVar varName;

    // Setter method template
    public void setVarName(typeOfVar newValue)
    {
        varName = newValue;
    }
}
</code></program>
            <p>Here’s an example of the <c>Student</c> class with a setter for the <c>name</c> variable:</p>
            <program language="java"><code>
class Student
{
    // Instance variable name
    private String name;

    /**
     * setName sets name to newName
     *
     * @param newName
     */
    public void setName(String newName)
    {
        name = newName;
    }

    public static void main(String[] args)
    {
        // To call a set method, use objectName.setVar(newValue)
        Student s = new Student();
        s.setName("Ayanna");
    }
}
</code></program>
            <p>Notice the difference between setters and getters in the following figure.
                Getters return an instance variable’s value and have the same return type as
                this variable and no parameters. Setters have a void return type and take a new
                value as a parameter to change the value of the instance variable.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Comparison of setters and getters</caption><image source="Unit3-Class-Creation/Figures/get-set-comparison.png" width="100%%"/></figure>
            <p>Try the <c>Student</c> class below which has had some setters added. Notice that
                there is no <c>setId</c> method even though there is a <c>getId</c>. This is
                presumably because in the system this class is part of, while it makes sense for
                a student to change their name or email, their id should never change.</p>
            <p>You will need to fix one error. The <c>main</c> method is in a separate class
                <c>TesterClass</c> and does not have access to the <c>private</c> instance variables
                in the <c>`Student</c> class. Change the <c>main</c> method so that it uses a
                <c>public</c> setter to change the value instead.</p>

<exercise label="StudentObjExample2">
    <statement>
            <p>Fix the main method to include a call to the appropriate set method.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println(s1);
        s1.setName("Skyler 2");
        // Main doesn't have access to email, use set method!
        s1.email = "skyler2@gmail.com";
        System.out.println(s1);
    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // Setters

    public void setName(String newName)
    {
        name = newName;
    }

    public void setEmail(String newEmail)
    {
        email = newEmail;
    }

    // Getters

    public String getName()
    {
        return name;
    }

    public String getEmail()
    {
        return email;
    }

    public int getId()
    {
        return id;
    }

    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

// activeCode StudentObjExample2
public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("TesterClass");
    }

    @Test
    public void test1()
    {
        String target = "s1.setEmail(\"skyler2@gmail.com\");";
        boolean passed = checkCodeContains("call to setEmail()", target);
        assertTrue(passed);
    }

    @Test
    public void testMain()
    {
        String output = getMethodOutput("main");
        String expect = "123456: Skyler, skyler@sky.com\n123456: Skyler 2, skyler2@gmail.com";

        boolean passed = getResults(expect, output, "Checking main()", true);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>

    <exercise label="setSignature">
        <statement>

            <p> Consider the class Party which keeps track of the number of people at the party.</p>
            <program language="java"><code>
public class Party
{
    // number of people at the party
    private int numOfPeople;

    /* Missing header of set method */
    {
        numOfPeople = people;
    }
}
</code></program>
            <p>Which of the following method signatures could replace the missing header for the set method in the code above so that the method will work as intended?</p>
</statement><choices><choice><statement id="setSignature_opt_a">            <p>public int getNum(int people)</p>
</statement><feedback id="setSignature_opt_a">
            <p>The set method should not have a return value and is usually named set, not get.</p>
</feedback></choice><choice><statement id="setSignature_opt_b">            <p>public int setNum()</p>
</statement><feedback id="setSignature_opt_b">
            <p>The set method should not have a return value and needs a parameter.</p>
</feedback></choice><choice><statement id="setSignature_opt_c">            <p>public int setNum(int people)</p>
</statement><feedback id="setSignature_opt_c">
            <p>The set method should not have a return value.</p>
</feedback></choice><choice correct="yes"><statement id="setSignature_opt_d">            <p>public void setNum(int people)</p>
</statement><feedback id="setSignature_opt_d">
            <p>Yes, the set method should take a parameter called people and have a void return value. The name of the set method is usually set followed by the full instance variable name, but it does not have to be an exact match.</p>
</feedback></choice><choice><statement id="setSignature_opt_e">            <p>public int setNumOfPeople(int p)</p>
</statement><feedback id="setSignature_opt_e">
            <p>The parameter of this set method should be called people in order to match the code in the method body.</p>
</feedback></choice></choices>

    </exercise>
            <p>Mutator methods do not have to have a name with “set” in it, although most do. They can be any methods that change the value of an instance variable in the class. Most mutator methods are non-void methods. Mutator methods do not have to have parameters, but they usually do.</p>
        </subsection>
  <subsection>
            <title>Parameters</title>
            <p>The setter methods above contained parameters. A <term>parameter</term> is a variable in a method’s header that is used to pass in data that the method needs to do its job. In a setter, the parameter is the new value that you want to assign to the instance variable. Methods with parameters receive values through those parameters and use those values in accomplishing the method’s task.</p>
            <p>An <term>argument</term> is a value that is passed into a method when the method is called. It is saved into a parameter variable. The arguments passed to a method must be compatible in number and order with the types identified in the parameter list of the method signature. When calling methods, arguments are passed using call by value. <term>Call by value</term> initializes the parameters with copies of the arguments.
                When an argument is a primitive value, the parameter is initialized with a copy of that value. Changes to the parameter have no effect on the corresponding argument.</p>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">Method signatures with parameters and method calls arguments</caption><image source="Unit3-Class-Creation/Figures/method-param-arg.png" width="98%%" alt="Method parameters and arguments"/></figure>
        </subsection>
  <subsection>
            <title>Methods with Parameters that Return Calculated values</title>
            <p>Not all methods that return values are accessor/get methods. Some methods have parameters and return values that are found or calculated in a more complex algorithm. The following method uses a loop to find a letter in a text string given as a parameter. It returns true if the letter is found and false otherwise. Change it to return the count of how many times the letter is found in the text instead.</p>

<exercise label="StringFind">
    <statement>
            <p>Run the following program which contains a method called findLetter that takes a letter and a text as parameters and uses a loop to see if that letter is in the text and returns true if it is, false otherwise. Set the variables <c>letter</c> and <c>message</c> to new values in the main method and run it again to try finding a different letter. Then, change the code of the findLetter method to return how many times it finds letter in text, using a new variable called <c>count</c>. How would the return type change?</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class StringFind
{
    /**
     * findLetter looks for a letter in a String
     *
     * @param String letter to look for
     * @param String text to look in
     * @return boolean true if letter is in text After running the code, change
     *     this method to return an int count of how many times letter is in the
     *     text.
     */
    public boolean findLetter(String letter, String text)
    {
        boolean flag = false;
        for (int i = 0; i &lt; text.length(); i++)
        {
            if (text.substring(i, i + 1).equalsIgnoreCase(letter))
            {
                flag = true;
            }
        }
        return flag;
    }

    public static void main(String args[])
    {
        StringFind test = new StringFind();
        String message = "Apples and Oranges";
        String letter = "p";
        System.out.println("Does " + message + " contain a " + letter + "?");
        System.out.println(test.findLetter(letter, message));
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void tryfindLetter() throws IOException
    {
        String message = "Apples and Oranges";
        String letter = "p";
        Object[] args = {letter, message};
        String output = getMethodOutput("findLetter", args);
        String expect = "2";

        boolean passed = getResults(expect, output, "findLetter(\"p\",\"Apples and Oranges\")");
        assertTrue(passed);
    }

    @Test
    public void tryfindLetter2() throws IOException
    {
        String message = "Test strings";
        String letter = "s";
        Object[] args = {letter, message};
        String output = getMethodOutput("findLetter", args);
        String expect = "3";

        boolean passed = getResults(expect, output, "findLetter(\"s\",\"Test strings\")");
        assertTrue(passed);
    }

    @Test
    public void test2()
    {
        boolean passed =
                checkCodeContains(
                        "changed return type of findLetter",
                        "public int findLetter(String letter, String text)");
        assertTrue(passed);
    }

    @Test
    public void test1()
    {
        boolean passed = checkCodeContains("variable count set to 0", "int count = 0;");
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String code = removeSpaces(getCode());
        boolean passed =
                code.contains("count++;")
                        || code.contains("count=count+1;")
                        || code.contains("count=1+count;")
                        || code.contains("count+=1;")
                        || code.contains("++count;");
        passed =
                getResults(
                        "count incremented",
                        Boolean.toString(passed),
                        "Count incremented?",
                        passed);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Coding Challenge : Class Pet</title>
            <image source="Unit3-Class-Creation/Figures/animalclinic.png" width="27%%" alt="Animal Clinic"/>
            <p>You’ve been hired to create a software system for the Awesome Animal Clinic! They would like to keep track of their animal patients. Here are some attributes of the pets that they would like to track:</p>
            <p><ul>
                <li>
                    <p>Name</p>
                </li>
                <li>
                    <p>Age</p>
                </li>
                <li>
                    <p>Weight</p>
                </li>
                <li>
                    <p>Type (dog, cat, lizard, etc.)</p>
                </li>
                <li>
                    <p>Breed</p>
                </li>
            </ul></p>
            <p><ol marker="1">
                <li>
                    <p>Create a class that keeps track of the attributes above for pet records at
                        the animal clinic. Decide what instance variables are needed and their data
                        types. Make sure you use <c>int</c>, <c>double</c>, and <c>String</c> data types. Make
                        the instance variables <c>private</c>.</p>
                </li>
                <li>
                    <p>Create a constructor with many parameters to initialize all the instance
                        variables.</p>
                </li>
                <li>
                    <p>Create accessor/getter methods for each of the instance variables.</p>
                </li>
                <li>
                    <p>Create a <c>toString</c> method that returns all the information in a <c>Pet</c>.</p>
                </li>
                <li>
                    <p>Create mutator/setter methods for each of the instance variables.</p>
                </li>
                <li>
                    <p>In the <c>main</c> method below, create 2 <c>Pet</c> objects with different values
                        and call the constructor, accessor methods, mutator methods, and <c>toString</c> methods to test all your code.</p>
                </li>
            </ol></p>

<exercise label="challenge-Pet-Class">
    <statement>
            <p>Create a Pet class that keeps track of the name, age, weight, type of animal,
                and breed for records at an animal clinic. Create a constructor, getter, setter, and toString() methods. Create 2 Pet objects in the main method and test all your methods.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
/**
 * Pet class (complete comments)
 *
 * @author
 * @since
 */
class Pet
{
    // Instance Variables for the name, age, weight, type of animal, and breed of the pet

    // Write a constructor, accessor (get) methods, mutator (set) methods)
    // and a toString method. Use good commenting.

    // Don't forget to complete the main method in the TesterClass below!
}

public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        // Create 2 Pet objects and test all your methods

    }
}
</code><tests>
 import static org.junit.Assert.*;

 import org.junit.*;

 import java.io.*;

 public class RunestoneTests extends CodeTestHelper
 {
     public RunestoneTests()
     {
         super("TesterClass");
     }

     @Test
     public void testConstructors()
     {
         changeClass("Pet");
         int count = 0;

         for (int i = 0; i &lt; 6; i++)
         {
             if (checkConstructor(i).equals("pass")) count++;
         }

         boolean passed = count &gt;= 1;

         getResults("2+", "" + count, "Checking for constructor", passed);
         assertTrue(passed);
     }

     @Test
     public void testPrivateVariables()
     {
         changeClass("Pet");
         String expect = "5 Private";
         String output = testPrivateInstanceVariables();

         boolean passed = getResults(expect, output, "Checking Private Instance Variables");
         assertTrue(passed);
     }

     @Test
     public void test1()
     {
         String code = getCode();
         String target = "public * get*()";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking accessor (get) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test3()
     {
         String target = "public String toString()";
         boolean passed = checkCodeContains("toString() method", target);
         assertTrue(passed);
     }

     @Test
     public void testSet()
     {
         String code = getCode();
         String target = "public void set*(*)";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking mutator (set) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test4()
     {
         String code = getCode();
         String target = "Pet * = new Pet(";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 2;

         getResults("2", "" + num, "Checking main method creates 2 Pet objects", passed);
         assertTrue(passed);
     }

     @Test
     public void testMain()
     {
         String output = getMethodOutput("main");

         String expect = "2+ line(s) of text";
         String actual = " line(s) of text";

         int len = output.split("\n").length;

         if (output.length() &gt; 0)
         {
             actual = len + actual;
         }
         else
         {
             actual = output.length() + actual;
         }
         boolean passed = len &gt;= 2;

         getResults(expect, actual, "Checking main method prints info for 2 Pet objects", passed);
         assertTrue(passed);
     }
 }
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Design a Class for your Community</title>
            <p>In last lessons, you came up with a class of your own choice relevant to your community.</p>
            <p><ol marker="1">
                <li>
                    <p>Copy your class with its 3 instance variables, constructor, and its print() and main methods from <url href="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community" visual="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community">lesson 3.4</url> into the active code exercise below.</p>
                </li>
                <li>
                    <p>Create accessor (get) methods and mutator (set) methods for each of the instance variables.</p>
                </li>
                <li>
                    <p>Create a <c>toString</c> method that returns all the information in the instance variables.</p>
                </li>
                <li>
                    <p>Write an additional method for your class that takes a parameter. For example, there could be a print method with arguments that indicate how you want to print out the information, e.g. <c>print(format)</c> could print the data according to an argument that is “plain” or “table” where the data is printed in a table drawn with dashes and lines (<c>|</c>). Or come up with another creative method for your class.</p>
                </li>
                <li>
                    <p>Use these methods in the main method to test them. Make sure you use good commenting.</p>
                </li>
            </ol></p>

<exercise label="community-challenge3">
    <statement>
            <p>Copy your class from <url href="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community" visual="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community">lesson 3.4</url>. Add get, set, toString, and a method that takes a parameter. For example, there could be a print method with arguments that indicate how you want to print out the information, print(format) where format is “plain” or “table”.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class          // Add your class name here!
{
    // 1. Copy your class instance variables, constructor, and print()

    // 2. Create accessor (get) and mutator (set) methods for each of the instance variables.

    // 3. Create a toString() method that returns all the information in the instance variables.
    // 4.  Add a method for your class that takes a parameter.
    // For example, there could be a print method with arguments that indicate
    // how you want to print out the information, print(format) where format is "plain" or "table".

    // 5. Test all the methods in the main method.
    public static void main(String[] args)
    {
       // Construct an object of your class


       // call the object's methods

    }
}
</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testPrivateVariables()
    {
        String expect = "3 Private";
        String output = testPrivateInstanceVariables();
        boolean passed = false;
        if (Integer.parseInt(expect.substring(0, 1)) &lt;= Integer.parseInt(output.substring(0, 1)))
            passed = true;
        passed = getResults(expect, output, "Checking private instance variable(s)", passed);
        assertTrue(passed);
    }

    /* @Test
    public void testDefaultConstructor()
    {
        String output = checkDefaultConstructor();
        String expect = "pass";

        boolean passed = getResults(expect, output, "Checking default constructor");
        assertTrue(passed);
    } */

    @Test
    public void testConstructor3()
    {
        String output = checkConstructor(3);
        String expect = "pass";

        boolean passed = getResults(expect, output, "Checking constructor with 3 parameters");
        assertTrue(passed);
    }

    @Test
    public void testPrint()
    {
        String output = getMethodOutput("print");
        String expect = "More than 15 characters";
        String actual = " than 15 characters";

        if (output.length() &lt; 15)
        {
            actual = "Less" + actual;
        }
        else
        {
            actual = "More" + actual;
        }
        boolean passed = getResults(expect, actual, "Checking print method");
        assertTrue(passed);
    }

    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main"); // .split("\n");
        String expect = "3+ line(s) of text";
        String actual = " line(s) of text";
        int len = output.split("\n").length;

        if (output.length() &gt; 0)
        {
            actual = len + actual;
        }
        else
        {
            actual = output.length() + actual;
        }
        boolean passed = len &gt;= 3;

        getResults(expect, actual, "Checking output", passed);
        assertTrue(passed);
    }

    @Test
    public void test1()
    {
        String code = getCode();
        String target = "public * get*()";

        int num = countOccurencesRegex(code, target);

        boolean passed = num &gt;= 3;

        getResults("3", "" + num, "Checking accessor (get) methods for each variable", passed);
        assertTrue(passed);
    }

    @Test
    public void test2()
    {
        String code = getCode();
        String target = "public void set*(*)";

        int num = countOccurencesRegex(code, target);

        boolean passed = num &gt;= 3;

        getResults("3", "" + num, "Checking mutator (set) methods for each variable", passed);
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String target = "public String toString()";
        boolean passed = checkCodeContains("toString() method", target);
        assertTrue(passed);
    }

    @Test
    public void testPrintFormat()
    {
        String target = "public void print(String";
        boolean passed = checkCodeContains("print method with String argument", target);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>(AP 3.5.A.1) A <c>void</c> method does not return a value. Its header contains the keyword <c>void</c> before the method name.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.2)  A <term>non-void method</term> returns a single value. Its header includes the return type in place of the keyword <c>void</c>.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.3) In non-void methods, a return expression compatible with the return type is evaluated, and the value is returned. This is referred to as <term>return by value</term>.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.4) The <c>return</c> keyword is used to return the flow of control to the point where the method or constructor was called. Any code that is sequentially after a return statement will never be executed. Executing a return statement inside a selection or iteration statement will halt the statement and exit the method or constructor.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.5) An <term>accessor method</term> (getter) allows objects of other classes to obtain a copy of the value of instance variables or class variables. An accessor method is a non-void method.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.6) A <term>mutator (modifier) method</term> (setter) is a method that changes the values of the instance variables or class variables. A mutator method is often a void method.</p>
                </li>
                <li>
                    <p>Comparison of accessor/getters and mutator/setters syntax:</p>
                </li>
            </ul></p>
            <figure align="center"><image source="Unit3-Class-Creation/Figures/get-set-comparison.png" width="100%%"/></figure>
            <p><ul>
                <li>
                    <p>(AP 3.5.A.7) Methods with parameters receive values through those parameters and use those values in accomplishing the method’s task.</p>
                </li>
                <li>
                    <p>(AP 3.5.A.8)  When an argument is a primitive value, the parameter is initialized with a copy of that value. Changes to the parameter have no effect on the corresponding argument.</p>
                </li>
                <li>
                    <p>The <c>toString</c> method is an overridden method that is included in classes to
                        provide a description of a specific object. It generally includes what values
                        are stored in the instance data of the object. If <c>System.out.print</c> or <c>System.out.println</c> is passed an object, that
                        object’s <c>toString</c> method is called, and the returned <c>String</c> is
                        printed. An object’s <c>toString</c> method is also used to get the <c>String</c>
                        representation when concatenating the object to a <c>String</c> with the
                        <c>+</c> operator.</p>
                </li>
            </ul></p>

<exercise label="AccessorMutator">
    <statement><p>Drag the definition from the left and drop it on the correct word on the right.  Click the "Check Me" button to see if you are correct.</p></statement>
    <feedback><p>Review the vocabulary.</p></feedback>
<matches><match order="1"><premise>gets and returns the value of an instance variable</premise><response>accessor method</response></match><match order="2"><premise>sets the instance variable to a value in its parameter</premise><response>mutator method</response></match><match order="3"><premise>initializes the instance variables to values</premise><response>constructor</response></match><match order="4"><premise>accessible from outside the class</premise><response>public</response></match><match order="5"><premise>accessible only inside the class</premise><response>private</response></match></matches></exercise>        </subsection>
  <subsection>
            <title>AP Practice</title>

    <exercise label="AP-get1">
        <statement>

            <p>  Consider the following Party class. The getNumOfPeople method is intended to allow methods in other classes to access a Party object’s numOfPeople instance variable value; however, it does not work as intended. Which of the following best explains why the getNumOfPeople method does NOT work as intended?</p>
            <blockquote>
                <program language="java"><code>
public class Party
{
    private int numOfPeople;

    public Party(int num)
    {
        numOfPeople = num;
    }

    private int getNumOfPeople()
    {
        return numOfPeople;
    }
}
</code></program>
            </blockquote>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>The getNumOfPeople method should be declared as public.</p>
                </statement>
                <feedback>
                    <p>Correct, accessor methods should be public so they can be accessed from outside the class.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The return type of the getNumOfPeople method should be void.</p>
                </statement>
                <feedback>
                    <p>The method return type should stay as int.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The getNumOfPeople method should have at least one parameter.</p>
                </statement>
                <feedback>
                    <p>This method should not have any parameters</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The variable numOfPeople is not declared inside the getNumOfPeople method.</p>
                </statement>
                <feedback>
                    <p>This is an instance variable and should be declared outside.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The instance variable num should be returned instead of numOfPeople,  which is local to the constructor.</p>
                </statement>
                <feedback>
                    <p>The numOfPeople variable is correctly returned.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="AP-get2">
        <statement>

            <p> Consider the following class definition. The class does not compile.</p>
            <program language="java"><code>
public class Student
{
    private int id;

    public getId()
    {
        return id;
    }
    // Constructor not shown
}
</code></program>
            <p>The accessor method getId is intended to return the id of a Student object. Which of the following best explains why the class does not compile?</p>
</statement><choices><choice><statement id="AP-get2_opt_a">            <p>The id instance variable should be public.</p>
</statement><feedback id="AP-get2_opt_a">
            <p>Instance variables should be private.</p>
</feedback></choice><choice><statement id="AP-get2_opt_b">            <p>The getId method should be declared as private.</p>
</statement><feedback id="AP-get2_opt_b">
            <p>Accessor methods should be public methods.</p>
</feedback></choice><choice><statement id="AP-get2_opt_c">            <p>The getId method requires a parameter.</p>
</statement><feedback id="AP-get2_opt_c">
            <p>Accessor methods usually do not require parameters.</p>
</feedback></choice><choice><statement id="AP-get2_opt_d">            <p>The return type of the getId method needs to be defined as void.</p>
</statement><feedback id="AP-get2_opt_d">
            <p>void is not the correct return type.</p>
</feedback></choice><choice correct="yes"><statement id="AP-get2_opt_e">            <p>The return type of the getId method needs to be defined as int.</p>
</statement><feedback id="AP-get2_opt_e">
            <p>Correct! Accessor methods have a return type of the instance variable they are returning.</p>
</feedback></choice></choices>

    </exercise>

    <exercise label="AP-mutator1">
        <statement>

            <p> Consider the following class definition.</p>
            <program language="java"><code>
public class Liquid
{
    private int currentTemp;

    public Liquid(int temp)
    {
        currentTemp = temp;
    }

    public void resetTemp()
    {
        currentTemp = newTemp;
    }
}
</code></program>
            <p>Which of the following best identifies the reason the class does not compile?</p>
</statement><choices><choice><statement id="AP-mutator1_opt_a">            <p>The constructor header does not have a return type.</p>
</statement><feedback id="AP-mutator1_opt_a">
            <p>The constructor should not have a return type.</p>
</feedback></choice><choice><statement id="AP-mutator1_opt_b">            <p>The resetTemp method is missing a return type.</p>
</statement><feedback id="AP-mutator1_opt_b">
            <p>Mutator methods usually have a void return type.</p>
</feedback></choice><choice><statement id="AP-mutator1_opt_c">            <p>The constructor should not have a parameter.</p>
</statement><feedback id="AP-mutator1_opt_c">
            <p>Constructors can have parameters.</p>
</feedback></choice><choice correct="yes"><statement id="AP-mutator1_opt_d">            <p>The resetTemp method should have a parameter.</p>
</statement><feedback id="AP-mutator1_opt_d">
            <p>Correct! The resetTemp method should have a parameter for the newTemp value to set the currentTemp.</p>
</feedback></choice><choice><statement id="AP-mutator1_opt_e">            <p>The instance variable currentTemp should be public instead of private.</p>
</statement><feedback id="AP-mutator1_opt_e">
            <p>Instance variables should be private variables.</p>
</feedback></choice></choices>

    </exercise>

    <exercise label="AP-mutator2">
        <statement>

            <p> In the <c>Party</c> class below, the <c>addPeople</c> method is intended to increase the value of the instance variable <c>numOfPeople</c> by the value of the parameter <c>additionalPeople</c>. The method does not work as intended.</p>
            <program language="java"><code>
public class Party
{
    private int numOfPeople;

    public Party(int n)
    {
        numOfPeople = n;
    }

    public int addPeople(int additionalPeople) // Line 10
            {
        numOfPeople += additionalPeople; // Line 12
    }
}
</code></program>
            <p>Which of the following changes should be made so that the class definition compiles without error and the method <c>addPeople</c> works as intended?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Replace line 12 with numOfPeople = additionalPeople;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 12 with return additionalPeople;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 12 with additionalPeople += 3;</p>
                </statement>
                <feedback>
                    <p>This method should add additionalPeople to numOfPeople.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Replace line 10 with public addPeople (int additionalPeople)</p>
                </statement>
                <feedback>
                    <p>Mutator methods should have a void return type.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Replace line 10 with public void addPeople(int additionalPeople)</p>
                </statement>
                <feedback>
                    <p>Mutator methods should have a void return type.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
        </subsection>
</section>
