<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="topic-3-5-methods">
  <time minutes="90" />
  <title>Methods: How to Write Them</title>
  <introduction>
    <idx>method</idx>
    <idx>return</idx>
    <idx>parameter</idx>
    <idx>argument</idx>
    <idx>abstraction</idx>
    <idx>
      <h>method</h><h>parameter</h>
    </idx>

    <idx>
      <h>method</h><h>argument</h>
    </idx>

    <idx>
      <h>method</h><h>return</h>
    </idx>

    <idx>void method</idx>
    <idx>non-void method</idx>
    <idx>accessor method</idx>
    <idx>getter</idx>
    <idx>mutator method</idx>
    <idx>setter</idx>
    <p>
      In object-oriented programming, the three main parts of a class are:
    </p>

    <p>
      <ul>
        <li>
          <p>
            the <term>instance variables</term> which hold attributes or values
            associated with each object,
          </p>
        </li>

        <li>
          <p>
            the <term>constructors</term> whose job is to initialize the
            instance variables,
          </p>
        </li>

        <li>
          <p>
            and the <term>methods</term> which contain the code for the
            behaviors of an object and which can use the instance variables
            defined in the class.
          </p>
        </li>
      </ul>
    </p>

    <p>
      In Unit 1, we used <c>Turtle</c> objects and called methods like
      <c>forward</c> which changed the <c>x</c> and <c>y</c> coordinates
      (instance variables) of the turtle. We also defined static methods that
      did not work with objects. In this unit, we will learn how to write our
      own methods in our own classes.
    </p>
  </introduction>

  <subsection xml:id="defining-and-calling-methods">
    <title>Defining and Calling Methods</title>
    <p>
      A <term>method</term> is a block of code that performs a specific task.
      Methods are defined inside a class and can access the instance variables
      of the class. For example, the print() method below prints the instance
      variables of the Person class. Methods are usually public.
    </p>

    <program language="java">
      <code>
public class Person
{
    // instance variables
    private String name;
    private String email;

    // Method definition: uses instance variables name and email
    public void print()
    {
        System.out.println("Name: " + name);
        System.out.println("Email: " + email);
    }

    public static void main(String[] args)
    {
        Person p = new Person();
        p.print();  // Method call
    }
}
      </code>
    </program>

    <p>There are three steps to creating and calling a method:</p>
    <p>
      <ol marker="1">
        <li>
          <p>
            <term>Object of the Class</term>: Declare an object of your class in
            the main method or from outside the class.
          </p>

          
            <program language="java">
              <code>
// Step 1: declare an object in main or from outside the class
Classname objectName = new Classname();
              </code>
            </program>

        </li>

        <li>
          <p>
            <term>Method Call</term>: whenever you want to use the method, call
            objectName.methodName();
          </p>


            <program language="java">
              <code>
// Step 2: call the object's method
objectName.methodName(); //Step 2
              </code>
            </program>

        </li>

        <li>
          <p>
            <term>Method Definition</term>: write the method’s
            <term>header</term> and <term>body</term> code like below:
          </p>


            <program language="java">
              <code>
// Step 3: Define the method in the class
// method header
public void methodName()
{
      // method body for the code
}
              </code>
            </program>

        </li>
      </ol>
    </p>

    <p>
      The following flowchart can be used to compare three different ways of
      calling methods. Class (static) methods are called using the class name.
      Instance methods which are discussing in this lesson are called using an
      object of the class. If you are calling the instance method from the main
      method or from another class, you must first create an object of that
      class and then call its methods using <c>object.methodName()</c>. If you
      are calling the method from within the same class, you can just call the
      method using <c>methodName()</c> which will refer to the current object.
    </p>

    <figure align="center">
      <caption>Comparing Method Calls to Static and Instance Methods</caption>
      <image source="Unit3-Class-Creation/Figures/FlowChartCallingMethods.png" width="98%" alt="Comparing method calls to static and instance methods" />
    </figure>

    <activity label="PersonPrint">
      <statement>
        <p>
          Try the following code. Add a print() method in the Person class that
          prints out all the attributes (name, email, phonenumber) of a person
          object.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class Person
{
    // instance variables
    private String name;
    private String email;
    private String phonenumber;

    // Constructor
    public Person(String n, String e, String p)
    {
        name = n;
        email = e;
        phonenumber = p;
    }

    // TODO: Add a print() method that prints out all the attributes (name, email, phonenumber)


    public static void main(String[] args)
    {
        Person p1 = new Person("Taylor", "swift@gmail.com", "123-456-7890");
        p1.print();
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void test1()
    {
        String target = "public void print()";
        boolean passed = checkCodeContains("public void print() method", target);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="void-methods">
    <title>void Methods</title>
    <p>
      A <term>void method</term> is a method that does not return a value. It is
      used when you want to perform an action but do not need to return a value.
      The method header for a void method looks like this:
    </p>

    <program language="java">
      <code>
public void methodName()
{
    // method body
}
      </code>
    </program>

    <p>
      The <c>print</c> method above is a void method. It does not return a
      value, but it does print out the name and email of the person. In the
      sections below, we will learn about setter methods that are also void
      methods.
    </p>
  </subsection>

  <subsection xml:id="non-void-methods-1">
    <title>Non-void Methods</title>
    <p>
      A <term>non-void method</term> is a method that returns a single value.
      Its body must have a <term>return</term> statement, usually at the end,
      that returns a variable’s value or an expression. Its header includes the
      <term>return type</term> (the type of the value in the return statement)
      in place of the keyword <c>void</c>. The method header for a non-void
      method looks like this:
    </p>

    <program language="java">
      <code>
public returnType methodName()
{
    // method body
    return value;
}
      </code>
    </program>

    <p>
      In Unit 1, we used static non-void methods like `` Math.random()`` which
      returned a random number. We also used non-void methods that belonged to
      Turtle objects like <c>getXPos()</c> and <c>getYPos()</c> that returned
      the x and y coordinates of the turtle. The most common non-void methods in
      Java are methods that start with <c>get</c> and return the value of an
      instance variable. We will learn about these in the next section.
    </p>

    <p>
      In non-void methods, a return expression compatible with the return type
      is evaluated, and the value is returned. This is referred to as
      <term>return by value</term>. The <c>return</c> keyword is used to return
      the flow of control to the point where the method or constructor was
      called. Any code that is sequentially after a return statement will never
      be executed, so usually non-void methods end with a return statement.
      Executing a return statement inside a selection or iteration statement
      will halt the statement and exit the method or constructor.
    </p>

    <note>
      <p>Some common errors when writing and using non-void methods are:</p>
      <p>
        <ul>
          <li>
            <p>
              Forgetting a return type like <c>int</c> before the method name.
            </p>
          </li>

          <li>
            <p>
              Forgetting to use the <c>return</c> keyword to return a value at
              the end of the method.
            </p>
          </li>

          <li>
            <p>
              Returning too soon from a method. If you have a return statement
              in a selection or iteration statement, the method will exit at
              that point and not execute the rest of the code.
            </p>
          </li>

          <li>
            <p>
              Forgetting to do something with the value returned from a method,
              like assigning it to a variable or printing it out.
            </p>
          </li>
        </ul>
      </p>
    </note>
  </subsection>

  <subsection xml:id="accessors-getters">
    <title>Accessors / Getters</title>
    <p>
      Since the instance variables in a class are usually marked as
      <c>private</c> to the class, if you want code outside the class to be able
      to access the value of an instance variable, you need to write what is
      formally called an <term>accessor methods</term> but which everyone
      actually just calls a <term>getter</term>. A getter is a <c>public</c>
      method that takes no arguments and returns the value of the <c>private</c>
      instance variable.
    </p>

    <p>
      If you used a language like App Inventor in an AP CSP class, you may have
      used setter and getter blocks. In App Inventor, you cannot make your own
      classes, but you can declare UI objects like Button1, Button2 from the
      Button class and use their get/set methods for any property like below.
      (We’ll talk about setters in Java in the next section.)
    </p>

    <figure align="center">
      <caption>App Inventor Set and Get blocks for object Button1</caption>
      <image source="Unit3-Class-Creation/Figures/AppInvSetGet.png" width="54%" />
    </figure>

    <p>
      You don’t need to write a getter for every instance variable in a class
      but if you want code outside the class to be able to get the value of one
      of your instance variables, you’ll need to write a getter that looks like
      the following.
    </p>

    <program language="java">
      <code>
class ExampleTemplate
{

    // Instance variable declaration
    private typeOfVar varName;

    // Accessor (getter) method template
    public typeOfVar getVarName()
    {
        return varName;
    }
}
      </code>
    </program>

    <p>
      Notice that the getter’s return type is the same as the type of the
      instance variable and all the body of the getter does is return the value
      of the variable using a <c>return</c> statement. We’ll talk more about
      the <c>return</c> statement in the next lesson, but for now just notice that it
      is followed by an expression whose value must be the same type as the
      return type in the method’s header. In a getter, that will definitely be
      true as long as the type of the instance variable and the return type of
      the getter are the same.
    </p>

    <p>
      Here’s an example of an accessor method called <c>getName</c> for the
      <c>Student</c> class which also demonstrates how to call <c>getName</c>
      using a <c>Student</c> object:
    </p>

    <program language="java">
      <code>
class Student
{

  //Instance variable name
  private String name;

  /** getName() example
   *  @return name */
  public String getName()
  {
     return name;
  }

  public static void main(String[] args)
  {
     // To call a get method, use objectName.getVarName()
     Student s = new Student();
     System.out.println("Name: " + s.getName() );
  }
      </code>
    </program>

    <p>
      Note, that getters only return the <em>value</em> of the variable.
    </p>

    <p>
      Try the following code. Note that this active code window has 2 classes!
      The main method is in a separate <term>Tester</term> or
      <term>Driver</term> class. It does not have access to the private instance
      variables in the other Student class. Note that when you use multiple
      classes in an IDE, you usually put them in separate files, and you give
      the files the same name as the public class in them. In active code and
      IDEs, you can put 2 classes in 1 file, as demonstrated here, but only 1 of
      them can be public and have a main method in it. You can also view the
      fixed code in the <url
      href="http://www.pythontutor.com/visualize.html#code=public%20class%20TesterClass%20%0A%20%20%7B%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20Student%20s1%20%3D%20new%20Student%28%22Skyler%22,%20%22skyler%40sky.com%22,%20123456%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Name%3A%22%20%2B%20%20s1.getName%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Email%3A%22%20%2B%20%20s1.getEmail%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22ID%3A%20%22%20%2B%20s1.getId%28%29%20%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%7D%0A%20%20%0A%20%20class%20Student%20%0A%20%20%7B%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20int%20id%3B%0A%20%20%20%20%20%0A%20%20%20%20%20public%20Student%28String%20initName,%20String%20initEmail,%20int%20initId%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20id%20%3D%20initId%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20accessor%20methods%20-%20getters%20%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20name%20*/%0A%20%20%20%20%20public%20String%20getName%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20name%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getEmail%28%29%20%20%40return%20email%20*/%0A%20%20%20%20%20public%20String%20getEmail%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20email%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20id%20*/%0A%20%20%20%20%20public%20int%20getId%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20id%3B%0A%20%20%20%20%20%7D%0A%20%20%7D&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"
      visual="http://www.pythontutor.com/visualize.html#code=public%20class%20TesterClass%20%0A%20%20%7B%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20Student%20s1%20%3D%20new%20Student%28%22Skyler%22,%20%22skyler%40sky.com%22,%20123456%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Name%3A%22%20%2B%20%20s1.getName%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Email%3A%22%20%2B%20%20s1.getEmail%28%29%20%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22ID%3A%20%22%20%2B%20s1.getId%28%29%20%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%7D%0A%20%20%0A%20%20class%20Student%20%0A%20%20%7B%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20int%20id%3B%0A%20%20%20%20%20%0A%20%20%20%20%20public%20Student%28String%20initName,%20String%20initEmail,%20int%20initId%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20id%20%3D%20initId%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20accessor%20methods%20-%20getters%20%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20name%20*/%0A%20%20%20%20%20public%20String%20getName%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20name%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getEmail%28%29%20%20%40return%20email%20*/%0A%20%20%20%20%20public%20String%20getEmail%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20email%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20/**%20getName%28%29%20%20%40return%20id%20*/%0A%20%20%20%20%20public%20int%20getId%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20return%20id%3B%0A%20%20%20%20%20%7D%0A%20%20%7D&amp;cumulative=false&amp;curInstr=26&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url>.
    </p>

    <activity label="StudentObjExample">
      <statement>
        <p>
          Try the following code. Note that it has a bug! It tries to access the
          private instance variable email from outside the class Student. Change
          the main method in Tester class so that it uses the appropriate public
          accessor method (get method) to access the email value instead.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println("Name:" + s1.getName());
        // Fix the bug here!
        System.out.println("Email:" + s1.email);
        System.out.println("ID: " + s1.getId());
    }
}

/** Class Student keeps track of name, email, and id of a Student. */
class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // accessor methods - getters
    /** getName() @return name */
    public String getName()
    {
        return name;
    }

    /** getEmail() @return email */
    public String getEmail()
    {
        return email;
    }

    /** getName() @return id */
    public int getId()
    {
        return id;
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main");
        String expect = "Name:Skyler\nEmail:skyler@sky.com\nID: 123456";
        boolean passed = getResults(expect, output, "Checking for expected output");
        assertTrue(passed);
    }

    @Test
    public void testMethodCall() throws IOException
    {
        String target = "s1.getEmail()";
        boolean passed = checkCodeContains("call to accessor method for email", target);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="tostring">
    <title>
      <c>toString</c>
    </title>

    <p>
      While not strictly speaking a getter, another important method that
      returns a value is the <c>toString</c> method. This method is called
      automatically by Java in a number of situations when it needs to convert
      an object to a <c>String</c>. Most notably the methods
      <c>System.out.print</c> and <c>System.out.println</c> use it to convert a
      object argument into a <c>String</c> to be printed and when objects are
      added to <c>String</c>s with <c>+</c> and <c>+=</c> their <c>String</c>
      representation comes from calling their <c>toString</c> method.
    </p>

    <p>
      Here is the <c>Student</c> class again, but this time with a
      <c>toString</c> method. Note that when we call
      <c>System.out.println(s1)</c> it will automatically call the
      <c>toString</c> method to get a <c>String</c> representation of the
      <c>Student</c> object. The <c>toString</c> method will return a
      <c>String</c> that is then printed out. Watch how the control moves to the
      <c>toString</c> method and then comes back to <c>main</c> in the Java
      visualizer by using the Show CodeLens button.
    </p>

    <activity label="StudentToString">
      <statement>
        <p>
          See the toString() method in action. Add another student object and
          print it out.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println(s1);
        // TODO: add another student s2 and print it out


    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // toString() method
    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void test1() throws IOException
    {
        String target = "System.out.println(s2)";
        boolean passed = checkCodeContains("System.out.println(s2)", target);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="mutators-setters">
    <title>Mutators / Setters</title>
    <p>
      In complement to the accessor/getter methods, if we want to allow code
      outside the class to <title_reference>change</title_reference> the value
      of an instance variable we have to provide what is formally called a
      <term>mutator method</term> but which everyone actually calls a
      <term>setter</term>. A setter is a void method with a name that starts
      with <c>set</c> and that takes a single argument of the same type as the
      instance variable to be set. The effect of a setter, as you would probably
      expect, is to assign the provided value to the instance variable.
    </p>

    <p>
      Just as you shouldn’t reflexively write a getter for every instance
      variable, you should think even harder about whether you want to write a
      setter. Not all instance variables are meant to be manipulated directly by
      code outside the class.
    </p>

    <p>
      For example, consider the <c>Turtle</c> class. It provides getters
      <c>getXPos</c> and <c>getYPos</c> but it does not provide corresponding
      setters. There are, however, methods that change a <c>Turtle</c>’s
      position like <c>forward</c> and <c>moveTo</c>. But they do more than just
      changing the values of instance variables; they also take care of drawing
      lines on the screen if the pen is down. By not providing setters for those
      instance variables, the authors of the <c>Turtle</c> class can assume the
      a <c>Turtle</c>’s position won’t change other than by going through one of
      the approved movement methods. In general, you shouldn’t write a setter
      until you find a real reason to do so.
    </p>

    <p>
      Here are some examples of how to write a setter for an instance variable:
    </p>

    <program language="java">
      <code>
class ExampleTemplate
{
    // Instance variable declaration
    private typeOfVar varName;

    // Setter method template
    public void setVarName(typeOfVar newValue)
    {
        varName = newValue;
    }
}
      </code>
    </program>

    <p>
      Here’s an example of the <c>Student</c> class with a setter for the
      <c>name</c> variable:
    </p>

    <program language="java">
      <code>
class Student
{
    // Instance variable name
    private String name;

    /**
     * setName sets name to newName
     *
     * @param newName
     */
    public void setName(String newName)
    {
        name = newName;
    }

    public static void main(String[] args)
    {
        // To call a set method, use objectName.setVar(newValue)
        Student s = new Student();
        s.setName("Ayanna");
    }
}
      </code>
    </program>

    <p>
      Notice the difference between setters and getters in the following figure.
      Getters return an instance variable’s value and have the same return type
      as this variable and no parameters. Setters have a void return type and
      take a new value as a parameter to change the value of the instance
      variable.
    </p>

    <figure align="center">
      <caption>Comparison of setters and getters</caption>
      <image source="Unit3-Class-Creation/Figures/get-set-comparison.png" width="100%" />
    </figure>

    <p>
      Try the <c>Student</c> class below which has had some setters added.
      Notice that there is no <c>setId</c> method even though there is a
      <c>getId</c>. This is presumably because in the system this class is part
      of, while it makes sense for a student to change their name or email,
      their id should never change.
    </p>

    <p>
      You will need to fix one error. The <c>main</c> method is in a separate
      class <c>TesterClass</c> and does not have access to the <c>private</c>
      instance variables in the <c>`Student</c> class. Change the <c>main</c>
      method so that it uses a <c>public</c> setter to change the value instead.
    </p>

    <activity label="StudentObjExample2">
      <statement>
        <p>
          Fix the main method to include a call to the appropriate set method.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        Student s1 = new Student("Skyler", "skyler@sky.com", 123456);
        System.out.println(s1);
        s1.setName("Skyler 2");
        // Main doesn't have access to email, use set method!
        s1.email = "skyler2@gmail.com";
        System.out.println(s1);
    }
}

class Student
{
    private String name;
    private String email;
    private int id;

    public Student(String initName, String initEmail, int initId)
    {
        name = initName;
        email = initEmail;
        id = initId;
    }

    // Setters

    public void setName(String newName)
    {
        name = newName;
    }

    public void setEmail(String newEmail)
    {
        email = newEmail;
    }

    // Getters

    public String getName()
    {
        return name;
    }

    public String getEmail()
    {
        return email;
    }

    public int getId()
    {
        return id;
    }

    public String toString()
    {
        return id + ": " + name + ", " + email;
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

// activeCode StudentObjExample2
public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("TesterClass");
    }

    @Test
    public void test1()
    {
        String target = "s1.setEmail(\"skyler2@gmail.com\");";
        boolean passed = checkCodeContains("call to setEmail()", target);
        assertTrue(passed);
    }

    @Test
    public void testMain()
    {
        String output = getMethodOutput("main");
        String expect = "123456: Skyler, skyler@sky.com\n123456: Skyler 2, skyler2@gmail.com";

        boolean passed = getResults(expect, output, "Checking main()", true);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <activity label="setSignature">
      <statement>
        <p>
          Consider the class Party which keeps track of the number of people at
          the party.
        </p>

        <program language="java">
          <code>
public class Party
{
    // number of people at the party
    private int numOfPeople;

    /* Missing header of set method */
    {
        numOfPeople = people;
    }
}
          </code>
        </program>

        <p>
          Which of the following method signatures could replace the missing
          header for the set method in the code above so that the method will
          work as intended?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="setSignature_opt_a">
            <p>public int getNum(int people)</p>
          </statement>

          <feedback id="setSignature_opt_a">
            <p>
              The set method should not have a return value and is usually named
              set, not get.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="setSignature_opt_b">
            <p>public int setNum()</p>
          </statement>

          <feedback id="setSignature_opt_b">
            <p>
              The set method should not have a return value and needs a
              parameter.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="setSignature_opt_c">
            <p>public int setNum(int people)</p>
          </statement>

          <feedback id="setSignature_opt_c">
            <p>The set method should not have a return value.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="setSignature_opt_d">
            <p>public void setNum(int people)</p>
          </statement>

          <feedback id="setSignature_opt_d">
            <p>
              Yes, the set method should take a parameter called people and have
              a void return value. The name of the set method is usually set
              followed by the full instance variable name, but it does not have
              to be an exact match.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="setSignature_opt_e">
            <p>public int setNumOfPeople(int p)</p>
          </statement>

          <feedback id="setSignature_opt_e">
            <p>
              The parameter of this set method should be called people in order
              to match the code in the method body.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      Mutator methods do not have to have a name with “set” in it, although most
      do. They can be any methods that change the value of an instance variable
      in the class. Most mutator methods are non-void methods. Mutator methods
      do not have to have parameters, but they usually do.
    </p>
  </subsection>

  <subsection xml:id="parameters">
    <title>Parameters</title>
    <p>
      The setter methods above contained parameters. A <term>parameter</term> is
      a variable in a method’s header that is used to pass in data that the
      method needs to do its job. In a setter, the parameter is the new value
      that you want to assign to the instance variable. Methods with parameters
      receive values through those parameters and use those values in
      accomplishing the method’s task.
    </p>

    <p>
      An <term>argument</term> is a value that is passed into a method when the
      method is called. It is saved into a parameter variable. The arguments
      passed to a method must be compatible in number and order with the types
      identified in the parameter list of the method signature. When calling
      methods, arguments are passed using call by value. <term>Call by
      value</term> initializes the parameters with copies of the arguments. When
      an argument is a primitive value, the parameter is initialized with a copy
      of that value. Changes to the parameter have no effect on the
      corresponding argument.
    </p>

    <figure align="center">
      <caption>Method signatures with parameters and method calls arguments</caption>
      <image source="Unit3-Class-Creation/Figures/method-param-arg.png" width="98%" alt="Method parameters and arguments" />
    </figure>
  </subsection>

  <subsection xml:id="methods-with-parameters-that-return-calculated-values">
    <title>Methods with Parameters that Return Calculated values</title>
    <p>
      Not all methods that return values are accessor/get methods. Some methods
      have parameters and return values that are found or calculated in a more
      complex algorithm. The following method uses a loop to find a letter in a
      text string given as a parameter. It returns true if the letter is found
      and false otherwise. Change it to return the count of how many times the
      letter is found in the text instead.
    </p>

    <activity label="StringFind">
      <statement>
        <p>
          Run the following program which contains a method called findLetter
          that takes a letter and a text as parameters and uses a loop to see if
          that letter is in the text and returns true if it is, false otherwise.
          Set the variables <c>letter</c> and <c>message</c> to new values in
          the main method and run it again to try finding a different letter.
          Then, change the code of the findLetter method to return how many
          times it finds letter in text, using a new variable called
          <c>count</c>. How would the return type change?
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class StringFind
{
    /**
     * findLetter looks for a letter in a String
     *
     * @param String letter to look for
     * @param String text to look in
     * @return boolean true if letter is in text 
     * After running the code, change this method 
     * to return an int count of how many times letter is in 
     * the text.
     */
    public boolean findLetter(String letter, String text)
    {
        boolean flag = false;
        for (int i = 0; i &lt; text.length(); i++)
        {
            if (text.substring(i, i + 1).equalsIgnoreCase(letter))
            {
                flag = true;
            }
        }
        return flag;
    }

    public static void main(String args[])
    {
        StringFind test = new StringFind();
        String message = "Apples and Oranges";
        String letter = "p";
        System.out.println("Does " + message + " contain a " + letter + "?");
        System.out.println(test.findLetter(letter, message));
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void tryfindLetter() throws IOException
    {
        String message = "Apples and Oranges";
        String letter = "p";
        Object[] args = {letter, message};
        String output = getMethodOutput("findLetter", args);
        String expect = "2";

        boolean passed = getResults(expect, output, "findLetter(\"p\",\"Apples and Oranges\")");
        assertTrue(passed);
    }

    @Test
    public void tryfindLetter2() throws IOException
    {
        String message = "Test strings";
        String letter = "s";
        Object[] args = {letter, message};
        String output = getMethodOutput("findLetter", args);
        String expect = "3";

        boolean passed = getResults(expect, output, "findLetter(\"s\",\"Test strings\")");
        assertTrue(passed);
    }

    @Test
    public void test2()
    {
        boolean passed =
                checkCodeContains(
                        "changed return type of findLetter",
                        "public int findLetter(String letter, String text)");
        assertTrue(passed);
    }

    @Test
    public void test1()
    {
        boolean passed = checkCodeContains("variable count set to 0", "int count = 0;");
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String code = removeSpaces(getCode());
        boolean passed =
                code.contains("count++;")
                        || code.contains("count=count+1;")
                        || code.contains("count=1+count;")
                        || code.contains("count+=1;")
                        || code.contains("++count;");
        passed =
                getResults(
                        "count incremented",
                        Boolean.toString(passed),
                        "Count incremented?",
                        passed);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-class-pet">
    <title>Coding Challenge : Class Pet</title>
    <image source="Unit3-Class-Creation/Figures/animalclinic.png" width="27%" alt="Animal Clinic" />
    <p>
      You’ve been hired to create a software system for the Awesome Animal
      Clinic! They would like to keep track of their animal patients. Here are
      some attributes of the pets that they would like to track:
    </p>

    <p>
      <ul>
        <li>
          <p>Name</p>
        </li>

        <li>
          <p>Age</p>
        </li>

        <li>
          <p>Weight</p>
        </li>

        <li>
          <p>Type (dog, cat, lizard, etc.)</p>
        </li>

        <li>
          <p>Breed</p>
        </li>
      </ul>
    </p>

    <p>
      <ol marker="1">
        <li>
          <p>
            Create a class that keeps track of the attributes above for pet
            records at the animal clinic. Decide what instance variables are
            needed and their data types. Make sure you use <c>int</c>,
            <c>double</c>, and <c>String</c> data types. Make the instance
            variables <c>private</c>.
          </p>
        </li>

        <li>
          <p>
            Create a constructor with many parameters to initialize all the
            instance variables.
          </p>
        </li>

        <li>
          <p>
            Create accessor/getter methods for each of the instance variables.
          </p>
        </li>

        <li>
          <p>
            Create a <c>toString</c> method that returns all the information in
            a <c>Pet</c>.
          </p>
        </li>

        <li>
          <p>
            Create mutator/setter methods for each of the instance variables.
          </p>
        </li>

        <li>
          <p>
            In the <c>main</c> method below, create 2 <c>Pet</c> objects with
            different values and call the constructor, accessor methods, mutator
            methods, and <c>toString</c> methods to test all your code.
          </p>
        </li>
      </ol>
    </p>

    <project label="challenge-Pet-Class">
      <statement>
        <p>
          Create a Pet class that keeps track of the name, age, weight, type of
          animal, and breed for records at an animal clinic. Create a
          constructor, getter, setter, and toString() methods. Create 2 Pet
          objects in the main method and test all your methods.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
/**
 * Pet class (complete comments)
 *
 * @author
 * @since
 */
class Pet
{
    // Instance Variables for the name, age, weight, type of animal, and breed of the pet

    // Write a constructor, accessor (get) methods, mutator (set) methods)
    // and a toString method. Use good commenting.

    // Don't forget to complete the main method in the TesterClass below!
}

public class TesterClass
{
    // main method for testing
    public static void main(String[] args)
    {
        // Create 2 Pet objects and test all your methods

    }
}
        </code>
        <tests>
 import static org.junit.Assert.*;

 import org.junit.*;

 import java.io.*;

 public class RunestoneTests extends CodeTestHelper
 {
     public RunestoneTests()
     {
         super("TesterClass");
     }

     @Test
     public void testConstructors()
     {
         changeClass("Pet");
         int count = 0;

         for (int i = 0; i &lt; 6; i++)
         {
             if (checkConstructor(i).equals("pass")) count++;
         }

         boolean passed = count &gt;= 1;

         getResults("2+", "" + count, "Checking for constructor", passed);
         assertTrue(passed);
     }

     @Test
     public void testPrivateVariables()
     {
         changeClass("Pet");
         String expect = "5 Private";
         String output = testPrivateInstanceVariables();

         boolean passed = getResults(expect, output, "Checking Private Instance Variables");
         assertTrue(passed);
     }

     @Test
     public void test1()
     {
         String code = getCode();
         String target = "public * get*()";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking accessor (get) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test3()
     {
         String target = "public String toString()";
         boolean passed = checkCodeContains("toString() method", target);
         assertTrue(passed);
     }

     @Test
     public void testSet()
     {
         String code = getCode();
         String target = "public void set*(*)";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 5;

         getResults("5", "" + num, "Checking mutator (set) methods for each variable", passed);
         assertTrue(passed);
     }

     @Test
     public void test4()
     {
         String code = getCode();
         String target = "Pet * = new Pet(";

         int num = countOccurencesRegex(code, target);

         boolean passed = num &gt;= 2;

         getResults("2", "" + num, "Checking main method creates 2 Pet objects", passed);
         assertTrue(passed);
     }

     @Test
     public void testMain()
     {
         String output = getMethodOutput("main");

         String expect = "2+ line(s) of text";
         String actual = " line(s) of text";

         int len = output.split("\n").length;

         if (output.length() &gt; 0)
         {
             actual = len + actual;
         }
         else
         {
             actual = output.length() + actual;
         }
         boolean passed = len &gt;= 2;

         getResults(expect, actual, "Checking main method prints info for 2 Pet objects", passed);
         assertTrue(passed);
     }
 }
        </tests>
      </program>
    </project>
  </subsection>

  <subsection xml:id="design-a-class-for-your-community-2">
    <title>Design a Class for your Community</title>
    <p>
      In last lessons, you came up with a class of your own choice relevant to
      your community.
    </p>

    <p>
      <ol marker="1">
        <li>
          <p>
            Copy your class with its 3 instance variables, constructor, and its
            print() and main methods from <url
            href="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community"
            visual="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community">lesson
            3.4</url> into the active code exercise below.
          </p>
        </li>

        <li>
          <p>
            Create accessor (get) methods and mutator (set) methods for each of
            the instance variables.
          </p>
        </li>

        <li>
          <p>
            Create a <c>toString</c> method that returns all the information in
            the instance variables.
          </p>
        </li>

        <li>
          <p>
            Write an additional method for your class that takes a parameter.
            For example, there could be a print method with arguments that
            indicate how you want to print out the information, e.g.
            <c>print(format)</c> could print the data according to an argument
            that is “plain” or “table” where the data is printed in a table
            drawn with dashes and lines (<c>|</c>). Or come up with another
            creative method for your class.
          </p>
        </li>

        <li>
          <p>
            Use these methods in the main method to test them. Make sure you use
            good commenting.
          </p>
        </li>
      </ol>
    </p>

    <project label="community-challenge3">
      <statement>
        <p>
          Copy your class from <url
          href="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community"
          visual="topic-3-4-constructors.html#groupwork-design-a-class-for-your-community">lesson
          3.4</url>. Add get, set, toString, and a method that takes a
          parameter. For example, there could be a print method with arguments
          that indicate how you want to print out the information, print(format)
          where format is “plain” or “table”.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class          // Add your class name here!
{
    // 1. Copy your class instance variables, constructor, and print()

    // 2. Create accessor (get) and mutator (set) methods for each of the instance variables.

    // 3. Create a toString() method that returns all the information in the instance variables.
    // 4.  Add a method for your class that takes a parameter.
    // For example, there could be a print method with arguments that indicate
    // how you want to print out the information, print(format) where format is "plain" or "table".

    // 5. Test all the methods in the main method.
    public static void main(String[] args)
    {
       // Construct an object of your class


       // call the object's methods

    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testPrivateVariables()
    {
        String expect = "3 Private";
        String output = testPrivateInstanceVariables();
        boolean passed = false;
        if (Integer.parseInt(expect.substring(0, 1)) &lt;= Integer.parseInt(output.substring(0, 1)))
            passed = true;
        passed = getResults(expect, output, "Checking private instance variable(s)", passed);
        assertTrue(passed);
    }

    /* @Test
    public void testDefaultConstructor()
    {
        String output = checkDefaultConstructor();
        String expect = "pass";

        boolean passed = getResults(expect, output, "Checking default constructor");
        assertTrue(passed);
    } */

    @Test
    public void testConstructor3()
    {
        String output = checkConstructor(3);
        String expect = "pass";

        boolean passed = getResults(expect, output, "Checking constructor with 3 parameters");
        assertTrue(passed);
    }

    @Test
    public void testPrint()
    {
        String output = getMethodOutput("print");
        String expect = "More than 15 characters";
        String actual = " than 15 characters";

        if (output.length() &lt; 15)
        {
            actual = "Less" + actual;
        }
        else
        {
            actual = "More" + actual;
        }
        boolean passed = getResults(expect, actual, "Checking print method");
        assertTrue(passed);
    }

    @Test
    public void testMain() throws IOException
    {
        String output = getMethodOutput("main"); // .split("\n");
        String expect = "3+ line(s) of text";
        String actual = " line(s) of text";
        int len = output.split("\n").length;

        if (output.length() &gt; 0)
        {
            actual = len + actual;
        }
        else
        {
            actual = output.length() + actual;
        }
        boolean passed = len &gt;= 3;

        getResults(expect, actual, "Checking output", passed);
        assertTrue(passed);
    }

    @Test
    public void test1()
    {
        String code = getCode();
        String target = "public * get*()";

        int num = countOccurencesRegex(code, target);

        boolean passed = num &gt;= 3;

        getResults("3", "" + num, "Checking accessor (get) methods for each variable", passed);
        assertTrue(passed);
    }

    @Test
    public void test2()
    {
        String code = getCode();
        String target = "public void set*(*)";

        int num = countOccurencesRegex(code, target);

        boolean passed = num &gt;= 3;

        getResults("3", "" + num, "Checking mutator (set) methods for each variable", passed);
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String target = "public String toString()";
        boolean passed = checkCodeContains("toString() method", target);
        assertTrue(passed);
    }

    @Test
    public void testPrintFormat()
    {
        String target = "public void print(String";
        boolean passed = checkCodeContains("print method with String argument", target);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </project>
  </subsection>

  <subsection xml:id="summary-31">
    <title>Summary</title>
    <p>
      <ul>
        <li>
          <p>
            (AP 3.5.A.1) A <c>void</c> method does not return a value. Its
            header contains the keyword <c>void</c> before the method name.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.2) A <term>non-void method</term> returns a single value.
            Its header includes the return type in place of the keyword
            <c>void</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.3) In non-void methods, a return expression compatible
            with the return type is evaluated, and the value is returned. This
            is referred to as <term>return by value</term>.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.4) The <c>return</c> keyword is used to return the flow of
            control to the point where the method or constructor was called. Any
            code that is sequentially after a return statement will never be
            executed. Executing a return statement inside a selection or
            iteration statement will halt the statement and exit the method or
            constructor.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.5) An <term>accessor method</term> (getter) allows objects
            of other classes to obtain a copy of the value of instance variables
            or class variables. An accessor method is a non-void method.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.6) A <term>mutator (modifier) method</term> (setter) is a
            method that changes the values of the instance variables or class
            variables. A mutator method is often a void method.
          </p>
        </li>

        <li>
          <p>Comparison of accessor/getters and mutator/setters syntax:</p>
        </li>
      </ul>
    </p>

    <figure align="center">
      <image source="Unit3-Class-Creation/Figures/get-set-comparison.png" width="100%" />
    </figure>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.5.A.7) Methods with parameters receive values through those
            parameters and use those values in accomplishing the method’s task.
          </p>
        </li>

        <li>
          <p>
            (AP 3.5.A.8) When an argument is a primitive value, the parameter is
            initialized with a copy of that value. Changes to the parameter have
            no effect on the corresponding argument.
          </p>
        </li>

        <li>
          <p>
            The <c>toString</c> method is an overridden method that is included
            in classes to provide a description of a specific object. It
            generally includes what values are stored in the instance data of
            the object. If <c>System.out.print</c> or <c>System.out.println</c>
            is passed an object, that object’s <c>toString</c> method is called,
            and the returned <c>String</c> is printed. An object’s
            <c>toString</c> method is also used to get the <c>String</c>
            representation when concatenating the object to a <c>String</c> with
            the <c>+</c> operator.
          </p>
        </li>
      </ul>
    </p>

    <activity label="AccessorMutator">
      <statement>
        <p>
          Drag the definition from the left and drop it on the correct word on
          the right. Click the "Check Me" button to see if you are correct.
        </p>
      </statement>

      <feedback>
        <p>Review the vocabulary.</p>
      </feedback>

      <cardsort>
        <match>
          <premise order="1">gets and returns the value of an instance variable</premise>
          <response>accessor method</response>
        </match>

        <match>
          <premise order="2">sets the instance variable to a value in its parameter</premise>
          <response>mutator method</response>
        </match>

        <match>
          <premise order="3">initializes the instance variables to values</premise>
          <response>constructor</response>
        </match>

        <match>
          <premise order="4">accessible from outside the class</premise>
          <response>public</response>
        </match>

        <match>
          <premise order="5">accessible only inside the class</premise>
          <response>private</response>
        </match>
      </cardsort>
    </activity>
  </subsection>

  <subsection xml:id="ap-practice-21">
    <title>AP Practice</title>
    <activity label="AP-get1">
      <statement>
        <p>
          Consider the following Party class. The getNumOfPeople method is
          intended to allow methods in other classes to access a Party object’s
          numOfPeople instance variable value; however, it does not work as
          intended. Which of the following best explains why the getNumOfPeople
          method does NOT work as intended?
        </p>


          <program language="java">
            <code>
public class Party
{
    private int numOfPeople;

    public Party(int num)
    {
        numOfPeople = num;
    }

    private int getNumOfPeople()
    {
        return numOfPeople;
    }
}
            </code>
          </program>

      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>The getNumOfPeople method should be declared as public.</p>
          </statement>

          <feedback>
            <p>
              Correct, accessor methods should be public so they can be accessed
              from outside the class.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The return type of the getNumOfPeople method should be void.</p>
          </statement>

          <feedback>
            <p>The method return type should stay as int.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The getNumOfPeople method should have at least one parameter.</p>
          </statement>

          <feedback>
            <p>This method should not have any parameters</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The variable numOfPeople is not declared inside the getNumOfPeople
              method.
            </p>
          </statement>

          <feedback>
            <p>This is an instance variable and should be declared outside.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The instance variable num should be returned instead of
              numOfPeople, which is local to the constructor.
            </p>
          </statement>

          <feedback>
            <p>The numOfPeople variable is correctly returned.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-get2">
      <statement>
        <p>
          Consider the following class definition. The class does not compile.
        </p>

        <program language="java">
          <code>
public class Student
{
    private int id;

    public getId()
    {
        return id;
    }
    // Constructor not shown
}
          </code>
        </program>

        <p>
          The accessor method getId is intended to return the id of a Student
          object. Which of the following best explains why the class does not
          compile?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-get2_opt_a">
            <p>The id instance variable should be public.</p>
          </statement>

          <feedback id="AP-get2_opt_a">
            <p>Instance variables should be private.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-get2_opt_b">
            <p>The getId method should be declared as private.</p>
          </statement>

          <feedback id="AP-get2_opt_b">
            <p>Accessor methods should be public methods.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-get2_opt_c">
            <p>The getId method requires a parameter.</p>
          </statement>

          <feedback id="AP-get2_opt_c">
            <p>Accessor methods usually do not require parameters.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-get2_opt_d">
            <p>
              The return type of the getId method needs to be defined as void.
            </p>
          </statement>

          <feedback id="AP-get2_opt_d">
            <p>void is not the correct return type.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-get2_opt_e">
            <p>The return type of the getId method needs to be defined as int.</p>
          </statement>

          <feedback id="AP-get2_opt_e">
            <p>
              Correct! Accessor methods have a return type of the instance
              variable they are returning.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-mutator1">
      <statement>
        <p>Consider the following class definition.</p>
        <program language="java">
          <code>
public class Liquid
{
    private int currentTemp;

    public Liquid(int temp)
    {
        currentTemp = temp;
    }

    public void resetTemp()
    {
        currentTemp = newTemp;
    }
}
          </code>
        </program>

        <p>
          Which of the following best identifies the reason the class does not
          compile?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-mutator1_opt_a">
            <p>The constructor header does not have a return type.</p>
          </statement>

          <feedback id="AP-mutator1_opt_a">
            <p>The constructor should not have a return type.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-mutator1_opt_b">
            <p>The resetTemp method is missing a return type.</p>
          </statement>

          <feedback id="AP-mutator1_opt_b">
            <p>Mutator methods usually have a void return type.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-mutator1_opt_c">
            <p>The constructor should not have a parameter.</p>
          </statement>

          <feedback id="AP-mutator1_opt_c">
            <p>Constructors can have parameters.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-mutator1_opt_d">
            <p>The resetTemp method should have a parameter.</p>
          </statement>

          <feedback id="AP-mutator1_opt_d">
            <p>
              Correct! The resetTemp method should have a parameter for the
              newTemp value to set the currentTemp.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-mutator1_opt_e">
            <p>
              The instance variable currentTemp should be public instead of
              private.
            </p>
          </statement>

          <feedback id="AP-mutator1_opt_e">
            <p>Instance variables should be private variables.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-mutator2">
      <statement>
        <p>
          In the <c>Party</c> class below, the <c>addPeople</c> method is
          intended to increase the value of the instance variable
          <c>numOfPeople</c> by the value of the parameter
          <c>additionalPeople</c>. The method does not work as intended.
        </p>

        <program language="java">
          <code>
public class Party
{
    private int numOfPeople;

    public Party(int n)
    {
        numOfPeople = n;
    }

    public int addPeople(int additionalPeople) // Line 10
    {
        numOfPeople += additionalPeople; // Line 12
    }
}
          </code>
        </program>

        <p>
          Which of the following changes should be made so that the class
          definition compiles without error and the method <c>addPeople</c>
          works as intended?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>Replace line 12 with numOfPeople = additionalPeople;</p>
          </statement>

          <feedback>
            <p>This method should add additionalPeople to numOfPeople.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Replace line 12 with return additionalPeople;</p>
          </statement>

          <feedback>
            <p>This method should add additionalPeople to numOfPeople.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Replace line 12 with additionalPeople += 3;</p>
          </statement>

          <feedback>
            <p>This method should add additionalPeople to numOfPeople.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Replace line 10 with public addPeople (int additionalPeople)</p>
          </statement>

          <feedback>
            <p>Mutator methods should have a void return type.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Replace line 10 with public void addPeople(int additionalPeople)
            </p>
          </statement>

          <feedback>
            <p>Mutator methods should have a void return type.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>
</section>
