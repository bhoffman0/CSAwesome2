<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section>
  <title>Exam 2 for the AP CSA Exam (not timed)</title>
  <p>The following problems are similar to what you might see on the AP CSA exam.  Please answer each to the best of your ability.</p>
  <exercises>
    <exercise label="qtnt2_1">
        <statement>

        <p>12-3-1: Consider the <c>Animal</c>, <c>Fish</c>, and <c>Goldfish</c> classes shown below.  Which of the following object declarations will compile without error?</p>
        <program language="java"><input>
public class Animal
{
    /* no constructors or other methods have been declared */
}

public class Fish extends Animal
{
    /* no constructors or other methods have been declared */
}

public class Goldfish extends Fish
{
    /* no constructors or other methods have been declared */
}

I. Goldfish glub = new Fish();

II. Animal glub = new Fish();

III. Fish glub = new Goldfish();
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>A Fish is NOT a type of Goldfish. The Fish class does not inherit from the Goldfish class, so a Fish cannot be instantiated as a Goldfish object.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>II is correct, but III is correct as well. A Goldfish IS-A type of Fish, and a Fish IS-A type of Animal.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>III is correct, but II is correct as well. A Goldfish IS-A type of Fish, and a Fish IS-A type of Animal.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I and II only</p>
                </statement>
                <feedback>
                    <p>II is correct, but a Fish is NOT a type of Goldfish. A Fish cannot be instantiated as a Goldfish object, because the Fish class does not inherit from the Goldfish class.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>II and III only</p>
                </statement>
                <feedback>
                    <p>A Goldfish IS-A type of Fish, and a Fish IS-A type of Animal. The Goldfish class inherits from the Fish class, and the Fish class inherits from the Animal class.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_2">
        <statement>

        <p>12-3-2: Assume that <c>list</c> has been instantiated as an ArrayList of integers containing <c>[6, 2, 9]</c> . What are the contents of <c>list</c> after the code is executed?</p>
        <program language="java"><input>
list.remove(2);
list.add(1, 4);
list.add(5);
list.set(2, 7);
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>[6, 2, 7, 5]</p>
                </statement>
                <feedback>
                    <p>When the add method is used with two parameters, the value is added at the specific index, not at the end of the list. In this list, 4 has been added at index 1.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[6, 4, 2, 7, 5]</p>
                </statement>
                <feedback>
                    <p>This would be correct if 7 had been placed in the list using add, not set. Remember that the set method replaces the value at the index. It does not move the previous value to the right.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 7, 9, 5]</p>
                </statement>
                <feedback>
                    <p>Remember that in ArrayLists, indexing starts at 0, not 1.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>[6, 4, 7, 5]</p>
                </statement>
                <feedback>
                    <p>The 9 at index 2 is removed, resulting in [6, 2], then a 4 is added at index 1 resulting in [6, 4, 2]. A 5 is added to the end of the list resulting in [6,4,2,5], and the value at 2 is replaced with a 7 resulting in [6,4,7,5].</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 7, 6, 9, 5]</p>
                </statement>
                <feedback>
                    <p>Remember that in ArrayLists, indexing starts at 0, not 1. The set method replaces the value at the specified index with a new value, so the original value is deleted.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_3">
        <statement>

        <p>12-3-3: A sorted array of integers containing 2000 elements is to be searched for <c>key</c> using a binary search method. Assuming <c>key</c> is in the array, what is the maximum number of iterations needed to find <c>key</c>?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>8</p>
                </statement>
                <feedback>
                    <p>2 ^ 8 = 256. There will not be enough passes to guarantee finding the value. Remember that binary search requires log2 (number of elements) passes to guarantee that a value will be found.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>10</p>
                </statement>
                <feedback>
                    <p>2 ^ 10 = 1024. There will not be enough passes to guarantee finding the value. Remember that binary search requires log2 (number of elements) passes to guarantee that a value will be found.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>100</p>
                </statement>
                <feedback>
                    <p>The key will be found in 100 passes, but there is a better answer. Remember that binary search requires log2 (number of elements) passes to find a value.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>2000</p>
                </statement>
                <feedback>
                    <p>With binary search, every element of the array does not have to be checked. Remember that although sequential search would require 2000 passes to guarantee the value was found, binary search requires log2 (number of elements) passes to find an object.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>11</p>
                </statement>
                <feedback>
                    <p>2 ^ 11 = 2048. Because 2048 is larger than 2000, 11 passes will be more than enough to guarantee finding the value.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_4">
        <statement>

        <p>12-3-4: Which of the following code segments creates a 7 x 9 array of integers and fills every space in the array with multiples of two (not including the value 0)?</p>
        <program language="java"><input>
I.   int[][] arr = new int [7][9];

II.  int[][] arr = new int [7][9];
     int count = 1;

     for(int i = 0; i &lt; arr.length; i++)
     {
        for(int j = 0; j &lt; arr[0].length; j++)
        {
           arr[i][j] = count * 2;
           count++;
        }
     }

III. int[][] arr = new int [7][9];
     int count = 1;
     int row = 0;
     int col = 0;

     while (row &lt; arr.length &amp;&amp; col &lt; arr[0].length)
     {
        arr[row][col] = count * 2;
        row++;
        col++;
        count++;
     }
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>I correctly creates the 7 x 9 matrix, but every value in the matrix remains 0.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>II correctly creates and fills the matrix with multiples of 2.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II and III only</p>
                </statement>
                <feedback>
                    <p>II is correct, but III does not fill every space correctly. Only diagonal spaces are filled, so most of the spaces are still filled with 0 at the end of the loop. Notice that every time the while loop cycles, the values of row and col both increase.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I and II only</p>
                </statement>
                <feedback>
                    <p>II is correct, but I does not fill the matrix.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>III does not fill every space correctly. Only spaces lying on the diagonal are filled because the row and column index change at the same time, and the values are incorrect. Most of the spaces remain filled with 0. Notice that every time the while loop cycles, the values of row and col both increase.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_5">
        <statement>

        <p>12-3-5: Consider the method <c>printString</c> shown below. What is printed as a result of printString(“sandwich”)?</p>
        <program language="java"><input>
public void printString(String s)
{
   if (s.length() &gt; 0)
   {
      printString(s.substring(1));
      System.out.print(s.substring(0, 1));
   }
}
</input></program>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>hciwdnas</p>
                </statement>
                <feedback>
                    <p>The recursive call occurs until the length of s equals 0, then the letters of the word are printed in reverse order.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>sandwich</p>
                </statement>
                <feedback>
                    <p>This would occur if the print statement came before the recursive call. Because the compiler works through the recursive call before moving to the other statements, the letters are printed in reverse order.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>andwichandwichndwichdwichwichichchh</p>
                </statement>
                <feedback>
                    <p>This would occur if the print statement came before the recursive call and included s.substring(1), not s.substring(0, 1). The statements are printed after the recursive call is made, so the compiler works through every recursive call before it prints out the letters, and the letters are printed in reverse order.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>hchichwichdwichndwichandwich</p>
                </statement>
                <feedback>
                    <p>This would occur if the print statement included s.substring(1). Each call of the printString method prints only one letter at a time, because the substring that is printed is s.substring(0,1).</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Nothing is printed because an infinite loop occurs</p>
                </statement>
                <feedback>
                    <p>This method ends when s.length() equals zero, so the base case is reached after eight passes for the word "sandwich". An infinite loop will not occur.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_6">
        <statement>

        <p>12-3-6: The Dog class is shown below. The GoldenRetriever class inherits from the Dog class. Which methods does the GoldenRetriever class inherit?</p>
        <program language="java"><input>
public class Dog
{
   private int numLegs = 4;
   private String name = "Spot";

   public Dog(String theName)
   {
      /* implementation not shown */
   }

   public String bark()
   {
     return "Woof!";
   }

   public String getName()
   {
      return name;
   }
}

I. public Dog(String theName)

II. bark()

III. getName()
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>Remember that subclasses do not inherit constructors from the parent class.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I and II only</p>
                </statement>
                <feedback>
                    <p>II is correct, but constructors are not inherited.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>III is correct, but remember that all public methods are inherited by the subclass.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>II and III only</p>
                </statement>
                <feedback>
                    <p>Subclasses inherit public methods from the parent class, but they do not inherit constructors.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I, II, and III</p>
                </statement>
                <feedback>
                    <p>Constructors are not inherited from the parent class. II and III are correct, but GoldenRetriever would not inherit the constructor.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_7">
        <statement>

        <p>12-3-7: Which of these loops will output <c>02468</c>?</p>
        <program language="java"><input>
I. for (int i = 0; i &lt;= 8; i++)
   {
      System.out.print(i);
   }

II. int i = 0;
    while (i &lt; 8)
    {
       i +=2;
       System.out.print(i);
    }

III. for (int i = 0; i &lt;= 8; i +=2)
     {
        System.out.print(i);
     }
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>Notice the incrementing in the for loop. The value i increments by 1, not by 2, so "012345678" is printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>Notice the order of the incrementing and the print statement in the while loop. The value i increments before it is printed. The code never prints out 0, so "2468" is printed.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>The value i starts at 0 and increments by 2, correctly printing out every value.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I and II only</p>
                </statement>
                <feedback>
                    <p>Notice the incrementing in the loops for I and II. In I, the value i increments by 1 and prints out too many values. In II, the first value is not printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I, II, and III</p>
                </statement>
                <feedback>
                    <p>III is correct, but I prints out every value between 0 and 8 and II does not print the first value.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_8">
        <statement>

        <p>12-3-8: Consider the following method <c>mystery</c>. Assuming x is an integer greater than 1, in which case does <c>mystery</c> result in an infinite loop?</p>
        <program language="java"><input>
public int mystery(int x, int y)
{
   if (x &lt;= y)
       return x;
   else
       return mystery(x, y * 10);
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>y is greater than 1</p>
                </statement>
                <feedback>
                    <p>Eventually, the recursive calls will reach the base case, where y is greater than or equal to x. If y is greater than 1, multiplying by 10 will increase y and y will remain positive.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>y is less than or equal to 0</p>
                </statement>
                <feedback>
                    <p>If y is less than or equal to 0, multiplying by 10 will not make the value greater than x. The base case will never be reached, and the method will continue running until the computer runs out of memory.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>y is greater than x</p>
                </statement>
                <feedback>
                    <p>If y is greater than x, the method will reach its base case on the first pass of the method.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>all of the above</p>
                </statement>
                <feedback>
                    <p>Not all of the statements are correct. If y is greater than x or if y is greater than 1, the method will eventually reach its base case and end.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>none of the above</p>
                </statement>
                <feedback>
                    <p>One of the statements is correct. If y is less than or equal to 0, multiplying by 10 will not make y become greater than x.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_9">
        <statement>

        <p>12-3-9: Consider the following classes <c>Cat</c> and <c>FluffyCat</c>. What is the result of executing the following code?
            <c>Cat obj = new FluffyCat();</c></p>
        <p><c>obj.display();</c></p>
        <program language="java"><input>
public class Cat
{
    public String display()
    {
        System.out.print("Cats! ");
    }
}

public class FluffyCat extends Cat
{
    public String display()
    {
        System.out.print("Cool!");
    }
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Cats!</p>
                </statement>
                <feedback>
                    <p>This would be the case if obj was a Cat at run-time. At run-time, obj is a FluffyCat, so the overwritten method in the Cat class is used.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Cats!  Cool!</p>
                </statement>
                <feedback>
                    <p>This would be the case if the display method in FluffyCat used 'super' to call on the display method in the Cat class before it printed "Cool!".</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Cool!</p>
                </statement>
                <feedback>
                    <p>Although obj is declared to be a Cat at compile time, at run-time it is actually a FluffyCat. The overwritten display method defined in the FluffyCat class will be called.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Cool! Cats!</p>
                </statement>
                <feedback>
                    <p>The method has been overwritten in FluffyCat, so the display method present in the Cat Class ("Cats! ") will not be printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The code results in an error.</p>
                </statement>
                <feedback>
                    <p>This code compiles and runs correctly. A FluffyCat IS-A Cat object, so the code will compile and run without issue.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_10">
        <statement>

        <p>12-3-10: Consider the class <c>showMe</c>, shown below. What is printed as a result of <c>showMe(10)</c>?</p>
        <program language="java"><input>
public static void showMe(int arg)
{
   if (arg &gt; 1)
   {
      showMe(arg - 1);
   }

   else
   {
      System.out.print(arg + " ");
   }
}
</input></program>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>1</p>
                </statement>
                <feedback>
                    <p>After the recursive call reaches the base case (where arg = 1), the compiler prints "1". The recursive calls all just return and don't print anything.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>0</p>
                </statement>
                <feedback>
                    <p>This would be correct if the recursive call specified that arg &gt;= 1 or arg &gt; 0. Because the code ends when arg reaches a value of 1, the code will not print out 0.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>10 9 8 7 6 5 4 3 2 1</p>
                </statement>
                <feedback>
                    <p>This would be correct if the method printed out arg + " " before going to the recursive call. Because the print statement is located at the end of the base case and not the recursive call, not every value is printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>1 2 3 4 5 6 7 8 9 10</p>
                </statement>
                <feedback>
                    <p>This would be correct if the method printed arg + " " after the recursive call in the if statement. Because the method does not return any values or strings, and because only the base case has a print statement, only the last value of arg is printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>10</p>
                </statement>
                <feedback>
                    <p>This would be correct if the method returned an integer that was the sum of the previous calls. The method does not add any values.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_11">
        <statement>

        <p>12-3-11: Consider the following code. What is printed as a result of executing this code?</p>
        <program language="java"><input>
int sum = 0;

for (int x = 0; x &lt; 5; x++)
{
   for (int y = x; y &lt; 5; y++)
   {
      sum++;
   }
}

System.out.println(sum);
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>25</p>
                </statement>
                <feedback>
                    <p>This would be correct if at the beginning of the second for loop, y was equal to 0, not to x. The starting value of y changes every time that x increases.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>15</p>
                </statement>
                <feedback>
                    <p>The code loops 15 times, and sum is incremented by 1 each time.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>21</p>
                </statement>
                <feedback>
                    <p>This would be correct if the for-loops both continued when the values were less than or equal to 5, not when the values were less than 5.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>36</p>
                </statement>
                <feedback>
                    <p>This would be correct if the for-loops both began at 0 and looped until the values were less than or equal to 5. Check the for loop structures.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>10</p>
                </statement>
                <feedback>
                    <p>This would be correct if the first for-loop began at 1, not at 0.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_12">
        <statement>

        <p>12-3-12: You are trying to write a method <c>sumRow</c> that finds the sum of the values in a specified row of a symmetrical 2-D matrix. Which of the following code segments could replace <c>/* to be determined */</c> to make the code work correctly?</p>
        <program language="java"><input>
public int sumRow (int row, int[][] values)
{
   int sum = 0;

   /* to be determined */

   return sum;
}

//I.
for (int[] rowValues : values)
{
   for (int x : rowValues)
   {
      sum += x;
   }
}

//II.
for (int i = 0; i &lt; values[0].length;i++)
{
   sum += values[row][i];
}

//III.
int col = 0;
while (col &lt; values[0].length)
{
   sum += values[row][col];
   col++;
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>I will find the sum of all the values in the matrix, but it does not find the sum of a specific row.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>II is correct, but III is also correct. This method can be completed by using a while loop or a for loop.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>III only</p>
                </statement>
                <feedback>
                    <p>III is correct, but II is also correct. This method can be completed by using a for loop or a while loop.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>II and III</p>
                </statement>
                <feedback>
                    <p>II and III both correctly add the values in the specified row.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I, II, and III</p>
                </statement>
                <feedback>
                    <p>II and III are correct, but I adds every value in the matrix, not just the specified row.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_13">
        <statement>

        <p>12-3-13: You have an array <c>values</c> filled with 50 integers. Which of the following correctly produces a random index of <c>values</c>?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>(int) (Math.random() + 1) * 50</p>
                </statement>
                <feedback>
                    <p>This always returns 50. Math.random() + 1 calculates a value between 1 and 1.9, and when this value is cast as an int it becomes 1. 1 * 50 always returns 50.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(int) (Math.random() * 50) + 1</p>
                </statement>
                <feedback>
                    <p>This calculates a random number between 1 and 50, but indexes of arrays start at 0 and end at array.length - 1.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(int) (Math.random() + 1 * 50)</p>
                </statement>
                <feedback>
                    <p>This always returns 50. 1 * 50 returns 50 since multiplication takes precedence befores addition. The value of Math.random() + 50 always falls between 50.0 and 50.9, and this value becomes 50 when it is cast as an int.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(int) Math.random() * 50</p>
                </statement>
                <feedback>
                    <p>This always returns 0, since Math.random() returns a value between 0 and 0.9. When the value of Math.random() is cast an int, its value becomes 0. 0 * 50 returns 0.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>(int) (Math.random() * 50)</p>
                </statement>
                <feedback>
                    <p>This correctly calculates a random index between 0 and 49 for the array.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_14">
        <statement>

        <p>12-3-14: Given the following code, what is returned by mystery(5364)?</p>
        <program language="java"><input>
public static int mystery(int num)
{
   if (num &lt; 10)
   {
      return 1;
   }

   else
   {
      return 1 + mystery(num / 10);
   }
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>The method will produce an infinite loop.</p>
                </statement>
                <feedback>
                    <p>Eventually, the recursive calls will reach mystery(5). 5 is less than 10, so the base case will have been reached and the method will end.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>19</p>
                </statement>
                <feedback>
                    <p>This would be correct if the method found the sum of the digits in the given value, with an extra 1. Instead, the method finds the number of digits.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>4</p>
                </statement>
                <feedback>
                    <p>This method finds the number of digits in num.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>3</p>
                </statement>
                <feedback>
                    <p>This method finds the number of digits in num. Check your recursive call to make sure you reached the base case correctly.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>18</p>
                </statement>
                <feedback>
                    <p>This would be correct if the method added the digits in the value. Instead, the method simply finds the number of digits. Check the recursive call again.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_15">
        <statement>

        <p>12-3-15: Consider an array of integers that contains <c>[12, 8, 4, 6, 13, 29, 7]</c>. If the array is sorted from smallest to largest using an insertion sort method, what will be the order of the array after the third iteration of the sorting method?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>[4, 6, 12, 8, 13, 29, 7]</p>
                </statement>
                <feedback>
                    <p>This is what would happen with two iterations of selection sort. Remember that selection sort only swaps two elements at a time, while insertion sort places elements in order in the sorted part of the array.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 6, 7, 8, 13, 29, 12]</p>
                </statement>
                <feedback>
                    <p>This is what would happen if selection sort was used instead of insertion sort. Remember that selection sort only swaps two elements at a time, while insertion sort places elements in order in the sorted part of the array.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 8, 12, 6, 13, 29, 7]</p>
                </statement>
                <feedback>
                    <p>This is what the array looks like after the second iteration. Do one more iteration.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>[4, 6, 8, 12, 13, 29, 7]</p>
                </statement>
                <feedback>
                    <p>Using insertion sort, we start at the first index and sort the first two values to create a sorted array at the left side of the array. We repeat this step for the second index, creating a sorted array of three elements, and again for the third index, creating a sorted array of four elements.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[4, 6, 7, 8, 12, 13, 29]</p>
                </statement>
                <feedback>
                    <p>This is the final sorted array. Instead of three passes, it takes seven iterations to reach this state.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_16">
        <statement>

        <p>12-3-16: Consider the classes <c>Car</c> and <c>Minivan</c>, shown below. If <c>obj</c> has been instantiated later in the class as a <c>Minivan</c>, what is printed as a result of <c>obj.drive()</c>?</p>
        <program language="java"><input>
public class Car
{
    public void drive()
    {
        System.out.print("Vroom vroom! ");
    }
}

public class Minivan extends Car
{
    public void drive()
    {
        super.drive();
        System.out.print(" Let's go! ");
    }
}
</input></program>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>Vroom vroom! Let's go!</p>
                </statement>
                <feedback>
                    <p>The method drive has been overwritten in the Minivan class. Since obj is of type Minivan, the compiler will use the overwritten method. The overwritten method uses super() to call to the method of the parent class, so "Vroom vroom! " is printed. Then, the overwritten method prints out "Let's go! ".</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Vroom vroom!</p>
                </statement>
                <feedback>
                    <p>Although the overwritten method has a call to the method in the parent class, there is another line of code that must be printed. The drive method has been overwritten for the Minivan class.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Let's go!</p>
                </statement>
                <feedback>
                    <p>This would be the case if the overwritten method did not make a call to the class in the parent class. Because the method has a call to the parent class before it does anything else, "Vroom vroom! " is printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Let's go! Vroom vroom!</p>
                </statement>
                <feedback>
                    <p>This would be the case if the parent method had been called after "Let's go! " had been printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>This would result in a compile-time error.</p>
                </statement>
                <feedback>
                    <p>This code correctly compiles, so there are no errors present. The Minivan class can make a call to a method in the Car class using super, because the Minivan class extends the Car class.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_17">
        <statement>

        <p>12-3-17: Consider the following method <c>changeArray</c>. An array is created that contains <c>[2, 8, 10, 9, 6]</c> and is passed to <c>changeArray</c>. What are the contents of the array after the <c>changeArray</c> method executes?</p>
        <program language="java"><input>
public void changeArray(int[] data)
{
   for (int k = data.length - 1; k &gt; 0; k--)
      data[k - 1] = data[k] + data[k - 1];
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>[2, 6, 2, -1, -3]</p>
                </statement>
                <feedback>
                    <p>This would be correct if data[k] was modified in the for-loop. In this for-loop, data[k - 1] is the element that changes.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[-23, -21, -13, -3, 6]</p>
                </statement>
                <feedback>
                    <p>This would be correct if data[k - 1] was subtracted from data[k]. Notice that for every instance of the for-loop, data[k] and data[k - 1] are added together and assigned to the index at data[k - 1].</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>[10, 18, 19, 15, 6]</p>
                </statement>
                <feedback>
                    <p>This would be correct if the for-loop began at 1 and continued to data.length - 1. Notice the for-loop indexing.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>This method creates an IndexOutOfBounds exception.</p>
                </statement>
                <feedback>
                    <p>The indexing of this method is correct. The for-loop begins at the last index and ends at the second index, and the method does not access any values other than the ones specified.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>[35, 33, 25, 15, 6]</p>
                </statement>
                <feedback>
                    <p>This method starts at the second-to-last index of the array and adds the value of the previous element to the element at index k - 1.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_18">
        <statement>

        <p>12-3-18: Which statement is equivalent to <c>!( (x &gt; 7) &amp;&amp; !(y &lt; 12) )</c>?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>(x &lt;= 7) &amp;&amp; (y &lt; 12)</p>
                </statement>
                <feedback>
                    <p>Use A and B to represent the expressions -- A == (x &gt; 7), B == !(y &lt; 12). The AND needs to be changed to an OR.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>(x &lt;= 7) || (y &lt; 12)</p>
                </statement>
                <feedback>
                    <p>Use A and B to represent the expressions -- A == (x &gt; 7), B == !(y &lt; 12)Using DeMorgan's law, !(A &amp;&amp; B) is equivalent to !A || !B. The negation of (x &gt; 7) is (x &lt;= 7), and the negation of !(y &lt; 12) is (y &lt; 12).</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(x &gt; 7) || (y &gt;= 12)</p>
                </statement>
                <feedback>
                    <p>Use A and B to represent the expressions -- A == (x &gt; 7), B == !(y &lt; 12)!(A &amp;&amp; B) is NOT equivalent to (A || B). It should be (!A || !B). Also, (y &gt;= 12) is equivalent to !(y &lt; 12).</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(x &gt; 7) &amp;&amp; (y &gt;= 12)</p>
                </statement>
                <feedback>
                    <p>Use A and B to represent the expressions -- A == (x &gt; 7), B == !(y &lt; 12)!(A &amp;&amp; B) is NOT equivalent to (A &amp;&amp; B). !(y &lt; 12) and (y &gt;=12) mean the same thing; changing this does not make the statement the opposite.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>(x &lt;= 7) || (y &gt;= 12)</p>
                </statement>
                <feedback>
                    <p>Use A and B to represent the expressions -- A == (x &gt; 7), B == !(y &lt; 12)!(A &amp;&amp; B) is NOT equivalent to (!A &amp;&amp; B). Changing !(y &lt; 12) to (y &gt;= 12) does not negate the statement; these two are equivalent.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_19">
        <statement>

        <p>12-3-19: Consider the following method <c>evens</c>, which finds the number of even numbers present in an array. Which of the following segments of code would correctly replace <c>/* to be completed */</c>?</p>
        <program language="java"><input>
public int evens(int [] arr)
{
   int count = 0;

   for (int x : arr)
   {
      /* to be completed */
   }

   return count;
}

// I
if (x % 2 == 0)
   count++;

// II
if (x % 2 == 1)
   count++;

// III
if (x / 2 == 0)
   count++;

// IV
if (x / 2 == 1)
   count++;
</input></program>

        </statement>
<choices>

            <choice correct="yes">
                <statement>
                    <p>I only</p>
                </statement>
                <feedback>
                    <p>The remainder operator (%) can be used to find if numbers are even or odd. I checks that x is even correctly using x % 2 == 0.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II only</p>
                </statement>
                <feedback>
                    <p>II uses the remainder operator to count the number of odd numbers in the array. If x % 2 == 1, then the number is odd, not even.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>III and IV only</p>
                </statement>
                <feedback>
                    <p>III and IV use the division operator, not the remainder operator. This does not check if the number is even.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>I and II only</p>
                </statement>
                <feedback>
                    <p>I is correct, but II increments the counter for odd numbers, not even numbers.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>II and IV only</p>
                </statement>
                <feedback>
                    <p>II counts the odd numbers instead of the even numbers. If x % 2 == 1, the number is odd, not even. IV does not use the remainder operator (%), which checks if numbers are even or odd.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    <exercise label="qtnt2_20">
        <statement>

        <p>12-3-20: Consider the method <c>findMax</c>, which uses sequential search to find the index of the largest value of an array. In which case would <c>findMax</c> not work properly?</p>
        <program language="java"><input>
public int findMax(int[] arr)
{
   int maxVal = 0;
   int index = 0;

   for (int i = 0; i &lt; arr.length; i++)
   {
      if (arr[i] &gt; maxVal)
      {
         index = i;
         maxVal = arr[i];
      }
   }
   return index;
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>This method will work correctly for all arrays.</p>
                </statement>
                <feedback>
                    <p>This method will not work correctly for all arrays. Look at the starting value for maxVal, and how maxVal is compared to all the values of the array. What happens if every value in the array is less than maxVal?</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The first value in the array is less than 0.</p>
                </statement>
                <feedback>
                    <p>Although this might present a problem if EVERY value in the array is less than 0, the compiler will move on to the next index without issue if the first value in the array is less than 0.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The first value in the array is equal to 0.</p>
                </statement>
                <feedback>
                    <p>This will not present a problem, as the if-statement has not been met and the for-loop will simply continue to the second element.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Every value in the array is greater than 0.</p>
                </statement>
                <feedback>
                    <p>If every value in the array is greater than 0, the method will work properly.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>Every value in the array is less than 0.</p>
                </statement>
                <feedback>
                    <p>maxVal is set to zero, so if every number in the array is less than 0, the maxVal will remain 0. A better idea would be to set maxVal to the value of the first element in the array.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
  </exercises>
</section>
