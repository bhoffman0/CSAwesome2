<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="test1nt">
  <title>Exam 1 for the AP CSA Exam (not timed)</title>
  <p>
    The following problems are similar to what you might see on the AP CSA exam.
    Please answer each to the best of your ability.
  </p>

  <activity label="qtnt1_1">
    <statement>
      <p>
        Which of the following is equivalent to the statement below? Recall
        DeMorganâ€™s Law.
      </p>

      <program language="java">
        <code>
!((a &lt;= b) &amp;&amp; (b &lt; 0))
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>(a &gt;= b) &amp;&amp; (b &gt;= 0)</p>
        </statement>

        <feedback>
          <p>
            The "!" would negate everything inside the parentheses. There are a
            few mistakes here. The opposite of &lt;= is not &gt;= and the
            opposite of AND is OR.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>!(a &gt; b) || !(b &gt;= 0)</p>
        </statement>

        <feedback>
          <p>
            Both of the expressions inside the parentheses were altered. If we
            wanted to distribute the negation symbol "!" then we would leave the
            expressions inside the parentheses alone.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>(a &gt;= b) || (b &gt; 0)</p>
        </statement>

        <feedback>
          <p>
            Negating less than or equals (&lt;=) results in greater than (&gt;).
            In addition, less than (&lt;) in the second argument should have
            been changed to greater than or equals (&gt;=).
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>(a &gt; b) || (b &gt;= 0)</p>
        </statement>

        <feedback>
          <p>
            Using DeMorgan's Law we negate everything. This includes our AND
            statement (which becomes an OR) and everything inside both
            parentheses.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>(a &gt; b) &amp;&amp; (b &gt;= 0)</p>
        </statement>

        <feedback>
          <p>Here we forgot to negate our AND (&amp;&amp;) into an OR (||).</p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_2">
    <statement>
      <p>
        Consider the following recursive method. What does <c>mystery(4)</c>
        return?
      </p>

      <program language="java">
        <code>
public int mystery(int m)
{
  if (m == 1)
  {
      return 3;
  } else
  {
      return 3 * mystery(m - 1);
  }
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>9</p>
        </statement>

        <feedback>
          <p>This would be true if we called mystery(2).</p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>81</p>
        </statement>

        <feedback>
          <p>
            The argument is 4 so will have 4 recursive calls and then return 3
            when we get to mystery(1). Each call will multiply our result by 3,
            so you can think of this as 3 raised to the 4th power (or 3 * 3 * 3
            * 3 = 81).
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>3</p>
        </statement>

        <feedback>
          <p>
            This value is returned when we call mystery(1), since 1 is the base
            case and doesn't result in a recursive call.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>243</p>
        </statement>

        <feedback>
          <p>This value would be returned from mystery(5).</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>27</p>
        </statement>

        <feedback>
          <p>This value would be returned from mystery(3).</p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_3">
    <statement>
      <p>
        In which of these cases will an ascending order (from smallest to
        largest) insertion sort have the fastest run time?
      </p>

      <program language="java">
        <code>
I.   An array that is in reverse order (from largest to smallest).
II.  An array that is in sorted order already (from smallest to largest).
III. An array that is in random order (not already sorted).
        </code>
      </program>
    </statement>

    <choices>
      <choice correct="yes">
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            If an array is already sorted from smallest to largest then we do
            not need to move anything in the array and we would only need to go
            through each element at most once, so this is fastest run time for
            insertion sort.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>
            An array in reverse order is actually the worst run time for
            insertion sort because we would need to move everything to make it
            in order from smallest to largest.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II only</p>
        </statement>

        <feedback>
          <p>
            II is correct, but number I will actually be the worst run time for
            insertion sort since all values will have to be moved each time
            through the loop.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II and III only</p>
        </statement>

        <feedback>
          <p>
            While II is the correct anwser, an array in random order will have
            average run time.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>III only</p>
        </statement>

        <feedback>
          <p>When the array is not sorted the run time will be average.</p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_4">
    <statement>
      <p>
        Which of these loops will output <c>01234</c>?
      </p>

      <program language="java">
        <code>
int max = 5;

//Loop I
for (int i = 0; i &lt; max; i++)
{
   System.out.print(i);
}


//Loop II
int j = 0;
while (j &lt; max)
{
   System.out.print(j);
   j++;
}


//Loop III
int k = 0;
for (int i = max; i &gt; 0; i--)
{
   System.out.print(i);
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>
            Loop I will produce this output, but it is not the only loop that
            will output these values.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            Loop II will produce this output, but it is not the only loop that
            will output these values.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II and III only</p>
        </statement>

        <feedback>
          <p>
            Loop II is correct, but loop III will produce the reverse output,
            43210.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>I and II only</p>
        </statement>

        <feedback>
          <p>
            Both of these loops will have the correct output. They iterate (and
            print each value) starting from 0 until the max value which we
            defined earlier in our code.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I, II, and III</p>
        </statement>

        <feedback>
          <p>
            While loop I and II will produce the correct output, loop III will
            actually produce the reverse of the correct output.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_5">
    <statement>
      <p>
        Consider the following block of code. What are the first and last
        numbers printed after running the code?
      </p>

      <program language="java">
        <code>
int value = 15;
while (value &lt; 30)
{
    value++;
    System.out.println(value);
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>First: 15 Last: 29</p>
        </statement>

        <feedback>
          <p>
            We add 1 to value before actually printing it, so the first value
            printed will be 16. The last time through the loop the value will be
            29 (less than 30) but then the code will add one so it will print
            30.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>First: 15 Last: 30</p>
        </statement>

        <feedback>
          <p>
            We add 1 to value before actually printing it, so the first value
            printed will be 16.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>First: 16 Last: 29</p>
        </statement>

        <feedback>
          <p>
            The last time through the loop the value will be 29 (less than 30)
            but then the code will add one so it will print 30.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>First: 16 Last: 30</p>
        </statement>

        <feedback>
          <p>
            The code adds one to value before the value is printed so 16 will be
            the first value printed. The last time through the loop the value
            will be 29 (less than 30) but then the code will add one so it will
            print 30.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>First: 16 Last: 28</p>
        </statement>

        <feedback>
          <p>
            The last time through the loop the value will be 29 (less than 30)
            but then the code will add one so it will print 30.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_6">
    <statement>
      <p>
        Consider the following block of code. What value is returned from
        <c>solution(5)</c>?
      </p>

      <program language="java">
        <code>
public int solution(int limit)
{
  int s = 0;

  for (int outside = 1; outside &lt;= limit; outside++)
  {
      for (int middle = 1; middle &lt;= limit; middle++)
      {
          for (int inside = 1; inside &lt;= limit; inside++)
          {
              s++;
          }
      }
  }
  return s;
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>25</p>
        </statement>

        <feedback>
          <p>
            This would be correct if we only had one inner for loop, but there
            are two.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>15</p>
        </statement>

        <feedback>
          <p>
            The outer loop will execute 5 times, each time the outer loop
            executes the middle loop will execute 5 times, and each time the
            middle loop executes the inner loop will execute 5 times. So the
            answer is 5 * 5 * 5 = 125.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>125</p>
        </statement>

        <feedback>
          <p>
            The number of times a loop executes is (largest value in loop -
            smallest value in loop + 1) each loop executes (5 - 1 + 1 = 5)
            times. When you have nested loops you multiply the number of times
            each loop executes. So the result is 5 for the outer loop * 5 for
            the middle loop * 5 for the innermost loop.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>64</p>
        </statement>

        <feedback>
          <p>
            This would be correct if we called solution(4) or the conditions to
            stop each loop were just less than, and not less than or equal to.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>625</p>
        </statement>

        <feedback>
          <p>
            If you got this value you probably made one extra call to the each
            of the loops, notice that the loops start at 1 and not 0.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_7">
    <statement>
      <p>
        Given that both <c>count</c> and <c>n</c> are integer values, which of
        the following statements is true about both code blocks?
      </p>

      <program language="java">
        <code>
// Code block I
for (count = 0; count &lt;= n; count++)
{
    System.out.println(count);
}

//Code block II
count = 0;
while (count &lt;= n)
{
    count = count + 1;
    System.out.println(count);
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I and II are exactly equivalent for all input values n.</p>
        </statement>

        <feedback>
          <p>
            I and II will never be equivalent because because count is
            incremented after it is printed in Code block I and before it is
            printed in Code block II.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II are only equivalent when n is an even number.</p>
        </statement>

        <feedback>
          <p>I and II are not equivalent when n is even.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II are only equivalent when n = 0</p>
        </statement>

        <feedback>
          <p>
            When n = 0, Code block I will print out 0, while Code block 2 will
            print out 1.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II are equivalent for all values except when n = 0</p>
        </statement>

        <feedback>
          <p>The code blocks never output the same value.</p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>I and II are never going to have the exact same outputs.</p>
        </statement>

        <feedback>
          <p>
            I and II will never be equivalent because count is incremented after
            it is printed in Code block I and before it is printed in Code block
            II.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_8">
    <statement>
      <p>
        Consider the following class declarations. Which statements are true?
      </p>

      <program language="java">
        <code>
 public class Animal
 {
  /* Some code */
 }

 public class Cat extends Animal
 {
    /* Some code */
 }

I. Cat inherits the constructors of Animal
II. Cat cannot add new methods and private instance variables that Animal does not have.
III. Cat can override existing public methods of Animal
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>A subclass needs to specify its own constructors.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            A subclass has the ability to add new methods and variables that are
            unique to it (meaning its parent class dosen't contain them)
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>III only</p>
        </statement>

        <feedback>
          <p>
            Subclasses can overide public methods from their parent classes to
            specialize behavior.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II</p>
        </statement>

        <feedback>
          <p>Neither of these statements are true.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II and III</p>
        </statement>

        <feedback>
          <p>Statement III is correct, but not statement II.</p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_9">
    <statement>
      <p>
        Consider the following code. What is the maximum amount of times that
        <c>HELLO</c> could possibly be printed?
      </p>

      <program language="java">
        <code>
for (int i = 0; i &lt;= k; i++)
{
   if (arr[i] &lt; someValue)
   {
     System.out.print("HELLO")
   }
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>k</p>
        </statement>

        <feedback>
          <p>
            This would be the case if i had the initial value 1 and arr[i] &lt;
            someValue would be true for all i values.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>k + 1</p>
        </statement>

        <feedback>
          <p>
            If arr[i] &lt; someValue for all i from 0 to k, HELLO will be
            printed on each iteration of the for loop. The number of times a
            loop executes is the biggest value in the loop - the smallest value
            in the loop + 1 (k - 0 + 1 is k + 1).
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>k - 1</p>
        </statement>

        <feedback>
          <p>
            This would be the case if i had the initial value 2 and arr[i] &lt;
            someValue would be true for all i values.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>1</p>
        </statement>

        <feedback>
          <p>
            This would be the case if only one element in the array would
            fulfill the condition that arr[i] &lt; someValue.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>0</p>
        </statement>

        <feedback>
          <p>
            This is the minimum number of times that HELLO could be executed.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_10">
    <statement>
      <p>
        When will the method <c>stringRecursion</c> produce a run time error?
      </p>

      <program language="java">
        <code>
public void stringRecursion(String s)
{

  if (s.length() &lt; 16)
  {
    System.out.println(s);
  }
  stringRecursion(s + "*");
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>It will never produce a run time error.</p>
        </statement>

        <feedback>
          <p>
            Since there is no terminating condition surrounding our recursive
            method call (because the call lies outside of the if statement), it
            will keep doing recursive calls until we eventually get a run time
            error.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>It will always produce a run time error.</p>
        </statement>

        <feedback>
          <p>
            Since there is no statement that terminates the recursive call to
            stringRecursion (the length of the string s will increase until it
            is greater than 16, but the recursive call will keep happening
            because the recursive call is outside the if statement) the computer
            will keep doing recurisve calls until it runs out of memory and a
            run time error will happen.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>
            Only when the length of the input string is greater than or equal to
            16.
          </p>
        </statement>

        <feedback>
          <p>
            Since the recursive call is outside the condition and the
            conditional doesn't include a return then this will result in
            infinite recursion and eventually a run time error.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>Only when an empty string is input.</p>
        </statement>

        <feedback>
          <p>
            The length of the string will not matter in this case because the
            recursive call to stringRecursion will always happen, since the
            recursive call lies outside the body of the conditional. The string
            length will only determine if the string s is printed out to the
            console or not.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>Whenever the input string length is less than 16.</p>
        </statement>

        <feedback>
          <p>
            We will get run time errors regardless of the length of the string
            s. This is due to the fact that the recursive call lies outside the
            body of the conditional. If the length of the string s is less than
            16 then we will get something printed out to the console until the
            length of s becomes greater than 16, and then we will continue in a
            infinite recursion.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_11">
    <statement>
      <p>
        Consider the following class definitions. Which of I, II and III below
        would cause an error when used in place of the missing code in the main
        method?
      </p>

      <program language="java">
        <code>
public class A
{
  public void method1() { };
}

public class B extends A
{
    // Instance variables and other methods not shown

    public void method1()
    {
      /* implementation not shown */
    }
}

public class C extends B
{
  //Instance variables and other methods not shown

  public void method2(C o)
  {
     /* implementation not shown */
  }

  public static void main(String[] args)
  {
    C objectC = new C();
    B objectB = new B();
    // Missing code
  }
}

I objectC.method1();
II objectB.method2(objectC);
III objectC.method2(objectB);
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>
            This method call compiles because class C inherits all the public
            methods in class B. This will not produce an error.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            Method II will produce a compile time error because class B (the
            superclass) does not inherit the methods of class C due to the fact
            that class C is its subclass. But, it is not the only call that will
            result in a compile time error.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>II and III only</p>
        </statement>

        <feedback>
          <p>
            Method II will produce a compile time error because class B (the
            superclass) does not inherit the methods of class C due to the fact
            that class C is its subclass. Method III will produce an error
            because of the parameter it takes in. objectB is not a class C type
            object which is what the method definition for method III required.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>III only</p>
        </statement>

        <feedback>
          <p>
            This method produces a compile time error, but method II will also
            produce a compile time error.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I, II and III</p>
        </statement>

        <feedback>
          <p>
            Methods II and III will both produce compile time errors, but method
            I works because class C inherits all the public methods of class B.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_12">
    <statement>
      <p>
        Which of these declarations will <em>not</em> cause an error?
      </p>

      <program language="java">
        <code>
I ArrayList&lt;String&gt; stringList = new List&lt;String&gt;();
II ArrayList&lt;int&gt; intList = new ArrayList&lt;int&gt;();
III ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>Use type ArrayList to create the object, not List.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            The type parameter in a generic ArrayList must be a class type, not
            a primitive type. int is a primitive type.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>III only</p>
        </statement>

        <feedback>
          <p>Correct.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II and III</p>
        </statement>

        <feedback>
          <p>
            III is correct, but II will cause a compile time error since we
            cannot use a primitive (int) as the type parameter in a generic
            ArrayList.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and II</p>
        </statement>

        <feedback>
          <p>Both of these solutions will cause an error.</p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_14">
    <statement>
      <p>
        Suppose that the following method takes in a two dimensional array
        called <c>matrix</c>. After the method call <c>printMatrix(matrix)</c>
        what will the output be? Possible options are listed below the method
        definition.
      </p>

      <program language="java">
        <code>
/* assume that matrix has the following values */
7654
3210
4567
0123

public static void printMatrix(int[][] matrix)
{
  for (int i = 0; i &lt; matrix.length; i++)
  {

    for (int t = 0; t &lt; i; t++)
    {
      System.out.print(matrix[i][t]);
    }
    System.out.println();
  }
}

Possible output:

I.
7654
3210
4567
0123

II.
7
32
456
0123

III.
3
45
012

IV.
7
3
4
0
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I</p>
        </statement>

        <feedback>
          <p>
            Since the inside for loop starts with t = 0 and continues while t
            &lt; i (and i begins at 0) it will not be print out every single
            element of the 4x4 matrix.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II</p>
        </statement>

        <feedback>
          <p>
            This anwser is not correct because our inside for loop will start
            with t = 0 and loop while t &lt; i and, as such, the entire first
            row of our matrix will be ignored, since both t and i = 0 and t is
            not less than i.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>III</p>
        </statement>

        <feedback>
          <p>
            When i = 0, the inner for loop does not get executed and the entire
            first row of the matrix is ignored. When i = 1 t goes from 0 to 0
            and the element matrix[1][0] will be printed out. Similarly, when i
            = 2 we will print out elements matrix[2][0] and matrix[2][1].
            Finally, when i = 3, we will print out matrix[3][0], matrix[3][1]
            and matrix[3][2].
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>IV</p>
        </statement>

        <feedback>
          <p>
            This would be the correct anwser if we kept incrementing i by one
            (the outer for loop) but the inner for variable t would always be 0.
            We would get the first element of each row.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>An ArrayIndexOutOfBoundsException will be thrown.</p>
        </statement>

        <feedback>
          <p>
            We will not get an index out of bounds exception since we made sure
            to increment i only until the max length of the array and the other
            variable we use to index, t, will only increase while it is still
            less than i.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_15">
    <statement>
      <p>
        If randomList is an <c>ArrayList</c> of <c>Integer</c> objects and is
        initially set to {0, 1, 2, 3}, what will randomList look like after the
        following code is executed?
      </p>

      <program language="java">
        <code>
randomList.add(5);
randomList.add(7);
int randomNum = randomList.get(2);
randomList.remove(2);
randomList.add(randomNum, 4);
randomList.set(1, 8);
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>[0, 1, 2, 3, 5, 7]</p>
        </statement>

        <feedback>
          <p>
            This is what the ArrayList will look like after the first two
            operations in the code.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>[0, 1, 4, 3, 5, 7]</p>
        </statement>

        <feedback>
          <p>
            This is what the ArrayList will look like before we set the element
            at index 1 to be 8.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>[0, 8, 3, 4, 5, 7]</p>
        </statement>

        <feedback>
          <p>
            This is what would have happened if we thought randomNum was
            actually 3 and we added the number 4 at the incorrect index.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>[0, 8, 4, 3, 5, 7]</p>
        </statement>

        <feedback>
          <p>
            After we add 5 and 7 to the end of the array we remove the element
            at index 2 (which was 2). Then we use the index we had previously
            obtained (also 2) to add a new element 4. This pushes the element
            already at that index (and the ones after it) one space to the
            right. Fianlly, we set the element at index 1 to be 8. This sets the
            value at index 1 to 8.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>[5, 7, 0, 8, 4, 3]</p>
        </statement>

        <feedback>
          <p>
            This is what we would have happened if we thought the add method
            would add elements to the beggining of the ArrayList and not the
            end.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_16">
    <statement>
      <p>
        Consider the following code segment. What will be printed as a result of
        executing the code below?
      </p>

      <program language="java">
        <code>
String str = "fedcba";
int counter = 0;
while(counter &lt; str.length() - 1)
{
  System.out.print(str.substring(counter + 1, counter + 2));
  counter++;
}
        </code>
      </program>
    </statement>

    <choices>
      <choice correct="yes">
        <statement>
          <p>edcba</p>
        </statement>

        <feedback>
          <p>
            The substring method takes two arguments, a start index (which is
            inclusive) and an end index (which is exclusive). The first
            substring is from index 1 (counter + 1) to index 2 (counter + 2).
            However the second index is not included so its just index 1 which
            is e. We then simply keep getting every indidual element from the
            string one by one until the end of the string.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>edcb</p>
        </statement>

        <feedback>
          <p>
            This substring is mostly correct but it ends early and is missing
            the a character at the end.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>
            Nothing is printed because an IndexOutOfBoundsException is thrown.
          </p>
        </statement>

        <feedback>
          <p>
            Even though the end of the substring is specified as index counter +
            2, which will be past the end of the string the last time through
            the loop, substring doesn't include the value at the end index, so
            the code will execute.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>feeddccbba</p>
        </statement>

        <feedback>
          <p>
            The first substring element has a start value of index 1 and so f
            will not be printed out. Also because each substring is a single
            character, no character will be repeated in the substring.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>fededcdcbcba</p>
        </statement>

        <feedback>
          <p>
            This is what we would have happened if the substring had started at
            index counter (and not index counter + 1).
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_17">
    <statement>
      <p>
        Consider the following class declarations. Which of the following
        statements will not compile?
      </p>

      <program language="java">
        <code>
public class B
{

    public int myValue;

    public B()
    {
        myValue = 0;
    }

    public B(int x)
    {
        myValue = x;
    }
}

public class C extends B
{

    public C()
    {
        super(0);
    }
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>C c1 = new C();</p>
        </statement>

        <feedback>
          <p>
            Here we are simply creating a new instance of class C by calling the
            appropiate constructor. Nothing is wrong here.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>B b1 = new B();</p>
        </statement>

        <feedback>
          <p>
            Here we are simply creating a new instance of class B by calling the
            appropiate constructor. Nothing is wrong here.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>B c2 = new C();</p>
        </statement>

        <feedback>
          <p>
            Since class C is a subclass of class B, you can upcast an object of
            type C to be of type B.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>B b3 = new B(10);</p>
        </statement>

        <feedback>
          <p>
            This statement is creating a new object using the second constructor
            of the B class. This is also a valid way to create a B object.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>C c3 = new C(24);</p>
        </statement>

        <feedback>
          <p>
            Even though class C has a super class with a constructor that takes
            in a single int argument, class C does not have a constructor that
            takes an int value.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_18">
    <statement>
      <p>
        Consider the following method. Assume that <c>String s = "rain";</c> and
        <c>int b = 4;</c> have been executed. What are the values of <c>s</c>
        and <c>b</c> after <c>test(s,b)</c> is executed?
      </p>

      <program language="java">
        <code>
public static void test(String str, int y)
{
   str = str + "bow";
   y = y * 2;
}
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>s="rainbow"; b=8;</p>
        </statement>

        <feedback>
          <p>
            Strings are immutable so changing str doesn't affect the string that
            s refers to. The value of b also will not change since Java passes a
            copy of the value.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>s="rain"; b=8;</p>
        </statement>

        <feedback>
          <p>
            Java copies the value of primitive types when they are passed to
            methods so nothing done in the method test affects the value of b.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>s="rainbow"; b=4;</p>
        </statement>

        <feedback>
          <p>
            Strings are immutable so changing str doesn't affect the string that
            s refers to.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>s="rain"; b=4;</p>
        </statement>

        <feedback>
          <p>
            Since strings are immutable any change returns a new string and
            doesn't affect what s refers to. Also the value of primitive types
            are copied and nothing done in test affects the orignal primitive
            value.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>s="bow"; b=4;</p>
        </statement>

        <feedback>
          <p>
            The string that s refers to is not changed by the test method. All
            changes to string result in a new string object.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_19">
    <statement>
      <p>
        Which of the following is/are true about using insertion sort versus
        using merge sort?
      </p>

      <program language="java">
        <code>
I. Insertion sort requires more storage space than mergesort.
II. Insertion sort is only more efficient than mergesort in the case that we have a very small and nearly sorted array.
III. Insertion sort is almost always less efficient than mergesort.
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I only</p>
        </statement>

        <feedback>
          <p>
            Merge sort often uses a temporary array when merging arrays, which
            means it actually uses more storage space than insertion sort.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II only</p>
        </statement>

        <feedback>
          <p>
            Insertion sort is more efficient for a small array because merge
            sort has extra overhead from the recursive function calls that cause
            it to take longer.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>III only</p>
        </statement>

        <feedback>
          <p>
            Merge sort uses the "divide and conquer" approach to sort an array.
            This will end up being more efficient than insertion sort in the
            case where we have a long unordered array.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>I and III</p>
        </statement>

        <feedback>
          <p>
            Statement III is true but statement I is false since mergesort often
            utilizes a temporary array and will actually require more storage
            space than insertion sort.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>II and III</p>
        </statement>

        <feedback>
          <p>
            Merge sort uses the "divide and conquer" approach to sort an array.
            This will end up being more efficient than insertion sort in the
            case where we have long unordered array. However if we have a very
            small almost sorted array, then insertion sort will outperform merge
            sort.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <activity label="qtnt1_20">
    <statement>
      <p>
        What would the contents of <c>matrix</c>, a 2-D array of integers, be
        after a call to <c>alter(1)</c>? The method alter is defined below.
      </p>

      <program language="java">
        <code>
  private int[][] matrix;

  /* matrix looks like this initially
  1 3 5 7
  2 4 6 8
  3 5 7 9
  */

  public void alter(int c)
  {
    for (int i = 0; i &lt; matrix.length; i++)
    {
      for (int j = c + 1; j &lt; matrix[0].length; j++)
      {
        matrix[i][j - 1] = matrix[i][j];
      }
    }
  }


I. 1 7 7 7
   2 8 8 8
   3 9 9 9

II. 1 5 7
    2 6 8
    3 7 9

III. 1 3 5 7
     3 5 7 9

IV. 1 3 5 7
    3 5 7 9
    3 5 7 9

V. 1 5 7 7
   2 6 8 8
   3 7 9 9
        </code>
      </program>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>I</p>
        </statement>

        <feedback>
          <p>
            The method alter shifts the values in the columns starting at column
            c + 1 and shifting back to entry to the left of c + 1. This matrix
            is what would result if c was three and we were shifitng the number
            there to the two spots before it.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>II</p>
        </statement>

        <feedback>
          <p>
            Although some numbers are overwriten in the matrix, the matrix will
            still be 3x4 matrix.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>III</p>
        </statement>

        <feedback>
          <p>
            Although some numbers are overwriten in the matrix, the matrix will
            still be 3x4 matrix.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>IV</p>
        </statement>

        <feedback>
          <p>
            This is what would happen if we were shifting rows instead of
            columns in the alter method.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>V</p>
        </statement>

        <feedback>
          <p>
            Method alter shifts the values in the columns, starting at column c
            + 1, one column to the left. It also overwrites column c. Here are
            the replacements made for the method call alter(1): matrix[0][1] =
            matrix[0][2], matrix[0][2] = matrix[0][3], matrix[1][1] =
            matrix[1][2], matrix[1][2] = matrix[1][3], matrix[2][1] =
            matrix[2][2], matrix[2][2] = matrix[2][3]
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>
</section>
