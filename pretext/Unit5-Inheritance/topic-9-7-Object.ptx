<?xml version="1.0"?>
<!-- Generated by Docutils 0.17.1 -->
<section xml:id="topic-9-7-Object">
  <title>Object Superclass</title><introduction>
    
    <p>The <c>Object</c> class is the superclass of all other classes in Java and a part
            of the built-in <c>java.lang</c> package. If a parent class isn’t specified using
            the <c>extends</c> keyword, the class will inherit from the <c>Object</c> class. What
            does a class inherit from the <c>Object</c> class? The <url href="https://apstudents.collegeboard.org/ap/pdf/ap-computer-science-a-java-quick-reference_0.pdf" visual="https://apstudents.collegeboard.org/ap/pdf/ap-computer-science-a-java-quick-reference_0.pdf">AP CSA Java Quick Reference Sheet</url>
            lists the two main methods that are most frequently used:</p>
    <p>
      <ul>
            <li>
                <p><c>String toString()</c></p>
            </li>
            <li>
                <p><c>boolean equals(Object other)</c></p>
            </li>
        </ul>
    </p>
  </introduction>
  <subsection>
            <title><c>toString()</c> method</title>
            <p>One commonly overridden <c>Object</c> method is <c>toString()</c>, which is often used
                to print out the attributes of an object. It is a good idea to write your own
                <c>toString()</c> method in every class. In a subclass, <c>toString()</c> can call the
                superclass <c>toString()</c> method using <c>super.toString()</c> and then add on its
                own attributes.</p>
            <p>In the following code, the <c>Person</c> class overrides the <c>toString</c> method
                from <c>Object</c> method and the <c>Student</c> class then overrides it again. In
                each class the new <c>toString</c> method adds the new attributes from that class.</p>

<exercise label="toStringDemo">
    <statement>
            <p>After trying the code below, complete the subclass called <c>APStudent</c> that
                extends <c>Student</c> with a new attribute called <c>APscore</c> and override the
                <c>toString()</c> method to call the superclass method and then add on the
                <c>APscore</c>. Uncomment the <c>APStudent</c> object in the main method to test it.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class Person
{
    private String name;

    public Person(String name)
    {
        this.name = name;
    }

    public String toString()
    {
        return name;
    }

    public static void main(String[] args)
    {
        Person p = new Person("Sila");
        Student s = new Student("Tully", 1001);
        System.out.println(p); // call Person toString
        System.out.println(s); // call Student toString
        // Uncomment the code below to test the APStudent class
        /*
        APStudent ap = new APStudent("Ayanna", 1002, 5);
        System.out.println(ap);
        */
    }
}

class Student extends Person
{
    private int id;

    public Student(String name, int id)
    {
        super(name);
        this.id = id;
    }

    public String toString()
    {
        return super.toString() + " " + id;
    }
}

class APStudent extends Student
{
    private int score;

    public APStudent(String name, int id, int score)
    {
        super(name, id);
        this.score = score;
    }
    // Add a toString() method here that calls the super class toString

}

  </code><tests>
  import static org.junit.Assert.*;

  import org.junit.*;

  import java.io.*;

  public class RunestoneTests extends CodeTestHelper
  {
      public RunestoneTests()
      {
          super("Person");
      }

      @Test
      public void test1()
      {
          String output = getMethodOutput("main");
          String expect = "Sila\nTully 1001\nAyanna 1002 5";

          boolean passed = getResults(expect, output, "Checking output from main()");
          assertTrue(passed);
      }

      @Test
      public void containsToString()
      {
          String code = getCode();
          String target = "public String toString()";

          int num = countOccurencesRegex(code, target);
          boolean passed = (num &gt;= 3);

          getResults("3", "" + num, "3 toString methods", passed);
          assertTrue(passed);
      }
  }
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title><c>equals</c> Method</title>
            <p>One of the important methods inherited from <c>Object</c> is the <c>equals(Object
obj)</c> method. This method is used to test if the current object and the passed
                object called <c>obj</c> are equal. But what does that mean?</p>
            
            
            <p>As you can see if you run the code below, the <c>equals</c> method inherited from
                <c>Object</c> only returns <c>true</c> if the two objects references refer to the same
                object. In other words it is does the same test as <c>==</c>.</p>

<exercise label="ObjEquals">
    <statement>
            <p>Try to guess what this code will print out before running it.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class Person
{
    private String name;

    public Person(String theName)
    {
        this.name = theName;
    }

    public static void main(String[] args)
    {
        Person p1 = new Person("Kairen");
        Person p2 = new Person("Jewel");
        Person p3 = new Person("Kairen");
        Person p4 = p3;
        System.out.println(p1.equals(p2));
        System.out.println(p2.equals(p3));
        System.out.println(p1.equals(p3));
        System.out.println(p3.equals(p4));
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("Person");
    }

    @Test
    public void test1()
    {
        String output = getMethodOutput("main");
        String expect = "false\nfalse\nfalse\ntrue";

        boolean passed = getResults(expect, output, "Checking output from main()", true);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
            <figure align="center"><caption xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">A picture from the Java Visualizer showing that only p3 and p4 refer to the same object.</caption><image source="Unit5-Inheritance/Figures/equalsEx.png" width="54%%"/></figure>
        </subsection>
  <subsection>
            <title>Overriding the <c>equals</c> Method</title>
            <p>The <c>equals</c> method defined in <c>Object</c> and thus inherited by all classes
                only considers two object references equivalent if they refer to exactly the
                same object. But we saw in Unit 2 that the <c>String</c> class provides an
                <c>equals</c> method that considers two <c>String</c> objects equivalent if they have
                the same characters in the same order, even if they are actually different
                objects. How does that work?</p>
            <p>It is because the <c>String</c> class has <term>overridden</term> the <c>equals</c> method it
                inherited from <c>Object</c> to provide a definition of equality that makes more
                sense.</p>
            <p>As we saw in section 9.3 a class can override inherited methods by providing a
                method with the same method signature (method name, parameter types, and return
                type). <c>String</c> has done that with <c>equals</c> so when we compare <c>String</c>
                objects with <c>equals</c> that new method will be called instead of the inherited
                one.</p>

<exercise label="StringTest1">
    <statement>
            <p>Try to guess what this code will print out before running it.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class StringTest
{
    public static void main(String[] args)
    {
        String s1 = "hi";
        String s2 = "Hi";
        String s3 = new String("hi");
        System.out.println(s1.equals(s2));
        System.out.println(s2.equals(s3));
        System.out.println(s1.equals(s3));
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("StringTest");
    }

    @Test
    public void test1()
    {
        String output = getMethodOutput("main");
        String expect = "false\nfalse\ntrue";

        boolean passed = getResults(expect, output, "Checking output from main()", true);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
            <p>However, overriding <c>equals</c> is a bit more involved than overriding
                <c>toString</c>. While the <c>toString</c> method is only required to produce a
                reasonable human-readable <c>String</c> representation of an object, <c>equals</c> has
                to meet a more complex set of requirements in order to be useful.</p>
            <p>You will not be expected to write your own <c>equals</c> method on the AP exam but
                it’s worth looking at what those requirements are and how to satisify them.
                There are five requirements described in the Javadocs for <c>equals</c> in
                <c>Object</c> that a properly implemented <c>equals</c> must satisfy:</p>
            <p><ol marker="1">
                <li>
                    <p>Equality is <term>reflexive</term>, meaning an object will be <c>equals</c> to itself:
                        <c>o.equals(o)</c> is <c>true</c>.</p>
                </li>
                <li>
                    <p>Equality is <term>symmetric</term>: <c>o1.equals(o2)</c> returns the same value as
                        <c>o2.equals(o1)</c>.</p>
                </li>
                <li>
                    <p>Equality is <term>transitive</term>: if <c>o1.equals(o2)</c> and <c>o2.equals(o3)</c> then
                        <c>o1.equals(o3)</c>.</p>
                </li>
                <li>
                    <p>Equality is <term>consistent</term>: <c>o1.equals(o2)</c> always returns the same value
                        assuming the objects are not modified.</p>
                </li>
                <li>
                    <p>No object is equal to <c>null</c>: <c>o.equals(null)</c> is always <c>false</c>.</p>
                </li>
            </ol></p>
            <p>The other way to look at these requirements is as guarantees that are made to
                you as a user of <c>equals</c>. If you look at it that way, these requirements are
                quite nice. Imagine how much harder it would be to use the <c>String</c> equals
                method if you couldn’t rely on the fact that <c>s1.equals(s2)</c> is necessarily
                the same as <c>s2.equals(s1)</c>!</p>
            <p>So even though the Java compiler can’t force you to implement <c>equals</c>
                correctly, if you ever do want to override it, it’s important that you do. Let’s
                look at what’s involved.</p>
            <p>We’ll write a class <c>Word</c> which represents a word in a particular language.
                We want two <c>Word</c> objects to be considered <c>equals</c> if and only if they are
                spelled the same <title_reference>and</title_reference> come from the same language. The latter requirement is
                because sometimes different languages have words that are spelled the same but
                with different meanings such as “pie” which in English is a tasty baked treat
                and in Spanish is what we call a “foot” in English.</p>

<exercise label="OverrideEquals">
    <statement>
            <p>Try to guess what this code will print out before running it. Click on the
                CodeLens button to step forward through the code and watch the memory.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class Word
{
    private String spelling;
    private String language;

    public Word(String spell, String lang)
    {
        this.spelling = spell;
        this.language = lang;
    }

    /**
     * Compares this word to the specified object. The result is true if and only
     * if the argument is not null and is a Word object with the same spelling and
     * language as this object.
     */
    public boolean equals(Object other)
    {
        if (this == other)
        {
            // This is not strictly necessary assuming the rest
            // of the method is implemented correctly but it is
            // a commonly used optimization because the == check
            // is very fast. Thus this is a quick way to guarantee
            // that our equals method is reflexive.
            return true;
        }

        if (!(other instanceof Word))
        {
            // It can't be the same Word if it's not a Word at all.
            // This also ensures that o.equals(null) is false because
            // null is not an instanceof any class.
            return false;
        }

        // Now we now we can safely cast other to a Word and
        // check if our two attributes are the same, using
        // equals to compare them because they are Strings.
        Word otherWord = (Word) other;
        return spelling.equals(otherWord.spelling)
                &amp;&amp; language.equals(otherWord.language);
    }

    public static void main(String[] args)
    {
        Word p1 = new Word("pie", "english");
        Word p2 = new Word("pie", "spanish");
        Word p3 = new Word("pie", "english");
        Word p4 = p3;
        System.out.println(p1.equals(p2));
        System.out.println(p2.equals(p3));
        System.out.println(p1.equals(p3));
        System.out.println(p3.equals(p4));
        System.out.println(p1.equals("pie"));
    }
}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("Word");
    }

    @Test
    public void test1()
    {
        String output = getMethodOutput("main");
        String expect = "false\nfalse\ntrue\ntrue\nfalse";

        boolean passed = getResults(expect, output, "Checking output from main()", true);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
            <p>The basic recipe for writing your own equals method, is:</p>
            <p><ol marker="1">
                <li>
                    <p>Use the <c>public boolean equals(Object other)</c> method signature. Make sure
                        the parameter type is <c>Object</c>, not the class you are defining.</p>
                </li>
                <li>
                    <p>Check of <c>this == other</c> to quickly return <c>true</c> when comparing an
                        object to itself.</p>
                </li>
                <li>
                    <p>Use <c>instanceof</c> to check if <title_reference>other</title_reference> is an instance of this class and
                        return <c>false</c> if not.</p>
                </li>
                <li>
                    <p>Cast <c>other</c> to the current class.</p>
                </li>
                <li>
                    <p>Finally compare this object’s attributes to the other object’s with <c>==</c>
                        for primitive types like <c>int</c> and <c>double</c> and <c>equals</c> for reference
                        types. If you need to compare multiple attributes <c>&amp;&amp;</c> together the
                        comparisons of the individual attributes since two objects should only be
                        equal if <title_reference>all</title_reference> the attributes match.</p>
                </li>
            </ol></p>
            <p>Note that the requirements on <c>equals</c> make it almost impossible to correctly
                override it in a subclass of a class that has already overridden the <c>Object</c>
                version. To see why, imagine if we made a subclass of <c>Word</c>,
                <c>ClassifiedWord</c> and added another attribute, <c>partOfSpeech</c>.</p>
            <p>If we override <c>equals</c> in the <c>ClassifiedWord</c> to only consider two
                <c>ClassifiedWord</c> objects <c>equals</c> if their spelling, language, <title_reference>and</title_reference> part of
                speech match, that will break the symmetry since
                <c>regularWord.equals(classifiedWord)</c> will invoke the <c>equals</c> from <c>Word</c>
                which will only compare the spelling and language of the word but
                <c>classifiedWord.equals(regularWord)</c> will return <c>false</c> assuming the
                <c>equals</c> in <c>ClassifiedWord</c> checks that <c>other</c> is an <c>instanceof
ClassifiedWord</c>. In general you should only provide an overridden <c>equals</c>
                method in one class in a class hierarchy.</p>
        </subsection>
  <subsection>
            <title>Coding Challenge : Savings Account</title>
            <p>The following code contains the beginning of a class for representing a bank
                account containing the account holder’s name and the money balance in the
                account.</p>
            <p>Work in pairs to write the following code and test each part before moving on to
                the next step:</p>
            <p><ol marker="1">
                <li>
                    <p>Implement a <c>toString</c> method in <c>Account</c> that returns a <c>String</c>
                        representing the instance variables in <c>Account</c> in the form name, comma,
                        space, balance.</p>
                </li>
                <li>
                    <p>Write a subclass called <c>SavingsAccount</c> that extends <c>Account</c> and adds
                        an interest rate variable.</p>
                </li>
                <li>
                    <p>Write a constructor with 3 arguments (name, balance, interest rate) for the
                        <c>SavingsAccount</c> class that uses the super constructor.</p>
                </li>
                <li>
                    <p>Write a <c>toString</c> method for <c>SavingsAccount</c> that returns a string
                        consisting of the result of the superclass’s <c>toString</c> plus a comma, a
                        space, and the interest rate.</p>
                </li>
            </ol></p>

<exercise label="challenge-9-7-savingsaccount">
    <statement>
            <p>Complete the subclass <c>SavingsAccount</c> below which inherits from
                <c>Account</c> and adds an interest rate variable. Write a constructor with 3
                arguments, a <c>toString</c>, and an <c>equals</c> method for it. Uncomment the
                code in <c>main</c> to test your new class and methods.</p>

    </statement>
    <program interactive="activecode" language="java">
        <code>
public class Account
{
    private String name;
    private double balance;

    public Account(String name, double balance)
    {
        this.name = name;
        this.balance = balance;
    }

    // Implement toString here

    public static void main(String[] args)
    {
        Account acct1 = new Account("Armani Smith", 1500);
        System.out.println(acct1);
        // Uncomment this code to test SavingsAccount
        /*
        SavingsAccount acct2 = new SavingsAccount("Dakota Jones",1500,4.5);
        System.out.println(acct2);
        */
    }
}

/*
 * Write the SavingsAccount class which inherits from Account. Add an
 * interest rate instance variable and write a constructor and a toString
 * method.
 */
class SavingsAccount
{

}

</code><tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    public RunestoneTests()
    {
        super("Account");
    }

    @Test
    public void test1()
    {
        String output = getMethodOutput("main");
        String expect = "Armani Smith, 1500.0\nDakota Jones, 1500.0, 4.5";

        boolean passed = getResults(expect, output, "Checking output from main()");
        assertTrue(passed);
    }

    @Test
    public void test3()
    {
        String target = "public String toString()";

        String code = getCode();
        int index = code.indexOf("class SavingsAccount");
        code = code.substring(index);
        boolean passed = code.contains(target);

        getResults(
                "true",
                "" + passed,
                "Checking that code contains toString() in SavingsAccount",
                passed);
        assertTrue(passed);
    }

    @Test
    public void test30()
    {
        String target = "super.toString()";

        String code = getCode();
        int index = code.indexOf("class SavingsAccount");
        code = code.substring(index);

        boolean passed = code.contains(target);

        getResults(
                "true",
                "" + passed,
                "Checking that code contains call to super.toString() in SavingsAccount",
                passed);
        assertTrue(passed);
    }

    @Test
    public void containsExtends()
    {
        String target = "SavingsAccount extends Account";
        boolean passed = checkCodeContains(target);
        assertTrue(passed);
    }
}
        </tests>
    </program>
</exercise>
        </subsection>
  <subsection>
            <title>Summary</title>
            <p><ul>
                <li>
                    <p>The <c>Object</c> class is the superclass of all other classes in Java and a part of the built-in <c>java.lang</c> package.</p>
                </li>
                <li>
                    <p>The following <c>Object</c> class methods are part of the Java Quick Reference:</p>
                    <p><ul>
                        <li>
                            <p><c>String toString()</c></p>
                        </li>
                        <li>
                            <p><c>boolean equals(Object other)</c></p>
                        </li>
                    </ul></p>
                </li>
                <li>
                    <p>Subclasses of Object often override the <c>toString</c> and <c>equals</c> methods
                        with class-specific implementations.</p>
                </li>
                <li>
                    <p>When overriding <c>equals</c>, it’s important to satisfy all the requirements of
                        a correct implementation.</p>
                </li>
            </ul></p>
        </subsection>
</section>
